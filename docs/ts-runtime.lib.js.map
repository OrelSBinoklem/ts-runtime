{"version":3,"sources":["webpack:///ts-runtime.lib.js","webpack:///webpack/bootstrap 5ca473610adcbf958f6f","webpack:///(webpack)/buildin/global.js","webpack:////Users/fabian/Documents/Development/ts-runtime/src/lib/index.ts","webpack:///../src/errorReporting/makeJSONError.js","webpack:///../src/cyclic.js","webpack:///../src/Validation.js","webpack:///../src/errorReporting/makeTypeError.js","webpack:///../src/makeError.js","webpack:///../src/compareTypes.js","webpack:///../src/getErrorMessage.js","webpack:///../src/types/TypeParameter.js","webpack:///../src/invariant.js","webpack:///../src/typeConstraints.js","webpack:///../src/declarations/ModuleDeclaration.js","webpack:///../src/declarations/ParameterizedClassDeclaration.js","webpack:///../src/types/ObjectType.js","webpack:///../src/types/IntersectionType.js","webpack:///../src/types/ParameterizedTypeAlias.js","webpack:///../src/types/ParameterizedFunctionType.js","webpack:///../src/types/TypeTDZ.js","webpack:///../src/makeReactPropTypes.js","webpack:///../src/errorReporting/makeWarningMessage.js","webpack:///../src/makeUnion.js","webpack:///../src/classDecorators.js","webpack:///../src/annotateValue.js","webpack:///../src/flowTypes/ClassType.js","webpack:///../src/index.cjs.js","webpack:///../src/primitiveTypes.js","webpack:///../node_modules/rollup-regenerator-runtime/regenerator/index.js","webpack:///../src/errorReporting/RuntimeTypeError.js","webpack:///../src/types/Type.js","webpack:///../src/types/AnyType.js","webpack:///../src/errorMessages.js","webpack:///../src/types/TupleType.js","webpack:///../src/types/ArrayType.js","webpack:///../src/types/BooleanLiteralType.js","webpack:///../src/types/BooleanType.js","webpack:///../src/types/EmptyType.js","webpack:///../src/types/ExistentialType.js","webpack:///../src/types/FlowIntoType.js","webpack:///../src/types/FunctionTypeRestParam.js","webpack:///../src/types/FunctionTypeParam.js","webpack:///../src/types/FunctionTypeReturn.js","webpack:///../src/symbols.js","webpack:///../src/types/FunctionType.js","webpack:///../src/types/GeneratorType.js","webpack:///../src/types/TypeParameterApplication.js","webpack:///../src/types/TypeConstructor.js","webpack:///../src/types/GenericType.js","webpack:///../src/types/NullLiteralType.js","webpack:///../src/types/VoidType.js","webpack:///../src/types/NullableType.js","webpack:///../src/types/ObjectTypeProperty.js","webpack:///../src/types/ObjectTypeIndexer.js","webpack:///../src/types/ObjectTypeCallProperty.js","webpack:///../src/declarations/Declaration.js","webpack:///../src/declarations/VarDeclaration.js","webpack:///../src/declarations/TypeDeclaration.js","webpack:///../src/declarations/ModuleExportsDeclaration.js","webpack:///../src/declarations/ClassDeclaration.js","webpack:///../src/types/PartialType.js","webpack:///../src/declarations/ExtendsDeclaration.js","webpack:///../src/types/MixedType.js","webpack:///../src/types/TypeAlias.js","webpack:///../src/types/NumericLiteralType.js","webpack:///../src/types/NumberType.js","webpack:///../src/types/RefinementType.js","webpack:///../src/types/StringLiteralType.js","webpack:///../src/types/StringType.js","webpack:///../src/types/SymbolLiteralType.js","webpack:///../src/types/SymbolType.js","webpack:///../src/types/ThisType.js","webpack:///../src/types/TypeBox.js","webpack:///../src/types/TypeReference.js","webpack:///../src/types/UnionType.js","webpack:///../src/TypeInferrer.js","webpack:///../src/flowTypes/$DiffType.js","webpack:///../src/flowTypes/$FlowFixMeType.js","webpack:///../src/flowTypes/$KeysType.js","webpack:///../src/flowTypes/$ObjMapiType.js","webpack:///../src/flowTypes/$ObjMapType.js","webpack:///../src/flowTypes/$PropertyType.js","webpack:///../src/flowTypes/$ShapeType.js","webpack:///../src/flowTypes/$SubType.js","webpack:///../src/flowTypes/$SuperType.js","webpack:///../src/flowTypes/$TupleMapType.js","webpack:///../src/TypeContext.js","webpack:///../src/globalContext.js","webpack:///../src/registerPrimitiveTypes.js","webpack:///../src/registerBuiltins.js","webpack:///../src/registerTypePredicates.js","webpack:////Users/fabian/Documents/Development/ts-runtime/node_modules/regenerator-runtime/runtime-module.js","webpack:////Users/fabian/Documents/Development/ts-runtime/node_modules/regenerator-runtime/runtime.js"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","g","this","Function","eval","e","value","t","voidType","void","typeOf","undef","bind","nostrict","args","_i","arguments","length","union","apply","concat","null","nullable","enum","enumMember","arg","literal","enumRef","input","declaration","typeName","Class","lib","default","global","factory","makeJSONError","validation","hasErrors","context","errors","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","_ref","_ref2","slicedToArray","path","message","expectedType","expected","toString","actual","resolvePath","field","stringifyPath","pointer","join","push","err","return","inValidationCycle","type","tracked","cyclicValidation","weakSetHas","startValidationCycle","WeakSet","set","weakSetAdd","endValidationCycle","weakSetDelete","inToStringCycle","cyclicToString","has","startToStringCycle","add","endToStringCycle","delete","weakset","parts","Array","part","validIdentifierOrAccessor","test","String","subject","Map","matchPath","candidate","makeTypeError","prefix","collected","RuntimeTypeError","trim","delimiter","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","getErrorMessage","key","_len","params","_key","errorMessages","replace","flowIntoTypeParameter","typeParameter","existing","FlowIntoSymbol","target","invariant","error","Error","captureStackTrace","addConstraints","_subject$constraints","constraints","toConsumableArray","collectConstraintErrors","_len2","_key2","constraint","violation","_regeneratorRuntime","wrap","_context","prev","stop","_marked$1","constraintsAccept","_len3","_key3","indent","lines","split","getPartial","parent","bodyCreator","partial","PartialType","body","isArray","class","shapeID","typeParameters","_len6","typeInstances","_key6","limit","Math","min","typeInstance","bound","intersect","acceptsCallProperties","callProperties","accepts","compareTypeCallProperties","inputCallProperties","identicalCount","loop","callProperty","j","inputCallProperty","acceptsWithIndexers","properties","indexers","seen","indexOf","indexer","acceptsKey","acceptsValue","compareTypeWithIndexers","inputIndexers","inputProperties","isGreater","inputProperty","inputIndexer","acceptsWithoutIndexers","acceptsExact","compareTypeWithoutIndexers","collectErrorsWithIndexers","_i5","_context2","delegateYield","t1","keys","t2","abrupt","_marked","collectErrorsWithoutIndexers","_context3","collectErrorsExact","_context4","t0","getPropertyIndex","mergeProperties","source","typeProp","index","typeCreator","_len7","_key7","function","_len5","_key5","getRevealed","container","RevealedValue","reveal","warnedInstances","RevealedName","emitWarningMessage","warnedInstances$2","mixed","Type","ref","makeReactPropTypes","objectType","output","props","propName","componentName","makeWarningMessage","makeUnion","types","merged","UnionType","mergeUnionTypes","aTypes","bTypes","bType","aType","makePropertyDescriptor","typeSource","propertyName","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","constructor","resolveType","receiver","safeName","className","initializer","config","writable","objectWithoutProperties","propertyPath","_extends","check","assert","warn","originalSetter","annotateValue","TypeSymbol","_ret","v","_typeof","checkGenericType","impl","isPrototypeOf","annotation","getAnnotation","checkType","globalContext","primitiveTypes","obj","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","protoProps","staticProps","assign","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","sliceIterator","arr","_arr","_n","_d","_e","_s","arr2","from","WeakMap","Validation","cyclic","didClear","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_errors","_temp","_this","getPrototypeOf","_TypeError","mark","_Type","ERR_CONSTRAINT_VIOLATION","ERR_EXPECT_ARRAY","ERR_EXPECT_TRUE","ERR_EXPECT_FALSE","ERR_EXPECT_BOOLEAN","ERR_EXPECT_EMPTY","ERR_EXPECT_EXACT_VALUE","ERR_EXPECT_CALLABLE","ERR_EXPECT_CLASS","ERR_EXPECT_FUNCTION","ERR_EXPECT_GENERATOR","ERR_EXPECT_ITERABLE","ERR_EXPECT_ARGUMENT","ERR_EXPECT_RETURN","ERR_EXPECT_N_ARGUMENTS","ERR_EXPECT_INSTANCEOF","ERR_EXPECT_KEY_TYPE","ERR_EXPECT_NULL","ERR_EXPECT_NUMBER","ERR_EXPECT_OBJECT","ERR_EXPECT_PROMISE","ERR_EXPECT_STRING","ERR_EXPECT_SYMBOL","ERR_EXPECT_THIS","ERR_EXPECT_VOID","ERR_INVALID_DATE","ERR_MISSING_PROPERTY","ERR_NO_INDEXER","ERR_NO_UNION","ERR_UNKNOWN_KEY","TupleType","checkPredicate","inputTypes","ArrayType","elementType","inCycle","startCycle","endCycle","BooleanLiteralType","BooleanType","EmptyType","boundOrDefault","recorded","finish","withBinding","id","defaultType","hasError","_hasError","_error","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","param","annotationParam","_param","acceptsType","any","inputReturnType","returnTypeResult","inputParams","inputParam","rest","paramsLength","argsLength","_len4","_key4","empty","GeneratorType","isValid","throw","yieldType","nextType","TypeParameterApplication","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","TypeConstructor","GenericType","_TypeConstructor","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","static","isStatic","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","_Declaration","TypeDeclaration","_typeAlias","typeAlias","addConstraint","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declarations","moduleName","slice","innerContext","import","ModuleExports","ClassDeclaration","errorPath","errorMessage","isSuperClassOf","current","withDeclaration","superClassName","bodyProps","superProps","seenStatic","expand","ParameterizedClassDeclaration","ExtendsDeclaration","ObjectType","exact","getIndexer","hasIndexer","hasCallProperties","IntersectionType","hasConstraints","NumericLiteralType","NumberType","ParameterizedTypeAlias","_TypeAlias","identifier","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","RefinementType","StringLiteralType","JSON","stringify","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","warnedInstances$1","warnedMissing","TypeReference","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","$DiffType","$FlowFixMeType","$KeysType","$ObjMapiType","mapper","applied","invoke","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","ClassType","instanceType","warnedInvalidReferences","TypeContext","mode","TypeInferrer","inferrer","infer","propertyNames","fromParent","getPredicate","predicate","_this2","Boolean","annotate","_target","nameRegistry","var","moduleRegistry","_moduleName$split","_moduleName$split2","head","handlerRegistry","instancePrototype","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","_target3","tail","unshift","_body$properties","_target4","_body","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_len12","_key12","_len13","_key13","tdz","_len14","_key14","_target5","_validation$path","console","_len15","_key15","clauses","pop","pattern","_len16","_key16","tests","clause","wrappedIterator","_len17","_key17","_$PropertyType","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","globalContext$1","freeze","declareTypeConstructor","Date","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref5","_ref6","findKey","Set","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","setPredicate","then","globalContext$2","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","AsyncIterator","resolve","reject","record","hasOwn","__await","enqueue","callInvokeWithMethodAndArg","previousPromise","process","domain","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","GenStateSuspendedYield","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","iteratorSymbol","Op","$Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","reverse","skipTempReset","charAt","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","catch","thrown"],"mappings":"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,MAAMkB,OAAON,KAAiB2T,EgCn7B/K3S,SAAmB,UhCm7BVyP,EgCn7BUiD,EAAAtB,GAAAuB,EAAAlD,GhC09BnB,MApDAqB,IAASzL,EAAS0N,GAgBlBtC,GAAYpL,IACVI,IAAK,SACLjH,MAAOyI,GAAoB6L,KAAK,QAASpS,GgCr7BlCH,EAA6BiB,EAAsB1B,GhCs7BxD,MAAOmH,IAAoBC,KAAK,SAAiBC,GAC/C,OACE,OAAQA,EAASC,KAAOD,EAAShG,MAC/B,IAAK,GACL,IAAK,MACH,MAAOgG,GAASE,SAGrB3G,EAAQtC,UAGbqH,IAAK,UACLjH,MAAO,SgC97BAsB,GhC+7BL,OgC97BK,KhCi8BP2F,IAAK,cACLjH,MAAO,SgC/7BIsB,GhCg8BT,MgC/7BK,MhCk8BP2F,IAAK,WACLjH,MAAO,WACL,MgCh8BK,ShCm8BPiH,IAAK,SACLjH,MAAO,WACL,OACEwB,SgCj8BQ5B,KAAK4B,chCq8BZqF,GgC39B4BwH,ICJ/BhH,IjCm+BJmN,yBiCl+B0B,wBjCm+B1BC,iBiCl+BkB,mBjCm+BlBC,gBiCl+BiB,ejCm+BjBC,iBiCl+BkB,gBjCm+BlBC,mBiCl+BoB,wBjCm+BpBC,iBiCl+BkB,gBjCm+BlBC,uBiCl+BwB,qBjCm+BxBC,oBiCl+BqB,mBjCm+BrBC,iBiCl+BkB,wBjCm+BlBC,oBiCl+BqB,qBjCm+BrBC,qBiCl+BsB,+BjCm+BtBC,oBiCl+BqB,mBjCm+BrBC,oBiCl+BqB,4BjCm+BrBC,kBiCl+BmB,8BjCm+BnBC,uBiCl+BwB,0BjCm+BxBC,sBiCl+BuB,4BjCm+BvBC,oBiCl+BqB,mBjCm+BrBC,gBiCl+BiB,ejCm+BjBC,kBiCl+BmB,mBjCm+BnBC,kBiCl+BmB,oBjCm+BnBC,mBiCl+BoB,wBjCm+BpBC,kBiCl+BmB,mBjCm+BnBC,kBiCl+BmB,mBjCm+BnBC,gBiCl+BiB,uBjCm+BjBC,gBiCl+BiB,oBjCm+BjBC,iBiCl+BkB,uBjCm+BlBC,qBiCl+BsB,4BjCm+BtBC,eiCl+BgB,4CjCm+BhBC,aiCl+Bc,qBjCm+BdC,gBiCl+BiB,oCCzBEC,elCghCnB,QAASA,KAC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","file":"ts-runtime.lib.js","sourcesContent":["window[\"t\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = __webpack_require__(2);\nvar voidType = t.void;\nvar typeOf = t.typeOf;\nt.undef = function () {\n    return voidType.bind(t)();\n};\nt.nostrict = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args.concat([t.null(), t.undef()]));\n};\nt.void = function () {\n    return t.union(t.null(), t.undef());\n};\nt.n = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.nullable.apply(t, args);\n};\nt.enum = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args);\n};\nt.enumMember = function (arg) {\n    return t.literal(arg);\n};\nt.enumRef = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.typeOf.apply(t, args);\n};\nt.typeOf = function (input, declaration) {\n    if (declaration === void 0) { declaration = false; }\n    if (declaration && typeof input === 'string') {\n        input = t.get(input);\n        if (input) {\n            if (input.typeName === 'ClassDeclaration') {\n                return t.Class(input);\n            }\n            return input;\n        }\n    }\n    return typeOf.bind(t)(input);\n};\nexports.lib = t;\nexports.default = t;\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global['flow-runtime'] = factory());\n}(this, (function () { 'use strict';\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nvar primitiveTypes = {};\n\nvar _regeneratorRuntime = __webpack_require__(3);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction makeJSONError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var errors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : null;\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n      var field = stringifyPath(validation.path.concat(path));\n\n      var pointer = '/' + path.join('/');\n\n      errors.push({\n        pointer: pointer,\n        field: field,\n        message: message,\n        expected: expected,\n        actual: actual\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Tracks whether we're in validation of cyclic objects.\nvar cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\n\n\nvar cyclicToString = new WeakSet();\n\nfunction inValidationCycle(type, input) {\n  try {\n    var tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    } else {\n      return weakSetHas(tracked, input);\n    }\n  } catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nfunction startValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nfunction endValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nfunction inToStringCycle(type) {\n  return cyclicToString.has(type);\n}\n\nfunction startToStringCycle(type) {\n  cyclicToString.add(type);\n}\n\nfunction endToStringCycle(type) {\n  cyclicToString.delete(type);\n}\n\nfunction weakSetHas(weakset, value) {\n  try {\n    return weakset.has(value);\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction weakSetAdd(weakset, value) {\n  try {\n    weakset.add(value);\n  } catch (e) {}\n}\n\nfunction weakSetDelete(weakset, value) {\n  try {\n    weakset.delete(value);\n  } catch (e) {}\n}\n\nvar validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nvar Validation = function () {\n  function Validation(context, input) {\n    classCallCheck(this, Validation);\n    this.path = [];\n    this.prefix = '';\n    this.errors = [];\n    this.cyclic = new WeakMap();\n\n    this.context = context;\n    this.input = input;\n  }\n\n  // Tracks whether we're in validation of cyclic objects.\n\n\n  createClass(Validation, [{\n    key: 'inCycle',\n    value: function inCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        return false;\n      } else {\n        return weakSetHas(tracked, input);\n      }\n    }\n  }, {\n    key: 'startCycle',\n    value: function startCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        tracked = new WeakSet();\n        this.cyclic.set(type, tracked);\n      }\n      weakSetAdd(tracked, input);\n    }\n  }, {\n    key: 'endCycle',\n    value: function endCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (tracked) {\n        weakSetDelete(tracked, input);\n      }\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors(path) {\n      if (path) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var candidate = _ref2[0];\n\n            if (matchPath(path, candidate)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        return this.errors.length > 0;\n      }\n    }\n  }, {\n    key: 'addError',\n    value: function addError(path, expectedType, message) {\n      this.errors.push([path, message, expectedType]);\n      return this;\n    }\n  }, {\n    key: 'clearError',\n    value: function clearError(path) {\n      var didClear = false;\n      if (path) {\n        var _errors = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var error = _step2.value;\n\n            if (matchPath(path, error[0])) {\n              didClear = true;\n            } else {\n              _errors.push(error);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.errors = _errors;\n      } else {\n        didClear = this.errors.length > 0;\n        this.errors = [];\n      }\n      return didClear;\n    }\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path) {\n      return _resolvePath(this.input, path);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return makeJSONError(this);\n    }\n  }]);\n  return Validation;\n}();\n\nfunction stringifyPath(path) {\n  if (!path.length) {\n    return 'Value';\n  }\n  var length = path.length;\n\n  var parts = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    } else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = '[' + String(part) + ']';\n    } else if (i > 0) {\n      parts[i] = '.' + String(part);\n    } else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nfunction _resolvePath(input, path) {\n  var subject = input;\n  var length = path.length;\n\n  for (var i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    } else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nfunction matchPath(path, candidate) {\n  var length = path.length;\n\n  if (length > candidate.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar RuntimeTypeError = function (_TypeError) {\n  inherits(RuntimeTypeError, _TypeError);\n\n  function RuntimeTypeError() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RuntimeTypeError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RuntimeTypeError.__proto__ || Object.getPrototypeOf(RuntimeTypeError)).call.apply(_ref, [this].concat(args))), _this), _this.name = \"RuntimeTypeError\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return RuntimeTypeError;\n}(TypeError);\n\nvar delimiter = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeTypeError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var prefix = validation.prefix,\n      input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actual + '\\n');\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (prefix) {\n    return new RuntimeTypeError(prefix.trim() + ' ' + collected.join(delimiter));\n  } else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\nfunction makeError(expected, input) {\n  var context = expected.context;\n\n  var validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\n\n\nfunction compareTypes(a, b) {\n\n  var result = void 0;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  } else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  } else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  } else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  } else {\n    return result;\n  }\n}\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nvar Type = function () {\n  function Type(context) {\n    classCallCheck(this, Type);\n    this.typeName = 'Type';\n\n    this.context = context;\n  }\n\n  createClass(Type, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var validation = new Validation(this.context, input);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.errors(validation, [], input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n          // eslint-disable-line no-unused-vars\n          return false;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsType',\n    value: function acceptsType(input) {\n      if (compareTypes(this, input) === -1) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return -1;\n    }\n  }, {\n    key: 'assert',\n    value: function assert(input) {\n      var error = makeError(this, input);\n      if (error) {\n        if (typeof Error.captureStackTrace === 'function') {\n          Error.captureStackTrace(error, this.assert);\n        }\n        throw error;\n      }\n      return input;\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Type';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return Type;\n}();\n\nvar AnyType = function (_Type) {\n  inherits(AnyType, _Type);\n\n  function AnyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AnyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AnyType.__proto__ || Object.getPrototypeOf(AnyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'AnyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AnyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'any';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return AnyType;\n}(Type);\n\nvar errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exists on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nfunction getErrorMessage(key) {\n  for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, function (m, i) {\n      return String(params[i]);\n    });\n  } else {\n    return message;\n  }\n}\n\nvar TupleType = function (_Type) {\n  inherits(TupleType, _Type);\n\n  function TupleType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TupleType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TupleType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, context, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < length)) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path.concat(i), input[i]), 't0', 10);\n\n            case 10:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 13:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n\n      if (!context.checkPredicate('Array', input) || input.length < length) {\n        return false;\n      }\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof TupleType)) {\n        return -1;\n      }\n      var types = this.types;\n      var inputTypes = input.types;\n      if (inputTypes.length < types.length) {\n        return -1;\n      }\n      var isGreater = false;\n      for (var i = 0; i < types.length; i++) {\n        var result = compareTypes(types[i], inputTypes[i]);\n        if (result === 1) {\n          isGreater = true;\n        } else if (result === -1) {\n          return -1;\n        }\n      }\n      if (types.length < inputTypes.length) {\n        return 0;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.types.join(', ') + ']';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return TupleType;\n}(Type);\n\nvar ArrayType = function (_Type) {\n  inherits(ArrayType, _Type);\n\n  function ArrayType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ArrayType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ArrayType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ArrayType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var context, elementType, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              validation.startCycle(this, input);\n              elementType = this.elementType;\n              length = input.length;\n              i = 0;\n\n            case 11:\n              if (!(i < length)) {\n                _context.next = 16;\n                break;\n              }\n\n              return _context.delegateYield(elementType.errors(validation, path.concat(i), input[i]), 't0', 13);\n\n            case 13:\n              i++;\n              _context.next = 11;\n              break;\n\n            case 16:\n              validation.endCycle(this, input);\n\n            case 17:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n      for (var i = 0; i < length; i++) {\n        if (!elementType.accepts(input[i])) {\n          endValidationCycle(this, input);\n          return false;\n        }\n      }\n      endValidationCycle(this, input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var elementType = this.elementType;\n\n      if (input instanceof TupleType) {\n        var types = input.types;\n\n        for (var i = 0; i < types.length; i++) {\n          var result = compareTypes(elementType, types[i]);\n          if (result === -1) {\n            return -1;\n          }\n        }\n        return 1;\n      } else if (input instanceof ArrayType) {\n        return compareTypes(elementType, input.elementType);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var elementType = this.elementType;\n\n      if (inToStringCycle(this)) {\n        if (typeof elementType.name === 'string') {\n          return 'Array<$Cycle<' + elementType.name + '>>';\n        } else {\n          return 'Array<$Cycle<Object>>';\n        }\n      }\n      startToStringCycle(this);\n      var output = 'Array<' + elementType.toString() + '>';\n      endToStringCycle(this);\n      return output;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        elementType: this.elementType\n      };\n    }\n  }]);\n  return ArrayType;\n}(Type);\n\nvar BooleanLiteralType = function (_Type) {\n  inherits(BooleanLiteralType, _Type);\n\n  function BooleanLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanLiteralType.__proto__ || Object.getPrototypeOf(BooleanLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== this.value)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.value ? 'true' : 'false';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        type: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return BooleanLiteralType;\n}(Type);\n\nvar BooleanType = function (_Type) {\n  inherits(BooleanType, _Type);\n\n  function BooleanType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanType.__proto__ || Object.getPrototypeOf(BooleanType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'boolean')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'boolean';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType) {\n        return 1;\n      } else if (input instanceof BooleanType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'boolean';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return BooleanType;\n}(Type);\n\nvar EmptyType = function (_Type) {\n  inherits(EmptyType, _Type);\n\n  function EmptyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, EmptyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EmptyType.__proto__ || Object.getPrototypeOf(EmptyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'EmptyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(EmptyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return false; // empty types accepts nothing.\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof EmptyType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'empty';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return EmptyType;\n}(Type);\n\nvar ExistentialType = function (_Type) {\n  inherits(ExistentialType, _Type);\n\n  function ExistentialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExistentialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExistentialType.__proto__ || Object.getPrototypeOf(ExistentialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExistentialType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExistentialType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '*';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ExistentialType;\n}(Type);\n\nvar FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\n\nvar TypeParameter = function (_Type) {\n  inherits(TypeParameter, _Type);\n\n  function TypeParameter() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  createClass(TypeParameter, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var boundOrDefault, recorded, context, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              boundOrDefault = this.bound || this.default;\n              recorded = this.recorded, context = this.context;\n\n              if (!(boundOrDefault instanceof FlowIntoType)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(boundOrDefault.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 7:\n              if (!recorded) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.delegateYield(recorded.errors(validation, path, input), 't1', 9);\n\n            case 9:\n              return _context.abrupt('return');\n\n            case 12:\n              if (!boundOrDefault) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType')) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 21;\n              _iterator = boundOrDefault.errors(validation, path, input)[Symbol.iterator]();\n\n            case 23:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 31;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 28;\n              return error;\n\n            case 28:\n              _iteratorNormalCompletion = true;\n              _context.next = 23;\n              break;\n\n            case 31:\n              _context.next = 37;\n              break;\n\n            case 33:\n              _context.prev = 33;\n              _context.t2 = _context['catch'](21);\n              _didIteratorError = true;\n              _iteratorError = _context.t2;\n\n            case 37:\n              _context.prev = 37;\n              _context.prev = 38;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 40:\n              _context.prev = 40;\n\n              if (!_didIteratorError) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 43:\n              return _context.finish(40);\n\n            case 44:\n              return _context.finish(37);\n\n            case 45:\n              if (!hasErrors) {\n                _context.next = 47;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 47:\n\n              this.recorded = context.typeOf(input);\n\n            case 48:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[21, 33, 37, 45], [38,, 40, 44]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n      if (boundOrDefault instanceof FlowIntoType) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        return boundOrDefault.accepts(input);\n      } else if (recorded) {\n        return recorded.accepts(input);\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n          return true;\n        } else if (!boundOrDefault.accepts(input)) {\n          return false;\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (input instanceof TypeParameter) {\n        // We don't need to check for `recorded` or `bound` fields\n        // because the input has already been unwrapped, so\n        // if we got a type parameter it must be totally generic and\n        // we treat it like Any.\n        return 1;\n      } else if (recorded) {\n        return compareTypes(recorded, input);\n      } else if (boundOrDefault) {\n        return compareTypes(boundOrDefault, input);\n      } else {\n        // A generic type parameter accepts any input.\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (recorded) {\n        return recorded.unwrap();\n      } else if (boundOrDefault) {\n        return boundOrDefault.unwrap();\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      var id = this.id,\n          bound = this.bound,\n          defaultType = this.default;\n\n      if (withBinding) {\n        if (defaultType) {\n          return id + ' = ' + defaultType.toString();\n        } else if (bound) {\n          return id + ': ' + bound.toString();\n        }\n      }\n      return id;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        bound: this.bound,\n        recorded: this.recorded\n      };\n    }\n  }]);\n  return TypeParameter;\n}(Type);\n\nfunction flowIntoTypeParameter(typeParameter) {\n  var existing = typeParameter[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  var target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  typeParameter[FlowIntoSymbol] = target;\n  return target;\n}\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\n\nvar FlowIntoType = function (_Type) {\n  inherits(FlowIntoType, _Type);\n\n  function FlowIntoType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FlowIntoType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FlowIntoType.__proto__ || Object.getPrototypeOf(FlowIntoType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FlowIntoType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FlowIntoType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var typeParameter, context, recorded, bound, hasError, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error, _hasError, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              typeParameter = this.typeParameter, context = this.context;\n              recorded = typeParameter.recorded, bound = typeParameter.bound;\n\n              if (!(bound instanceof FlowIntoType)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.delegateYield(bound.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!recorded) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!bound) {\n                _context.next = 39;\n                break;\n              }\n\n              hasError = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 11;\n              _iterator = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 13:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 21;\n                break;\n              }\n\n              error = _step.value;\n              _context.next = 17;\n              return error;\n\n            case 17:\n              hasError = true;\n\n            case 18:\n              _iteratorNormalCompletion = true;\n              _context.next = 13;\n              break;\n\n            case 21:\n              _context.next = 27;\n              break;\n\n            case 23:\n              _context.prev = 23;\n              _context.t1 = _context['catch'](11);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 27:\n              _context.prev = 27;\n              _context.prev = 28;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 30:\n              _context.prev = 30;\n\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 33:\n              return _context.finish(30);\n\n            case 34:\n              return _context.finish(27);\n\n            case 35:\n              if (!hasError) {\n                _context.next = 37;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 37:\n              _context.next = 45;\n              break;\n\n            case 39:\n              if (!recorded.accepts(input)) {\n                _context.next = 43;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 43:\n              // we need to make a union\n              typeParameter.recorded = context.union(recorded, context.typeOf(input));\n              return _context.abrupt('return');\n\n            case 45:\n              _context.next = 82;\n              break;\n\n            case 47:\n              if (!bound) {\n                _context.next = 82;\n                break;\n              }\n\n              if (!(bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType')) {\n                _context.next = 52;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 52:\n              _hasError = false;\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 56;\n              _iterator2 = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 58:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 66;\n                break;\n              }\n\n              _error = _step2.value;\n              _context.next = 62;\n              return _error;\n\n            case 62:\n              _hasError = true;\n\n            case 63:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 58;\n              break;\n\n            case 66:\n              _context.next = 72;\n              break;\n\n            case 68:\n              _context.prev = 68;\n              _context.t2 = _context['catch'](56);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t2;\n\n            case 72:\n              _context.prev = 72;\n              _context.prev = 73;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n\n            case 75:\n              _context.prev = 75;\n\n              if (!_didIteratorError2) {\n                _context.next = 78;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 78:\n              return _context.finish(75);\n\n            case 79:\n              return _context.finish(72);\n\n            case 80:\n              if (!_hasError) {\n                _context.next = 82;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 82:\n\n              typeParameter.recorded = context.typeOf(input);\n\n            case 83:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[11, 23, 27, 35], [28,, 30, 34], [56, 68, 72, 80], [73,, 75, 79]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.accepts(input);\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound && !bound.accepts(input)) {\n          return false;\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return true;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return true;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return true;\n        } else if (!bound.accepts(input)) {\n          return false;\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.compareWith(input);\n      }\n      if (recorded) {\n        if (bound && compareTypes(bound, input) === -1) {\n          return -1;\n        }\n        var result = compareTypes(recorded, input);\n        if (result === 0) {\n          // our existing type already permits this value, there's nothing to do.\n          return 0;\n        }\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, input);\n        return 1;\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return 1;\n        }\n        var _result = compareTypes(bound, input);\n        if (_result === -1) {\n          return -1;\n        }\n      }\n\n      typeParameter.recorded = input;\n      return 0;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.typeParameter.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return this.typeParameter.toString(withBinding);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.typeParameter.toJSON();\n    }\n  }]);\n  return FlowIntoType;\n}(Type);\n\nvar FunctionTypeRestParam = function (_Type) {\n  inherits(FunctionTypeRestParam, _Type);\n\n  function FunctionTypeRestParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeRestParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeRestParam.__proto__ || Object.getPrototypeOf(FunctionTypeRestParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeRestParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeRestParam, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '...' + this.name + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeRestParam;\n}(Type);\n\nvar FunctionTypeParam = function (_Type) {\n  inherits(FunctionTypeParam, _Type);\n\n  function FunctionTypeParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeParam.__proto__ || Object.getPrototypeOf(FunctionTypeParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeParam, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              optional = this.optional, type = this.type;\n\n              if (!(optional && input === undefined)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 6);\n\n            case 6:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return true;\n      } else {\n        return type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var optional = this.optional,\n          type = this.type;\n\n      return '' + this.name + (optional ? '?' : '') + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        optional: this.optional,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeParam;\n}(Type);\n\nvar FunctionTypeReturn = function (_Type) {\n  inherits(FunctionTypeReturn, _Type);\n\n  function FunctionTypeReturn() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeReturn);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeReturn.__proto__ || Object.getPrototypeOf(FunctionTypeReturn)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeReturn', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeReturn, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path.concat('[[Return Type]]'), input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeReturn) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeReturn;\n}(Type);\n\nvar ParentSymbol = Symbol('Parent');\nvar NameRegistrySymbol = Symbol('NameRegistry');\nvar ModuleRegistrySymbol = Symbol('ModuleRegistry');\nvar CurrentModuleSymbol = Symbol('CurrentModule');\nvar TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nvar InferrerSymbol = Symbol('Inferrer');\n\n\nvar TypeSymbol = Symbol('Type');\nvar TypeParametersSymbol = Symbol('TypeParameters');\nvar TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\nvar FunctionType = function (_Type) {\n  inherits(FunctionType, _Type);\n\n  function FunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var annotation, returnType, params, i, param, annotationParam, context, _i, _param;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'function')) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              annotation = input[TypeSymbol];\n              returnType = this.returnType, params = this.params;\n\n              if (!annotation) {\n                _context.next = 29;\n                break;\n              }\n\n              if (annotation.params) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i = 0;\n\n            case 10:\n              if (!(i < params.length)) {\n                _context.next = 24;\n                break;\n              }\n\n              param = params[i];\n              annotationParam = annotation.params[i];\n\n              if (!(!annotationParam && !param.optional)) {\n                _context.next = 18;\n                break;\n              }\n\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              if (param.acceptsType(annotationParam)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 21;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 21:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 24:\n              if (returnType.acceptsType(annotation.returnType)) {\n                _context.next = 27;\n                break;\n              }\n\n              _context.next = 27;\n              return [path, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()), this];\n\n            case 27:\n              _context.next = 32;\n              break;\n\n            case 29:\n              context = this.context;\n              // We cannot safely check an unannotated function.\n              // But we need to propagate `any` type feedback upwards.\n\n              for (_i = 0; _i < params.length; _i++) {\n                _param = params[_i];\n\n                _param.acceptsType(context.any());\n              }\n              returnType.acceptsType(context.any());\n\n            case 32:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var returnType = this.returnType,\n          params = this.params;\n\n      var annotation = input[TypeSymbol];\n      if (annotation) {\n        if (!annotation.params) {\n          return true;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            return false;\n          } else if (!param.acceptsType(annotationParam)) {\n            return false;\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          return false;\n        }\n        return true;\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i2 = 0; _i2 < params.length; _i2++) {\n          var _param2 = params[_i2];\n          _param2.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof FunctionType)) {\n        return -1;\n      }\n      var returnType = this.returnType;\n      var inputReturnType = input.returnType;\n      var isGreater = false;\n      var returnTypeResult = compareTypes(returnType, inputReturnType);\n      if (returnTypeResult === -1) {\n        return -1;\n      } else if (returnTypeResult === 1) {\n        isGreater = true;\n      }\n\n      var params = this.params;\n      var inputParams = input.params;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        var inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n        if (inputParam == null) {\n          return -1;\n        }\n        var result = compareTypes(param, inputParam);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n      }\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.accepts(args[i])) {\n            return false;\n          }\n        } else if (!param.accepts(undefined)) {\n          return false;\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {\n          if (!rest.accepts(args[_i3])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          param.assert(args[i]);\n        } else {\n          param.assert(undefined);\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i4 = paramsLength; _i4 < argsLength; _i4++) {\n          rest.assert(args[_i4]);\n        }\n      }\n\n      return args;\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      this.returnType.assert(input);\n      return input;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var params = this.params,\n          rest = this.rest,\n          context = this.context;\n\n      var paramsLength = params.length;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.acceptsType(args[i])) {\n            return context.empty();\n          }\n        } else if (!param.accepts(undefined)) {\n          return context.empty();\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i5 = paramsLength; _i5 < argsLength; _i5++) {\n          if (!rest.acceptsType(args[_i5])) {\n            return context.empty();\n          }\n        }\n      }\n\n      return this.returnType.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = this.params,\n          rest = this.rest,\n          returnType = this.returnType;\n\n      var args = [];\n      for (var i = 0; i < params.length; i++) {\n        args.push(params[i].toString());\n      }\n      if (rest) {\n        args.push(rest.toString());\n      }\n      return '(' + args.join(', ') + ') => ' + returnType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        params: this.params,\n        rest: this.rest,\n        returnType: this.returnType\n      };\n    }\n  }]);\n  return FunctionType;\n}(Type);\n\nvar GeneratorType = function (_Type) {\n  inherits(GeneratorType, _Type);\n\n  function GeneratorType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeneratorType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeneratorType.__proto__ || Object.getPrototypeOf(GeneratorType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GeneratorType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeneratorType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              isValid = input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n\n              if (isValid) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof GeneratorType)) {\n        var _result = compareTypes(this.yieldType, input);\n        if (_result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      var isGreater = false;\n      var result = compareTypes(this.yieldType, input.yieldType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.returnType, input.returnType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.nextType, input.nextType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsYield',\n    value: function acceptsYield(input) {\n      return this.yieldType.accepts(input);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'acceptsNext',\n    value: function acceptsNext(input) {\n      return this.nextType.accepts(input);\n    }\n  }, {\n    key: 'assertYield',\n    value: function assertYield(input) {\n      return this.yieldType.assert(input);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return this.returnType.assert(input);\n    }\n  }, {\n    key: 'assertNext',\n    value: function assertNext(input) {\n      return this.nextType.assert(input);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var yieldType = this.yieldType,\n          returnType = this.returnType,\n          nextType = this.nextType;\n\n      return 'Generator<' + yieldType.toString() + ', ' + returnType.toString() + ', ' + nextType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        yieldType: this.yieldType,\n        returnType: this.returnType,\n        nextType: this.nextType\n      };\n    }\n  }]);\n  return GeneratorType;\n}(Type);\n\n/**\n * # TypeParameterApplication\n *\n */\nvar TypeParameterApplication = function (_Type) {\n  inherits(TypeParameterApplication, _Type);\n\n  function TypeParameterApplication() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameterApplication);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameterApplication.__proto__ || Object.getPrototypeOf(TypeParameterApplication)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameterApplication', _this.typeInstances = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeParameterApplication, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var parent, typeInstances;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              parent = this.parent, typeInstances = this.typeInstances;\n              return _context.delegateYield(parent.errors.apply(parent, [validation, path, input].concat(toConsumableArray(typeInstances))), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      return parent.accepts.apply(parent, [input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var _parent;\n\n      return (_parent = this.parent).compareWith.apply(_parent, [input].concat(toConsumableArray(this.typeInstances)));\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.hasProperty === 'function') {\n        var _ref2;\n\n        return (_ref2 = inner).hasProperty.apply(_ref2, [name].concat(toConsumableArray(this.typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.getProperty === 'function') {\n        var _ref3;\n\n        return (_ref3 = inner).getProperty.apply(_ref3, [name].concat(toConsumableArray(this.typeInstances)));\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _parent2;\n\n      return (_parent2 = this.parent).unwrap.apply(_parent2, toConsumableArray(this.typeInstances));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n      var name = parent.name;\n\n      if (typeInstances.length) {\n        var items = [];\n        for (var i = 0; i < typeInstances.length; i++) {\n          var typeInstance = typeInstances[i];\n          items.push(typeInstance.toString());\n        }\n        return name + '<' + items.join(', ') + '>';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeInstances: this.typeInstances\n      };\n    }\n  }]);\n  return TypeParameterApplication;\n}(Type);\n\nvar warnedInstances = new WeakSet();\n\nvar TypeConstructor = function (_Type) {\n  inherits(TypeConstructor, _Type);\n\n  function TypeConstructor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeConstructor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeConstructor.__proto__ || Object.getPrototypeOf(TypeConstructor)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeConstructor', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeConstructor, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement accepts().');\n        warnedInstances.add(this);\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement compareWith().');\n        warnedInstances.add(this);\n      }\n      return -1;\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }]);\n  return TypeConstructor;\n}(Type);\n\nvar GenericType = function (_TypeConstructor) {\n  inherits(GenericType, _TypeConstructor);\n\n  function GenericType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GenericType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GenericType.__proto__ || Object.getPrototypeOf(GenericType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GenericType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GenericType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var name, impl, context, annotation;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              name = this.name, impl = this.impl, context = this.context;\n\n              if (input instanceof impl) {\n                _context.next = 9;\n                break;\n              }\n\n              annotation = context.getAnnotation(impl);\n\n              if (!annotation) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(annotation.errors(validation, path, input), 't0', 5);\n\n            case 5:\n              _context.next = 9;\n              break;\n\n            case 7:\n              _context.next = 9;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', name), this];\n\n            case 9:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      if (input instanceof impl) {\n        return true;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        return annotation.accepts(input);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var expected = annotation.unwrap.apply(annotation, toConsumableArray(typeInstances));\n        return compareTypes(input, expected);\n      } else if (input instanceof GenericType && (input.impl === impl || impl && impl.isPrototypeOf(input.impl))) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var context = this.context,\n          impl = this.impl;\n\n      if (typeof impl !== 'function') {\n        return this;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation != null) {\n        return annotation.unwrap.apply(annotation, arguments);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }]);\n  return GenericType;\n}(TypeConstructor);\n\nfunction invariant(input, message) {\n  if (!input) {\n    var error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\nvar NullLiteralType = function (_Type) {\n  inherits(NullLiteralType, _Type);\n\n  function NullLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullLiteralType.__proto__ || Object.getPrototypeOf(NullLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== null)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === null;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'null';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NullLiteralType;\n}(Type);\n\nvar VoidType = function (_Type) {\n  inherits(VoidType, _Type);\n\n  function VoidType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VoidType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VoidType.__proto__ || Object.getPrototypeOf(VoidType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VoidType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VoidType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== undefined)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === undefined;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof VoidType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'void';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return VoidType;\n}(Type);\n\nvar NullableType = function (_Type) {\n  inherits(NullableType, _Type);\n\n  function NullableType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullableType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullableType.__proto__ || Object.getPrototypeOf(NullableType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullableType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullableType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input != null)) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input == null) {\n        return true;\n      } else {\n        return this.type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType || input instanceof VoidType) {\n        return 1;\n      } else if (input instanceof NullableType) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '? ' + this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return NullableType;\n}(Type);\n\nvar _marked$1 = [collectConstraintErrors].map(_regeneratorRuntime.mark);\n\n/**\n * Add constraints to the given subject type.\n */\nfunction addConstraints(subject) {\n  var _subject$constraints;\n\n  for (var _len = arguments.length, constraints = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    constraints[_key - 1] = arguments[_key];\n  }\n\n  (_subject$constraints = subject.constraints).push.apply(_subject$constraints, toConsumableArray(constraints));\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\n\n\nfunction collectConstraintErrors(subject, validation, path) {\n  for (var _len2 = arguments.length, input = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    input[_key2 - 3] = arguments[_key2];\n  }\n\n  var constraints, length, i, constraint, violation;\n  return _regeneratorRuntime.wrap(function collectConstraintErrors$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          constraints = subject.constraints;\n          length = constraints.length;\n          i = 0;\n\n        case 3:\n          if (!(i < length)) {\n            _context.next = 12;\n            break;\n          }\n\n          constraint = constraints[i];\n          violation = constraint.apply(undefined, toConsumableArray(input));\n\n          if (!(typeof violation === 'string')) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return [path, violation, this];\n\n        case 9:\n          i++;\n          _context.next = 3;\n          break;\n\n        case 12:\n        case 'end':\n          return _context.stop();\n      }\n    }\n  }, _marked$1[0], this);\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nfunction constraintsAccept(subject) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len3 = arguments.length, input = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    input[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    if (typeof constraint.apply(undefined, toConsumableArray(input)) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar ObjectTypeProperty = function (_Type) {\n  inherits(ObjectTypeProperty, _Type);\n\n  function ObjectTypeProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeProperty.__proto__ || Object.getPrototypeOf(ObjectTypeProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeProperty', _this['static'] = false, _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeProperty, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n\n    /**\n     * Determine whether the property is nullable.\n     */\n\n  }, {\n    key: 'isNullable',\n    value: function isNullable() {\n      return this.value instanceof NullableType;\n    }\n\n    /**\n     * Determine whether the property exists on the given input or its prototype chain.\n     */\n\n  }, {\n    key: 'existsOn',\n    value: function existsOn(input) {\n      // Ignore\n      var key = this.key,\n          isStatic = this.static;\n\n      return key in (isStatic ? input.constructor : input) === true;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, key, value, isStatic, target, targetPath, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              optional = this.optional, key = this.key, value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 18;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 14;\n                break;\n              }\n\n              if (optional) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 13;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 13:\n              return _context.abrupt('return');\n\n            case 14:\n              targetPath.push(key);\n              target = input.constructor[key];\n              _context.next = 20;\n              break;\n\n            case 18:\n              target = input[key];\n              targetPath = path.concat(key);\n\n            case 20:\n              if (!(optional && target === undefined)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 22:\n              if (!(this.isNullable() && !this.existsOn(input))) {\n                _context.next = 26;\n                break;\n              }\n\n              _context.next = 25;\n              return [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n\n            case 25:\n              return _context.abrupt('return');\n\n            case 26:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 30;\n              _iterator = value.errors(validation, targetPath, target)[Symbol.iterator]();\n\n            case 32:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 40;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 37;\n              return error;\n\n            case 37:\n              _iteratorNormalCompletion = true;\n              _context.next = 32;\n              break;\n\n            case 40:\n              _context.next = 46;\n              break;\n\n            case 42:\n              _context.prev = 42;\n              _context.t0 = _context['catch'](30);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 46:\n              _context.prev = 46;\n              _context.prev = 47;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 49:\n              _context.prev = 49;\n\n              if (!_didIteratorError) {\n                _context.next = 52;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 52:\n              return _context.finish(49);\n\n            case 53:\n              return _context.finish(46);\n\n            case 54:\n              if (hasErrors) {\n                _context.next = 56;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, targetPath, target), 't1', 56);\n\n            case 56:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[30, 42, 46, 54], [47,, 49, 53]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return optional ? true : false;\n        }\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n      }\n\n      if (optional && target === undefined) {\n        return true;\n      }\n\n      if (this.isNullable() && !this.existsOn(input)) {\n        return false;\n      }\n\n      if (!value.accepts(target)) {\n        return false;\n      } else {\n        return constraintsAccept(this, target);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeProperty)) {\n        return -1;\n      } else if (input.key !== this.key) {\n        return -1;\n      } else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var key = this.key;\n      // Issue 252\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol') {\n        key = '[' + key.toString() + ']';\n      }\n      if (this.static) {\n        return 'static ' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      } else {\n        return '' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        key: this.key,\n        value: this.value,\n        optional: this.optional\n      };\n    }\n  }]);\n  return ObjectTypeProperty;\n}(Type);\n\nvar ObjectTypeIndexer = function (_Type) {\n  inherits(ObjectTypeIndexer, _Type);\n\n  function ObjectTypeIndexer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeIndexer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeIndexer.__proto__ || Object.getPrototypeOf(ObjectTypeIndexer)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeIndexer', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectTypeIndexer, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, key, value) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // special case number types\n              if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n                key = +key;\n              }\n\n              return _context.delegateYield(this.key.errors(validation, path.concat('[[Key]]'), key), 't0', 2);\n\n            case 2:\n              return _context.delegateYield(this.value.errors(validation, path.concat(key), value), 't1', 3);\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'acceptsKey',\n    value: function acceptsKey(key) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n      return this.key.accepts(key);\n    }\n  }, {\n    key: 'acceptsValue',\n    value: function acceptsValue(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ObjectTypeProperty) {\n        if (!this.key.accepts(input.key)) {\n          return -1;\n        } else {\n          return compareTypes(this.value, input.value);\n        }\n      } else if (!(input instanceof ObjectTypeIndexer)) {\n        return -1;\n      }\n\n      var keyResult = compareTypes(this.key, input.key);\n      if (keyResult === -1) {\n        return -1;\n      }\n      var valueResult = compareTypes(this.value, input.value);\n      if (valueResult === -1) {\n        return -1;\n      }\n\n      if (keyResult === 0 && valueResult === 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.id + ': ' + this.key.toString() + ']: ' + this.value.toString() + ';';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        key: this.key,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeIndexer;\n}(Type);\n\nvar ObjectTypeCallProperty = function (_Type) {\n  inherits(ObjectTypeCallProperty, _Type);\n\n  function ObjectTypeCallProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeCallProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeCallProperty.__proto__ || Object.getPrototypeOf(ObjectTypeCallProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeCallProperty', _this['static'] = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeCallProperty, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value, isStatic, target, targetPath;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 16;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 12;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 12:\n              return _context.abrupt('return');\n\n            case 13:\n              target = input.constructor;\n              _context.next = 18;\n              break;\n\n            case 16:\n              target = input;\n              targetPath = path;\n\n            case 18:\n              return _context.delegateYield(value.errors(validation, targetPath, target), 't0', 19);\n\n            case 19:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return false;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n      }\n      return value.accepts(target);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeCallProperty)) {\n        return -1;\n      }\n      return compareTypes(this.value, input.value);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.static) {\n        return 'static ' + this.value.toString() + ';';\n      } else {\n        return this.value.toString();\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeCallProperty;\n}(Type);\n\nvar Declaration = function (_Type) {\n  inherits(Declaration, _Type);\n\n  function Declaration() {\n    classCallCheck(this, Declaration);\n    return possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).apply(this, arguments));\n  }\n\n  return Declaration;\n}(Type);\n\nvar VarDeclaration = function (_Declaration) {\n  inherits(VarDeclaration, _Declaration);\n\n  function VarDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VarDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VarDeclaration.__proto__ || Object.getPrototypeOf(VarDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VarDeclaration', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VarDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare var ' + this.name + ': ' + this.type.toString() + ';';\n    }\n  }]);\n  return VarDeclaration;\n}(Declaration);\n\nvar TypeDeclaration = function (_Declaration) {\n  inherits(TypeDeclaration, _Declaration);\n\n  function TypeDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeDeclaration.__proto__ || Object.getPrototypeOf(TypeDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      var _typeAlias;\n\n      (_typeAlias = this.typeAlias).addConstraint.apply(_typeAlias, arguments);\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.typeAlias.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _typeAlias2;\n\n      return (_typeAlias2 = this.typeAlias).apply.apply(_typeAlias2, arguments);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.typeAlias.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.typeAlias, input);\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var _typeAlias3;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_typeAlias3 = this.typeAlias).hasProperty.apply(_typeAlias3, [name].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var _typeAlias4;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_typeAlias4 = this.typeAlias).getProperty.apply(_typeAlias4, [name].concat(toConsumableArray(typeInstances)));\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _typeAlias5;\n\n      return (_typeAlias5 = this.typeAlias).unwrap.apply(_typeAlias5, arguments);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare ' + this.typeAlias.toString(true) + ';';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return this.typeAlias.type;\n    }\n  }]);\n  return TypeDeclaration;\n}(Declaration);\n\nvar ModuleDeclaration = function (_Declaration) {\n  inherits(ModuleDeclaration, _Declaration);\n\n  function ModuleDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleDeclaration.__proto__ || Object.getPrototypeOf(ModuleDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleDeclaration, [{\n    key: 'get',\n    value: function get$$1(name) {\n      var moduleExports = this.moduleExports;\n\n      if (moduleExports) {\n        var exporting = moduleExports.unwrap();\n        if (typeof exporting.getProperty === 'function') {\n          var prop = exporting.getProperty(name);\n          if (prop) {\n            return prop.unwrap();\n          }\n        }\n      } else {\n        var declaration = this.declarations[name];\n        if (declaration) {\n          return declaration.unwrap();\n        }\n      }\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      if (/^\\.\\//.test(moduleName)) {\n        moduleName = '' + this.name + moduleName.slice(1);\n      }\n      return this.innerContext.import(moduleName);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var name = this.name,\n          declarations = this.declarations,\n          modules = this.modules,\n          moduleExports = this.moduleExports;\n\n      var body = [];\n      for (var _name in declarations) {\n        // eslint-disable-line guard-for-in\n        var declaration = declarations[_name];\n        body.push(declaration.toString(true));\n      }\n      if (modules) {\n        for (var _name2 in modules) {\n          // eslint-disable-line guard-for-in\n          var module = modules[_name2];\n          body.push(module.toString());\n        }\n      }\n      if (moduleExports) {\n        body.push(moduleExports.toString());\n      }\n      return 'declare module \"' + name + '\" {\\n' + indent$1(body.join('\\n\\n')) + '}';\n    }\n  }, {\n    key: 'moduleType',\n    get: function get$$1() {\n      if (this.moduleExports) {\n        return 'commonjs';\n      } else {\n        return 'es6';\n      }\n    }\n  }, {\n    key: 'isCommonJS',\n    get: function get$$1() {\n      return this.moduleExports ? true : false;\n    }\n  }, {\n    key: 'isES6',\n    get: function get$$1() {\n      return this.moduleExports ? false : true;\n    }\n  }, {\n    key: 'declarations',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[NameRegistrySymbol];\n    }\n  }, {\n    key: 'modules',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[ModuleRegistrySymbol];\n    }\n  }]);\n  return ModuleDeclaration;\n}(Declaration);\n\nfunction indent$1(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar ModuleExports = function (_Declaration) {\n  inherits(ModuleExports, _Declaration);\n\n  function ModuleExports() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleExports);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleExports.__proto__ || Object.getPrototypeOf(ModuleExports)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleExports', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleExports, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare module.exports: ' + this.type.toString() + ';';\n    }\n  }]);\n  return ModuleExports;\n}(Declaration);\n\nvar ClassDeclaration = function (_Declaration) {\n  inherits(ClassDeclaration, _Declaration);\n\n  function ClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassDeclaration.__proto__ || Object.getPrototypeOf(ClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var body, superClass, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref2, _ref3, errorPath, errorMessage, expectedType, propertyName;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              body = this.body;\n              superClass = this.superClass && this.superClass.unwrap();\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n\n            case 5:\n              return _context.abrupt('return');\n\n            case 6:\n              if (!superClass) {\n                _context.next = 42;\n                break;\n              }\n\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = superClass.errors(validation, path, input)[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 28;\n                break;\n              }\n\n              _ref2 = _step.value;\n              _ref3 = slicedToArray(_ref2, 3);\n              errorPath = _ref3[0];\n              errorMessage = _ref3[1];\n              expectedType = _ref3[2];\n              propertyName = errorPath[path.length];\n\n              if (!body.getProperty(propertyName)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt('continue', 25);\n\n            case 23:\n              _context.next = 25;\n              return [errorPath, errorMessage, expectedType];\n\n            case 25:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 28:\n              _context.next = 34;\n              break;\n\n            case 30:\n              _context.prev = 30;\n              _context.t0 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 34:\n              _context.prev = 34;\n              _context.prev = 35;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 37:\n              _context.prev = 37;\n\n              if (!_didIteratorError) {\n                _context.next = 40;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 40:\n              return _context.finish(37);\n\n            case 41:\n              return _context.finish(34);\n\n            case 42:\n              return _context.delegateYield(body.errors(validation, path, input), 't1', 43);\n\n            case 43:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 30, 34, 42], [35,, 37, 41]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      } else if (superClass && !superClass.accepts(input)) {\n        return false;\n      } else if (!body.accepts(input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ClassDeclaration) {\n        if (input === this) {\n          return 0;\n        } else if (this.isSuperClassOf(input)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      return compareTypes(this.body, input);\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      var prop = body.getProperty(key);\n      if (prop) {\n        return prop;\n      } else if (superClass && typeof superClass.getProperty === 'function') {\n        return superClass.getProperty(key);\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (body.hasProperty(key)) {\n        return true;\n      } else if (superClass && typeof superClass.hasProperty === 'function') {\n        return superClass.hasProperty(key);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine whether this class declaration represents a super class of\n     * the given type.\n     */\n\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      var body = this.body,\n          shapeID = this.shapeID;\n\n      var current = candidate;\n\n      while (current != null) {\n        if (current === this || current === body || current.shapeID === shapeID) {\n          return true;\n        }\n        if (current instanceof ClassDeclaration) {\n          current = current.superClass;\n        } else {\n          current = current.unwrap();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          superClass = this.superClass,\n          body = this.body;\n\n      if (withDeclaration) {\n        var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n        return 'declare class ' + name + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (superClass == null) {\n        return body.properties;\n      }\n      var bodyProps = body.properties;\n      var superProps = superClass.unwrap().properties;\n      var seen = {};\n      var seenStatic = {};\n      var props = [];\n      for (var i = 0; i < superProps.length; i++) {\n        var prop = superProps[i];\n        props.push(prop);\n        if (prop.static) {\n          seenStatic[prop.key] = i;\n        } else {\n          seen[prop.key] = i;\n        }\n      }\n      for (var _i = 0; _i < bodyProps.length; _i++) {\n        var _prop = bodyProps[_i];\n        if (seen[_prop.key]) {\n          props[_i] = _prop;\n        } else {\n          props.push(_prop);\n        }\n      }\n      return props;\n    }\n  }]);\n  return ClassDeclaration;\n}(Declaration);\n\nvar PartialType = function (_Type) {\n  inherits(PartialType, _Type);\n\n  function PartialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, PartialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PartialType.__proto__ || Object.getPrototypeOf(PartialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'PartialType', _this.typeParameters = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(PartialType, [{\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this.context);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      this.typeParameters.push(target);\n      return target;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var constraints, type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              constraints = this.constraints, type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (!(!hasErrors && constraints)) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (constraints && !constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(expand) {\n      var type = this.type;\n\n      return type.toString(expand);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeParameters: this.typeParameters,\n        type: this.type\n      };\n    }\n  }]);\n  return PartialType;\n}(Type);\n\nvar ParameterizedClassDeclaration = function (_Declaration) {\n  inherits(ParameterizedClassDeclaration, _Declaration);\n\n  function ParameterizedClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedClassDeclaration.__proto__ || Object.getPrototypeOf(ParameterizedClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedClassDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return getPartial(this).compareWith(input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).type;\n    }\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      return getPartial(this).type.isSuperClassOf(candidate);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len5 = arguments.length, typeInstances = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeInstances[_key5] = arguments[_key5];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      if (!withDeclaration) {\n        return this.name;\n      }\n      var partial = getPartial(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return partial.toString(true);\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      var superClass = type.superClass,\n          body = type.body;\n\n      var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n      return 'declare class ' + this.name + '<' + items.join(', ') + '>' + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getPartial(this).toJSON();\n    }\n  }, {\n    key: 'superClass',\n    get: function get$$1() {\n      return getPartial(this).type.superClass;\n    }\n  }, {\n    key: 'body',\n    get: function get$$1() {\n      return getPartial(this).type.body;\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial(this).type.properties;\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial(this).typeParameters;\n    }\n  }]);\n  return ParameterizedClassDeclaration;\n}(Declaration);\n\nfunction getPartial(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class.apply(context, [parent.name].concat(toConsumableArray(body)));\n  } else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  partial.type.shapeID = parent.shapeID;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len6 = arguments.length, typeInstances = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    typeInstances[_key6 - 1] = arguments[_key6];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ExtendsDeclaration = function (_Declaration) {\n  inherits(ExtendsDeclaration, _Declaration);\n\n  function ExtendsDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExtendsDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExtendsDeclaration.__proto__ || Object.getPrototypeOf(ExtendsDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExtendsDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExtendsDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var type = this.type;\n\n      if (withDeclaration) {\n        return 'extends ' + type.toString();\n      } else {\n        return type.toString();\n      }\n    }\n  }]);\n  return ExtendsDeclaration;\n}(Declaration);\n\nvar _marked = [collectErrorsWithIndexers, collectErrorsWithoutIndexers, collectErrorsExact].map(_regeneratorRuntime.mark);\n\nvar ObjectType = function (_Type) {\n  inherits(ObjectType, _Type);\n\n  function ObjectType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectType, [{\n    key: 'getProperty',\n\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n    value: function getProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return property;\n        }\n      }\n      return this.getIndexer(key);\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return true;\n        }\n      }\n      return this.hasIndexer(key);\n    }\n\n    /**\n     * Get an indexer with which matches the given key type.\n     */\n\n  }, {\n    key: 'getIndexer',\n    value: function getIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return indexer;\n        }\n      }\n    }\n\n    /**\n     * Determine whether an indexer exists which matches the given key type.\n     */\n\n  }, {\n    key: 'hasIndexer',\n    value: function hasIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var hasCallProperties;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input === null)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              hasCallProperties = this.callProperties.length > 0;\n\n              if (!hasCallProperties) {\n                _context.next = 11;\n                break;\n              }\n\n              if (acceptsCallProperties(this, input)) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 9;\n              return [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n\n            case 9:\n              _context.next = 15;\n              break;\n\n            case 11:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object')) {\n                _context.next = 15;\n                break;\n              }\n\n              _context.next = 14;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 14:\n              return _context.abrupt('return');\n\n            case 15:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              validation.startCycle(this, input);\n\n              if (!(this.indexers.length > 0)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsWithIndexers(this, validation, path, input), 't0', 20);\n\n            case 20:\n              _context.next = 27;\n              break;\n\n            case 22:\n              if (!this.exact) {\n                _context.next = 26;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsExact(this, validation, path, input), 't1', 24);\n\n            case 24:\n              _context.next = 27;\n              break;\n\n            case 26:\n              return _context.delegateYield(collectErrorsWithoutIndexers(this, validation, path, input), 't2', 27);\n\n            case 27:\n              validation.endCycle(this, input);\n\n            case 28:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input === null) {\n        return false;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          return false;\n        }\n      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = acceptsWithIndexers(this, input);\n      } else if (this.exact) {\n        result = acceptsExact(this, input);\n      } else {\n        result = acceptsWithoutIndexers(this, input);\n      }\n      endValidationCycle(this, input);\n      return result;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n        return -1;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      var isGreater = false;\n      if (hasCallProperties) {\n        var _result = compareTypeCallProperties(this, input);\n        if (_result === -1) {\n          return -1;\n        } else if (_result === 1) {\n          isGreater = true;\n        }\n      }\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = compareTypeWithIndexers(this, input);\n      } else {\n        result = compareTypeWithoutIndexers(this, input);\n      }\n\n      if (result === -1) {\n        return -1;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var callProperties = this.callProperties,\n          properties = this.properties,\n          indexers = this.indexers;\n\n      if (inToStringCycle(this)) {\n        return '$Cycle<Object>';\n      }\n      startToStringCycle(this);\n      var body = [];\n      for (var i = 0; i < callProperties.length; i++) {\n        body.push(callProperties[i].toString());\n      }\n      for (var _i = 0; _i < properties.length; _i++) {\n        body.push(properties[_i].toString());\n      }\n      for (var _i2 = 0; _i2 < indexers.length; _i2++) {\n        body.push(indexers[_i2].toString());\n      }\n      endToStringCycle(this);\n      if (this.exact) {\n        return '{|\\n' + indent(body.join('\\n')) + '\\n|}';\n      } else {\n        return '{\\n' + indent(body.join('\\n')) + '\\n}';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        callProperties: this.callProperties,\n        properties: this.properties,\n        indexers: this.indexers,\n        exact: this.exact\n      };\n    }\n  }]);\n  return ObjectType;\n}(Type);\n\nfunction acceptsCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareTypeCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  var inputCallProperties = input.callProperties;\n  var identicalCount = 0;\n  loop: for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n\n    for (var j = 0; j < inputCallProperties.length; j++) {\n      var inputCallProperty = inputCallProperties[j];\n      var result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      } else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers(type, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i3 = 0; _i3 < indexers.length; _i3++) {\n      var indexer = indexers[_i3];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers(type, input) {\n  var indexers = type.indexers,\n      properties = type.properties;\n\n  var inputIndexers = input.indexers;\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {\n    var indexer = indexers[_i4];\n    for (var _j = 0; _j < inputIndexers.length; _j++) {\n      var inputIndexer = inputIndexers[_j];\n      var _result2 = compareTypes(indexer, inputIndexer);\n      if (_result2 === 1) {\n        isGreater = true;\n        continue loop;\n      } else if (_result2 === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction acceptsWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact(type, input) {\n  var properties = type.properties;\n  var length = properties.length;\n\n  loop: for (var key in input) {\n    // eslint-disable-line guard-for-in\n    for (var i = 0; i < length; i++) {\n      var property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction collectErrorsWithIndexers(type, validation, path, input) {\n  var properties, indexers, seen, i, property, key, value, _i5, indexer;\n\n  return _regeneratorRuntime.wrap(function collectErrorsWithIndexers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          properties = type.properties, indexers = type.indexers;\n          seen = [];\n          i = 0;\n\n        case 3:\n          if (!(i < properties.length)) {\n            _context2.next = 10;\n            break;\n          }\n\n          property = properties[i];\n          return _context2.delegateYield(property.errors(validation, path, input), 't0', 6);\n\n        case 6:\n          seen.push(property.key);\n\n        case 7:\n          i++;\n          _context2.next = 3;\n          break;\n\n        case 10:\n          _context2.t1 = _regeneratorRuntime.keys(input);\n\n        case 11:\n          if ((_context2.t2 = _context2.t1()).done) {\n            _context2.next = 28;\n            break;\n          }\n\n          key = _context2.t2.value;\n\n          if (!(seen.indexOf(key) !== -1)) {\n            _context2.next = 15;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 15:\n          value = input[key];\n          _i5 = 0;\n\n        case 17:\n          if (!(_i5 < indexers.length)) {\n            _context2.next = 24;\n            break;\n          }\n\n          indexer = indexers[_i5];\n\n          if (!(indexer.acceptsKey(key) && indexer.acceptsValue(value))) {\n            _context2.next = 21;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 21:\n          _i5++;\n          _context2.next = 17;\n          break;\n\n        case 24:\n          _context2.next = 26;\n          return [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n\n        case 26:\n          _context2.next = 11;\n          break;\n\n        case 28:\n        case 'end':\n          return _context2.stop();\n      }\n    }\n  }, _marked[0], this);\n}\n\nfunction collectErrorsWithoutIndexers(type, validation, path, input) {\n  var properties, i, property;\n  return _regeneratorRuntime.wrap(function collectErrorsWithoutIndexers$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          properties = type.properties;\n          i = 0;\n\n        case 2:\n          if (!(i < properties.length)) {\n            _context3.next = 8;\n            break;\n          }\n\n          property = properties[i];\n          return _context3.delegateYield(property.errors(validation, path, input), 't0', 5);\n\n        case 5:\n          i++;\n          _context3.next = 2;\n          break;\n\n        case 8:\n        case 'end':\n          return _context3.stop();\n      }\n    }\n  }, _marked[1], this);\n}\n\nfunction collectErrorsExact(type, validation, path, input) {\n  var properties, length, key, i, property;\n  return _regeneratorRuntime.wrap(function collectErrorsExact$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          properties = type.properties;\n          length = properties.length;\n          _context4.t0 = _regeneratorRuntime.keys(input);\n\n        case 3:\n          if ((_context4.t1 = _context4.t0()).done) {\n            _context4.next = 18;\n            break;\n          }\n\n          key = _context4.t1.value;\n          i = 0;\n\n        case 6:\n          if (!(i < length)) {\n            _context4.next = 14;\n            break;\n          }\n\n          property = properties[i];\n\n          if (!(property.key === key)) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield(property.errors(validation, path, input), 't2', 10);\n\n        case 10:\n          return _context4.abrupt('continue', 3);\n\n        case 11:\n          i++;\n          _context4.next = 6;\n          break;\n\n        case 14:\n          _context4.next = 16;\n          return [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n\n        case 16:\n          _context4.next = 3;\n          break;\n\n        case 18:\n        case 'end':\n          return _context4.stop();\n      }\n    }\n  }, _marked[2], this);\n}\n\nfunction indent(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar IntersectionType = function (_Type) {\n  inherits(IntersectionType, _Type);\n\n  function IntersectionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, IntersectionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IntersectionType.__proto__ || Object.getPrototypeOf(IntersectionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'IntersectionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(IntersectionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 8;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path, input), 't0', 5);\n\n            case 5:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = length - 1; i >= 0; i--) {\n        var type = types[i];\n        if (typeof type.getProperty === 'function') {\n          var prop = type.getProperty(key);\n          if (prop) {\n            return prop;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      var identicalCount = 0;\n      if (input instanceof IntersectionType) {\n        var inputTypes = input.types;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n        return identicalCount === types.length ? 0 : 1;\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          var _result = compareTypes(_type, input);\n          if (_result === -1) {\n            return -1;\n          } else if (_result === 0) {\n            identicalCount++;\n          }\n        }\n        return identicalCount === types.length ? 0 : 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _ref2;\n\n      var callProperties = [];\n      var properties = [];\n      var indexers = [];\n      var types = this.types,\n          context = this.context;\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        invariant(type instanceof ObjectType, 'Can only intersect object types');\n        callProperties.push.apply(callProperties, toConsumableArray(type.callProperties));\n        indexers.push.apply(indexers, toConsumableArray(type.indexers));\n        mergeProperties(properties, type.properties);\n      }\n      return (_ref2 = context).object.apply(_ref2, callProperties.concat(properties, indexers));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.types.join(' & ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return IntersectionType;\n}(Type);\n\nfunction getPropertyIndex(name, properties) {\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    var typeProp = source[i];\n    var index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    } else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\nvar MixedType = function (_Type) {\n  inherits(MixedType, _Type);\n\n  function MixedType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, MixedType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MixedType.__proto__ || Object.getPrototypeOf(MixedType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'MixedType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(MixedType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'mixed';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return MixedType;\n}(Type);\n\nvar TypeAlias = function (_Type) {\n  inherits(TypeAlias, _Type);\n\n  function TypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeAlias.__proto__ || Object.getPrototypeOf(TypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeAlias', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeAlias, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          type = this.type;\n\n      if (withDeclaration) {\n        return 'type ' + name + ' = ' + type.toString() + ';';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return this.type.properties;\n    }\n  }, {\n    key: 'hasConstraints',\n    get: function get$$1() {\n      return this.constraints.length > 0;\n    }\n  }]);\n  return TypeAlias;\n}(Type);\n\nvar NumericLiteralType = function (_Type) {\n  inherits(NumericLiteralType, _Type);\n\n  function NumericLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumericLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumericLiteralType.__proto__ || Object.getPrototypeOf(NumericLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumericLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumericLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumericLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '' + this.value;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return NumericLiteralType;\n}(Type);\n\nvar NumberType = function (_Type) {\n  inherits(NumberType, _Type);\n\n  function NumberType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumberType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumberType.__proto__ || Object.getPrototypeOf(NumberType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumberType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumberType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'number')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'number';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumberType) {\n        return 0;\n      } else if (input instanceof NumericLiteralType) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'number';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NumberType;\n}(Type);\n\nvar ParameterizedTypeAlias = function (_TypeAlias) {\n  inherits(ParameterizedTypeAlias, _TypeAlias);\n\n  function ParameterizedTypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedTypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedTypeAlias.__proto__ || Object.getPrototypeOf(ParameterizedTypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedTypeAlias', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedTypeAlias, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      var partial = getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances)));\n      if (!partial.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(getPartial$1(this), input);\n      }\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        typeInstances[_key5 - 1] = arguments[_key5];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len6 = arguments.length, typeInstances = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeInstances[_key6] = arguments[_key6];\n      }\n\n      return getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var partial = getPartial$1(this);\n      var typeParameters = partial.typeParameters;\n\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n\n      var name = this.name;\n\n      var identifier = typeParameters.length > 0 ? name + '<' + items.join(', ') + '>' : name;\n\n      if (withDeclaration) {\n        return 'type ' + identifier + ' = ' + partial.toString() + ';';\n      } else {\n        return identifier;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$1(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial$1(this).type.properties;\n    }\n  }]);\n  return ParameterizedTypeAlias;\n}(TypeAlias);\n\nfunction getPartial$1(parent) {\n  var typeCreator = parent.typeCreator,\n      context = parent.context,\n      name = parent.name;\n\n  var partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len7 = arguments.length, typeInstances = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    typeInstances[_key7 - 1] = arguments[_key7];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ParameterizedFunctionType = function (_Type) {\n  inherits(ParameterizedFunctionType, _Type);\n\n  function ParameterizedFunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedFunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedFunctionType.__proto__ || Object.getPrototypeOf(ParameterizedFunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedFunctionType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedFunctionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getPartial$2(this), input);\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var _getPartial$type;\n\n      return (_getPartial$type = getPartial$2(this).type).acceptsParams.apply(_getPartial$type, arguments);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return getPartial$2(this).type.acceptsReturn(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var _getPartial$type2;\n\n      return (_getPartial$type2 = getPartial$2(this).type).assertParams.apply(_getPartial$type2, arguments);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return getPartial$2(this).type.assertReturn(input);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var partial = getPartial$2(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return type.toString();\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      return '<' + items.join(', ') + '> ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$2(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial$2(this).typeParameters;\n    }\n  }, {\n    key: 'params',\n    get: function get$$1() {\n      return getPartial$2(this).type.params;\n    }\n  }, {\n    key: 'rest',\n    get: function get$$1() {\n      return getPartial$2(this).type.rest;\n    }\n  }, {\n    key: 'returnType',\n    get: function get$$1() {\n      return getPartial$2(this).type.returnType;\n    }\n  }]);\n  return ParameterizedFunctionType;\n}(Type);\n\nfunction getPartial$2(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  partial.type = context.function.apply(context, toConsumableArray(body));\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    typeInstances[_key5 - 1] = arguments[_key5];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar RefinementType = function (_Type) {\n  inherits(RefinementType, _Type);\n\n  function RefinementType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RefinementType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RefinementType.__proto__ || Object.getPrototypeOf(RefinementType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'RefinementType', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(RefinementType, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '$Refinment<' + type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return RefinementType;\n}(Type);\n\nvar StringLiteralType = function (_Type) {\n  inherits(StringLiteralType, _Type);\n\n  function StringLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringLiteralType.__proto__ || Object.getPrototypeOf(StringLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return StringLiteralType;\n}(Type);\n\nvar StringType = function (_Type) {\n  inherits(StringType, _Type);\n\n  function StringType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringType.__proto__ || Object.getPrototypeOf(StringType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'string')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'string';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType) {\n        return 1;\n      } else if (input instanceof StringType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return StringType;\n}(Type);\n\nvar SymbolLiteralType = function (_Type) {\n  inherits(SymbolLiteralType, _Type);\n\n  function SymbolLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolLiteralType.__proto__ || Object.getPrototypeOf(SymbolLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'typeof ' + String(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return SymbolLiteralType;\n}(Type);\n\nvar SymbolType = function (_Type) {\n  inherits(SymbolType, _Type);\n\n  function SymbolType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolType.__proto__ || Object.getPrototypeOf(SymbolType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'symbol')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType) {\n        return 1;\n      } else if (input instanceof SymbolType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Symbol';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return SymbolType;\n}(Type);\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\n\nvar ThisType = function (_Type) {\n  inherits(ThisType, _Type);\n\n  function ThisType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ThisType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ThisType.__proto__ || Object.getPrototypeOf(ThisType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ThisType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ThisType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var recorded;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              recorded = this.recorded;\n\n              if (!(input === recorded)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              if (!(typeof recorded === 'function' && input instanceof recorded)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              if (!(recorded != null)) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return true;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return true;\n      } else if (recorded != null) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ThisType)) {\n        return -1;\n      } else if (input.recorded && this.recorded) {\n        return input.recorded === this.recorded ? 0 : -1;\n      } else if (this.recorded) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return 'this';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ThisType;\n}(Type);\n\nvar warnedInstances$1 = new WeakSet();\n\nvar TypeBox = function (_Type) {\n  inherits(TypeBox, _Type);\n\n  function TypeBox() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeBox);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeBox.__proto__ || Object.getPrototypeOf(TypeBox)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeBox', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeBox, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this.type;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.type.toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      return this.type.name;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var reveal = this.reveal;\n\n      var type = reveal();\n      if (!type) {\n        if (!warnedInstances$1.has(this)) {\n          this.context.emitWarningMessage('Failed to reveal boxed type.');\n          warnedInstances$1.add(this);\n        }\n        return this.context.mixed();\n      } else if (!(type instanceof Type)) {\n        // we got a boxed reference to something like a class\n        return this.context.ref(type);\n      }\n      return type;\n    }\n  }]);\n  return TypeBox;\n}(Type);\n\nvar warnedMissing = {};\n\nvar TypeReference = function (_Type) {\n  inherits(TypeReference, _Type);\n\n  function TypeReference() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeReference);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeReference.__proto__ || Object.getPrototypeOf(TypeReference)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeReference', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeReference, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var context = this.context,\n          name = this.name;\n\n      var type = context.get(name);\n      if (!type) {\n        if (!warnedMissing[name]) {\n          context.emitWarningMessage('Cannot resolve type: ' + name);\n          warnedMissing[name] = true;\n        }\n        return context.any();\n      }\n      return type;\n    }\n  }]);\n  return TypeReference;\n}(Type);\n\nvar warnedInstances$2 = new WeakSet();\n\nvar RevealedName = Symbol('RevealedName');\nvar RevealedValue = Symbol('RevealedValue');\n\nvar TypeTDZ = function (_Type) {\n  inherits(TypeTDZ, _Type);\n\n  function TypeTDZ() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeTDZ);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeTDZ.__proto__ || Object.getPrototypeOf(TypeTDZ)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeTDZ', _this[RevealedName] = undefined, _this[RevealedValue] = undefined, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeTDZ, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getRevealed(this).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return getRevealed(this).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getRevealed(this), input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = getRevealed(this);\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return getRevealed(this).unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return getRevealed(this).toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getRevealed(this).toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      var name = this[RevealedName];\n      if (!name) {\n        name = getRevealed(this).name;\n      }\n      return name;\n    },\n    set: function set$$1(value) {\n      this[RevealedName] = value;\n    }\n  }]);\n  return TypeTDZ;\n}(Type);\n\nfunction getRevealed(container) {\n  var existing = container[RevealedValue];\n  if (existing) {\n    return existing;\n  } else {\n    var reveal = container.reveal;\n\n    var type = reveal();\n    if (!type) {\n      if (!warnedInstances$2.has(container)) {\n        var name = container[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage('Failed to reveal type called \"' + name + '\" in Temporal Dead Zone.');\n        } else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances$2.add(container);\n      }\n      return container.context.mixed();\n    } else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\nvar UnionType = function (_Type) {\n  inherits(UnionType, _Type);\n\n  function UnionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, UnionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnionType.__proto__ || Object.getPrototypeOf(UnionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'UnionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(UnionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 10;\n                break;\n              }\n\n              type = types[i];\n\n              if (!type.accepts(input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 10:\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      if (input instanceof UnionType) {\n        var inputTypes = input.types;\n        var identicalCount = 0;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n\n        if (identicalCount === types.length) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          if (compareTypes(_type, input) >= 0) {\n            return 1;\n          }\n        }\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var types = this.types;\n\n      var normalized = new Array(types.length);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n          normalized[i] = '(' + type.toString() + ')';\n        } else {\n          normalized[i] = type.toString();\n        }\n      }\n      return normalized.join(' | ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return UnionType;\n}(Type);\n\nfunction registerPrimitiveTypes(t) {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\nfunction registerBuiltinTypeConstructors(t) {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (input instanceof Date) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n\n            case 3:\n              _context.next = 8;\n              break;\n\n            case 5:\n              if (!isNaN(input.getTime())) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return [path, getErrorMessage('ERR_INVALID_DATE'), this];\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, futureType) {\n      var context;\n      return _regeneratorRuntime.wrap(function errors$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              invariant(futureType, 'Must specify type parameter for Promise.');\n              context = this.context;\n\n              if (context.checkPredicate('Promise', input)) {\n                _context2.next = 5;\n                break;\n              }\n\n              _context2.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n\n            case 5:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      var context = this.context;\n\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, keyType, valueType) {\n      var context, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref, _ref2, key, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              invariant(keyType, 'Must specify two type parameters for Map.');\n              invariant(valueType, 'Must specify two type parameters for Map.');\n              context = this.context;\n\n              if (context.checkPredicate('Map', input)) {\n                _context3.next = 7;\n                break;\n              }\n\n              _context3.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n\n            case 6:\n              return _context3.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context3.prev = 10;\n              _iterator = input[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context3.next = 24;\n                break;\n              }\n\n              _ref = _step.value;\n              _ref2 = slicedToArray(_ref, 2);\n              key = _ref2[0];\n              value = _ref2[1];\n\n              if (keyType.accepts(key)) {\n                _context3.next = 20;\n                break;\n              }\n\n              _context3.next = 20;\n              return [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n\n            case 20:\n              return _context3.delegateYield(valueType.errors(validation, path.concat(key), value), 't0', 21);\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context3.next = 12;\n              break;\n\n            case 24:\n              _context3.next = 30;\n              break;\n\n            case 26:\n              _context3.prev = 26;\n              _context3.t1 = _context3['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context3.t1;\n\n            case 30:\n              _context3.prev = 30;\n              _context3.prev = 31;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 33:\n              _context3.prev = 33;\n\n              if (!_didIteratorError) {\n                _context3.next = 36;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 36:\n              return _context3.finish(33);\n\n            case 37:\n              return _context3.finish(30);\n\n            case 38:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, errors, this, [[10, 26, 30, 38], [31,, 33, 37]]);\n    }),\n    accepts: function accepts(input, keyType, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref3 = _step2.value;\n\n          var _ref4 = slicedToArray(_ref3, 2);\n\n          var key = _ref4[0];\n          var value = _ref4[1];\n\n          if (!keyType.accepts(key) || !valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var keyTypes = [];\n      var valueTypes = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        loop: for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref5 = _step3.value;\n\n          var _ref6 = slicedToArray(_ref5, 2);\n\n          var key = _ref6[0];\n          var value = _ref6[1];\n\n          findKey: {\n            for (var i = 0; i < keyTypes.length; i++) {\n              var type = keyTypes[i];\n              if (type.accepts(key)) {\n                break findKey;\n              }\n            }\n            keyTypes.push(t.typeOf(key));\n          }\n\n          for (var _i = 0; _i < valueTypes.length; _i++) {\n            var _type = valueTypes[_i];\n            if (_type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, valueType) {\n      var context, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              invariant(valueType, 'Must specify type parameter for Set.');\n              context = this.context;\n\n              if (context.checkPredicate('Set', input)) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n\n            case 5:\n              return _context4.abrupt('return');\n\n            case 6:\n              _iteratorNormalCompletion4 = true;\n              _didIteratorError4 = false;\n              _iteratorError4 = undefined;\n              _context4.prev = 9;\n              _iterator4 = input[Symbol.iterator]();\n\n            case 11:\n              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                _context4.next = 17;\n                break;\n              }\n\n              value = _step4.value;\n              return _context4.delegateYield(valueType.errors(validation, path, value), 't0', 14);\n\n            case 14:\n              _iteratorNormalCompletion4 = true;\n              _context4.next = 11;\n              break;\n\n            case 17:\n              _context4.next = 23;\n              break;\n\n            case 19:\n              _context4.prev = 19;\n              _context4.t1 = _context4['catch'](9);\n              _didIteratorError4 = true;\n              _iteratorError4 = _context4.t1;\n\n            case 23:\n              _context4.prev = 23;\n              _context4.prev = 24;\n\n              if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n              }\n\n            case 26:\n              _context4.prev = 26;\n\n              if (!_didIteratorError4) {\n                _context4.next = 29;\n                break;\n              }\n\n              throw _iteratorError4;\n\n            case 29:\n              return _context4.finish(26);\n\n            case 30:\n              return _context4.finish(23);\n\n            case 31:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, errors, this, [[9, 19, 23, 31], [24,, 26, 30]]);\n    }),\n    accepts: function accepts(input, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (!valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var valueTypes = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        loop: for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n\n          for (var i = 0; i < valueTypes.length; i++) {\n            var type = valueTypes[i];\n            if (type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      } else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      } else {\n        return [t.union.apply(t, valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\nfunction registerTypePredicates(context) {\n  context.setPredicate('Array', function (input) {\n    return Array.isArray(input);\n  });\n  context.setPredicate('Map', function (input) {\n    return input instanceof Map;\n  });\n  context.setPredicate('Set', function (input) {\n    return input instanceof Set;\n  });\n  context.setPredicate('Promise', function (input) {\n    if (input instanceof Promise) {\n      return true;\n    } else if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && typeof input.then === 'function') {\n      return input.then.length >= 2;\n    } else {\n      return false;\n    }\n  });\n}\n\nvar TypeInferer = function () {\n  function TypeInferer(context) {\n    classCallCheck(this, TypeInferer);\n\n    this.context = context;\n  }\n\n  createClass(TypeInferer, [{\n    key: 'infer',\n    value: function infer(input) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      var inferred = new Map();\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferInternal',\n    value: function inferInternal(input, inferred) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferPrimitive',\n    value: function inferPrimitive(input) {\n      var context = this.context;\n\n      if (input === null) {\n        return context.null();\n      } else if (input === undefined) {\n        return context.void();\n      } else if (typeof input === 'number') {\n        return context.number();\n      } else if (typeof input === 'boolean') {\n        return context.boolean();\n      } else if (typeof input === 'string') {\n        return context.string();\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return context.symbol(input);\n        } else {\n          return undefined;\n        }\n    }\n  }, {\n    key: 'inferComplex',\n    value: function inferComplex(input, inferred) {\n      var context = this.context;\n\n\n      if (typeof input === 'function') {\n        return this.inferFunction(input, inferred);\n      } else if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\n        return this.inferObject(input, inferred);\n      } else {\n        return context.any();\n      }\n    }\n  }, {\n    key: 'inferFunction',\n    value: function inferFunction(input, inferred) {\n      var context = this.context;\n      var length = input.length;\n\n      var body = new Array(length + 1);\n      for (var i = 0; i < length; i++) {\n        body[i] = context.param(String.fromCharCode(97 + i), context.existential());\n      }\n      body[length] = context.return(context.existential());\n      return context.fn.apply(context, body);\n    }\n  }, {\n    key: 'inferObject',\n    value: function inferObject(input, inferred) {\n      var existing = inferred.get(input);\n      if (existing) {\n        return existing;\n      }\n      var context = this.context;\n\n      var type = void 0;\n\n      // Temporarily create a box for this type to catch cyclical references.\n      // Nested references to this object will receive the boxed type.\n      var box = context.box(function () {\n        return type;\n      });\n      inferred.set(input, box);\n\n      if (context.checkPredicate('Array', input)) {\n        type = this.inferArray(input, inferred);\n      } else if (!(input instanceof Object)) {\n        type = this.inferDict(input, inferred);\n      } else if (input.constructor !== Object) {\n        var handler = context.getTypeConstructor(input.constructor);\n        if (handler) {\n          var typeParameters = handler.inferTypeParameters(input);\n          type = handler.apply.apply(handler, toConsumableArray(typeParameters));\n        } else {\n          type = context.ref(input.constructor);\n        }\n      } else {\n        var body = [];\n        for (var key in input) {\n          // eslint-disable-line\n          var value = input[key];\n          body.push(context.property(key, this.inferInternal(value, inferred)));\n        }\n        type = context.object.apply(context, body);\n      }\n\n      // Overwrite the box with the real value.\n      inferred.set(input, type);\n      return type;\n    }\n  }, {\n    key: 'inferDict',\n    value: function inferDict(input, inferred) {\n      var numericIndexers = [];\n      var stringIndexers = [];\n      loop: for (var key in input) {\n        // eslint-disable-line\n        var value = input[key];\n        var types = isNaN(+key) ? stringIndexers : numericIndexers;\n        for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        types.push(this.inferInternal(value, inferred));\n      }\n\n      var context = this.context;\n\n      var body = [];\n      if (numericIndexers.length === 1) {\n        body.push(context.indexer('index', context.number(), numericIndexers[0]));\n      } else if (numericIndexers.length > 1) {\n        body.push(context.indexer('index', context.number(), context.union.apply(context, numericIndexers)));\n      }\n\n      if (stringIndexers.length === 1) {\n        body.push(context.indexer('key', context.string(), stringIndexers[0]));\n      } else if (stringIndexers.length > 1) {\n        body.push(context.indexer('key', context.string(), context.union.apply(context, stringIndexers)));\n      }\n\n      return context.object.apply(context, body);\n    }\n  }, {\n    key: 'inferArray',\n    value: function inferArray(input, inferred) {\n      var context = this.context;\n\n      var types = [];\n      var values = [];\n      var length = input.length;\n\n      loop: for (var i = 0; i < length; i++) {\n        var item = input[i];\n        var inferredType = this.inferInternal(item, inferred);\n        for (var j = 0; j < types.length; j++) {\n          var type = types[j];\n          if (type.accepts(item) && inferredType.accepts(values[j])) {\n            continue loop;\n          }\n        }\n        types.push(inferredType);\n        values.push(item);\n      }\n      if (types.length === 0) {\n        return context.array(context.any());\n      } else if (types.length === 1) {\n        return context.array(types[0]);\n      } else {\n        return context.array(context.union.apply(context, types));\n      }\n    }\n  }]);\n  return TypeInferer;\n}();\n\nfunction makeReactPropTypes(objectType) {\n  var output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n\n  var _loop = function _loop(property) {\n    output[property.key] = function (props, propName, componentName) {\n      return makeError(property, props);\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = objectType.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return output;\n}\n\nvar delimiter$1 = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeWarningMessage(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actual + '\\n');\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return 'Warning: ' + collected.join(delimiter$1);\n}\n\nfunction makeUnion(context, types) {\n  var length = types.length;\n  var merged = [];\n  for (var i = 0; i < length; i++) {\n    var type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return type;\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    } else {\n      merged.push(type);\n    }\n  }\n  var union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes(aTypes, bTypes) {\n  loop: for (var i = 0; i < bTypes.length; i++) {\n    var bType = bTypes[i];\n    for (var j = 0; j < aTypes.length; j++) {\n      var aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\nfunction makePropertyDescriptor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert);\n  } else {\n    return propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert);\n  }\n}\n\nfunction makePropertyName(name) {\n  return '_flowRuntime$' + name;\n}\n\nfunction getClassName(input) {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  } else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  } else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType(receiver, typeSource) {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  } else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  var safeName = makePropertyName(propertyName);\n  var className = getClassName(input);\n  var initializer = descriptor.initializer,\n      writable = descriptor.writable,\n      config = objectWithoutProperties(descriptor, ['initializer', 'writable']); // eslint-disable-line no-unused-vars\n\n  var propertyPath = [className, propertyName];\n\n  return _extends({}, config, {\n    type: 'accessor',\n    get: function get$$1() {\n      if (safeName in this) {\n        return this[safeName];\n      } else if (initializer) {\n        var type = resolveType(this, typeSource);\n        var _value = initializer.call(this);\n        var context = type.context;\n        context.check(type, _value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: _value\n        });\n        return _value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set: function set$$1(value) {\n      var type = resolveType(this, typeSource);\n      var context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      } else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  });\n}\n\nfunction augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert) {\n\n  var className = getClassName(input);\n  var propertyPath = [className, propertyName];\n\n  var originalSetter = descriptor.set;\n\n  descriptor.set = function set$$1(value) {\n    var type = resolveType(this, typeSource);\n    var context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    } else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n}\n\n// eslint-disable-line no-redeclare\n\nfunction annotateValue(input, type) {\n  // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  } else {\n    var _ret = function () {\n      var type = input;\n      return {\n        v: function v(input) {\n          input[TypeSymbol] = type;\n          return input;\n        }\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n}\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nvar $DiffType = function (_Type) {\n  inherits($DiffType, _Type);\n\n  function $DiffType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $DiffType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $DiffType.__proto__ || Object.getPrototypeOf($DiffType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$DiffType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($DiffType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var aType, bType, properties, i, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              aType = this.aType, bType = this.bType;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              aType = aType.unwrap();\n              bType = bType.unwrap();\n              invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n              properties = aType.properties;\n              i = 0;\n\n            case 10:\n              if (!(i < properties.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!bType.hasProperty(property.key)) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt('continue', 15);\n\n            case 14:\n              return _context.delegateYield(property.errors(validation, path.concat(property.key), input), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        if (!property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var aType = this.aType,\n          bType = this.bType;\n\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      var args = [];\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        args.push(property);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Diff<' + this.aType.toString() + ', ' + this.bType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        aType: this.aType,\n        bType: this.bType\n      };\n    }\n  }]);\n  return $DiffType;\n}(Type);\n\n// Any subtype of T\n\nvar $FlowFixMeType = function (_Type) {\n  inherits($FlowFixMeType, _Type);\n\n  function $FlowFixMeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $FlowFixMeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $FlowFixMeType.__proto__ || Object.getPrototypeOf($FlowFixMeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$FlowFixMeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($FlowFixMeType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, input) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$FlowFixMe';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return $FlowFixMeType;\n}(Type);\n\n// The set of keys of T.\n\nvar $KeysType = function (_Type) {\n  inherits($KeysType, _Type);\n\n  function $KeysType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $KeysType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $KeysType.__proto__ || Object.getPrototypeOf($KeysType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$KeysType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($KeysType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, properties, length, i, property, keys, _i;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type.unwrap();\n\n              invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n              properties = type.properties;\n              length = properties.length;\n              i = 0;\n\n            case 5:\n              if (!(i < length)) {\n                _context.next = 12;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!(input === property.key)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i++;\n              _context.next = 5;\n              break;\n\n            case 12:\n              keys = new Array(length);\n\n              for (_i = 0; _i < length; _i++) {\n                keys[_i] = properties[_i].key;\n              }\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var keys = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        keys[i] = context.literal(property.key);\n      }\n      return (_context2 = this.context).union.apply(_context2, keys);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Keys<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $KeysType;\n}(Type);\n\n// Map over the keys and values in an object.\n\nvar $ObjMapiType = function (_Type) {\n  inherits($ObjMapiType, _Type);\n\n  function $ObjMapiType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapiType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapiType.__proto__ || Object.getPrototypeOf($ObjMapiType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapiType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapiType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key), prop.value);\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key), prop.value)));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMapi<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapiType;\n}(Type);\n\n// Map over the keys in an object.\n\nvar $ObjMapType = function (_Type) {\n  inherits($ObjMapType, _Type);\n\n  function $ObjMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapType.__proto__ || Object.getPrototypeOf($ObjMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key));\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key))));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMap<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapType;\n}(Type);\n\n// The type of the named object property\n\nvar $PropertyType = function (_Type) {\n  inherits($PropertyType, _Type);\n\n  function $PropertyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $PropertyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $PropertyType.__proto__ || Object.getPrototypeOf($PropertyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$PropertyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($PropertyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.unwrap().errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.unwrap().accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          property = this.property;\n\n      var unwrapped = object.unwrap();\n      invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n      return unwrapped.getProperty(property).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$PropertyType<' + this.object.toString() + ', ' + String(this.property) + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        property: this.property\n      };\n    }\n  }]);\n  return $PropertyType;\n}(Type);\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nvar $ShapeType = function (_Type) {\n  inherits($ShapeType, _Type);\n\n  function $ShapeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ShapeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ShapeType.__proto__ || Object.getPrototypeOf($ShapeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ShapeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ShapeType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, key, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n\n              type = type.unwrap();\n              invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n              _context.t0 = _regeneratorRuntime.keys(input);\n\n            case 8:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              key = _context.t1.value;\n              // eslint-disable-line guard-for-in\n              property = type.getProperty(key);\n\n              if (property) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt('continue', 8);\n\n            case 13:\n              return _context.delegateYield(property.errors(validation, path, input), 't2', 14);\n\n            case 14:\n              _context.next = 8;\n              break;\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property || !property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var type = this.type;\n\n      type = type.unwrap();\n      var context = this.context;\n      invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n      var properties = type.properties;\n      var args = new Array(properties.length);\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        args[i] = context.property(property.key, property.value, true);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Shape<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ShapeType;\n}(Type);\n\n// Any subtype of T\n\nvar $SubType = function (_Type) {\n  inherits($SubType, _Type);\n\n  function $SubType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SubType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SubType.__proto__ || Object.getPrototypeOf($SubType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SubType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SubType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(input, path), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Subtype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SubType;\n}(Type);\n\n// Any, but at least T.\n\nvar $SuperType = function (_Type) {\n  inherits($SuperType, _Type);\n\n  function $SuperType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SuperType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SuperType.__proto__ || Object.getPrototypeOf($SuperType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SuperType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SuperType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Supertype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SuperType;\n}(Type);\n\n// Map over the values in a tuple.\n\nvar $TupleMapType = function (_Type) {\n  inherits($TupleMapType, _Type);\n\n  function $TupleMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $TupleMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $TupleMapType.__proto__ || Object.getPrototypeOf($TupleMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$TupleMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($TupleMapType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var tuple, mapper, context, target, i, type, applied, expected, value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              tuple = this.tuple, mapper = this.mapper, context = this.context;\n              target = tuple.unwrap();\n\n              invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < target.types.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              type = target.types[i];\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              expected = applied.invoke(type);\n              value = input[i];\n              return _context.delegateYield(expected.errors(validation, path.concat(i), value), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        if (!applied.invoke(type).accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n      var args = [];\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        args.push(applied.invoke(type).unwrap().unwrap());\n      }\n\n      return context.tuple.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$TupleMap<' + this.tuple.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        tuple: this.tuple,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $TupleMapType;\n}(Type);\n\nfunction checkGenericType(context, expected, input) {\n  var impl = expected.impl;\n\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  } else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  var annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  } else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType(context, expected, input) {\n  var annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    var result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\nvar ClassType = function (_Type) {\n  inherits(ClassType, _Type);\n\n  function ClassType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassType.__proto__ || Object.getPrototypeOf(ClassType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var instanceType, context, expectedType, isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              instanceType = this.instanceType, context = this.context;\n\n              if (!(typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n              isValid = expectedType instanceof GenericType ? checkGenericType(context, expectedType, input) : checkType(context, expectedType, input);\n\n              if (isValid) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 10;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 10:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      if (expectedType instanceof GenericType) {\n        return checkGenericType(context, expectedType, input);\n      } else {\n        return checkType(context, expectedType, input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var instanceType = this.instanceType;\n\n      if (input instanceof ClassType) {\n        return compareTypes(instanceType, input.instanceType);\n      }\n      return -1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Class<' + this.instanceType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        instanceType: this.instanceType\n      };\n    }\n  }]);\n  return ClassType;\n}(Type);\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nvar warnedInvalidReferences = new WeakSet();\n\nvar TypeContext = function () {\n  function TypeContext() {\n    classCallCheck(this, TypeContext);\n    this.mode = 'assert';\n    this[NameRegistrySymbol] = {};\n    this[TypePredicateRegistrySymbol] = {};\n    this[TypeConstructorRegistrySymbol] = new Map();\n    this[InferrerSymbol] = new TypeInferer(this);\n    this[ModuleRegistrySymbol] = {};\n  }\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeContext, [{\n    key: 'makeJSONError',\n    value: function makeJSONError$$1(validation) {\n      return makeJSONError(validation);\n    }\n  }, {\n    key: 'makeTypeError',\n    value: function makeTypeError$$1(validation) {\n      return makeTypeError(validation);\n    }\n  }, {\n    key: 'createContext',\n    value: function createContext() {\n      var context = new TypeContext();\n      // Issue 252\n      context[ParentSymbol] = this;\n      return context;\n    }\n  }, {\n    key: 'typeOf',\n    value: function typeOf(input) {\n\n      var annotation = this.getAnnotation(input);\n      if (annotation) {\n        if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n          return this.Class(annotation);\n        }\n        return annotation;\n      }\n      // Issue 252\n      var inferrer = this[InferrerSymbol];\n      inferrer;\n\n      return inferrer.infer(input);\n    }\n  }, {\n    key: 'compareTypes',\n    value: function compareTypes$$1(a, b) {\n      return compareTypes(a, b);\n    }\n  }, {\n    key: 'get',\n    value: function get$$1(name) {\n      // Issue 252\n      var item = this[NameRegistrySymbol][name];\n\n      for (var _len = arguments.length, propertyNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        propertyNames[_key - 1] = arguments[_key];\n      }\n\n      if (item != null) {\n        var current = typeof item === 'function' ? new item(this) : item;\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n          if (typeof current.getProperty !== 'function') {\n            return;\n          }\n          current = current.getProperty(propertyName);\n          if (!current) {\n            return;\n          }\n          current = current.unwrap();\n        }\n        return current;\n      }\n      // Issue 252\n      var parent = this[ParentSymbol];\n      if (parent) {\n        var fromParent = parent.get.apply(parent, [name].concat(toConsumableArray(propertyNames)));\n        if (fromParent) {\n          return fromParent;\n        }\n      }\n\n      // if we got this far, see if we have a global type with this name.\n      if (typeof global[name] === 'function') {\n        var target = new GenericType(this);\n        target.name = name;\n        target.impl = global[name];\n        // Issue 252\n        this[NameRegistrySymbol][name] = target;\n        return target;\n      }\n    }\n\n    /**\n     * Get the predicate for a given type name.\n     * e.g. `t.getPredicate('Array')`.\n     */\n\n  }, {\n    key: 'getPredicate',\n    value: function getPredicate(name) {\n      var item = this[TypePredicateRegistrySymbol][name];\n      if (item) {\n        return item;\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.getPredicate(name);\n      }\n    }\n\n    /**\n     * Set the predicate for a given type name.\n     * This can be used to customise the behaviour of things like Array\n     * detection or allowing Thenables in place of the global Promise.\n     */\n\n  }, {\n    key: 'setPredicate',\n    value: function setPredicate(name, predicate) {\n      this[TypePredicateRegistrySymbol][name] = predicate;\n    }\n\n    /**\n     * Check the given value against the named predicate.\n     * Returns false if no such predicate exists.\n     * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n     */\n\n  }, {\n    key: 'checkPredicate',\n    value: function checkPredicate(name, input) {\n      var predicate = this.getPredicate(name);\n      if (predicate) {\n        return predicate(input);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Returns a decorator for a function or object with the given type.\n     */\n\n  }, {\n    key: 'decorate',\n    value: function decorate(type, shouldAssert) {\n      var _this2 = this;\n\n      if (shouldAssert == null) {\n        shouldAssert = this.mode === 'assert';\n      }\n      return function (input, propertyName, descriptor) {\n        if (descriptor && typeof propertyName === 'string') {\n          return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n        } else {\n          invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n          return _this2.annotate(input, type);\n        }\n      };\n    }\n\n    /**\n     * Annotates an object or function with the given type.\n     * If a type is specified as the sole argument, returns a\n     * function which can decorate classes or functions with the given type.\n     */\n\n  }, {\n    key: 'annotate',\n    value: function annotate(input, type) {\n      if (type === undefined) {\n        return annotateValue(input);\n      } else {\n        return annotateValue(input, type);\n      }\n    }\n  }, {\n    key: 'getAnnotation',\n    value: function getAnnotation(input) {\n      if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' || typeof input === 'function') {\n        // Issue 252\n        return input[TypeSymbol];\n      }\n    }\n  }, {\n    key: 'hasAnnotation',\n    value: function hasAnnotation(input) {\n      if (input == null) {\n        return false;\n      } else {\n        return input[TypeSymbol] ? true : false;\n      }\n    }\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(input, type) {\n      input[TypeSymbol] = type;\n      return input;\n    }\n  }, {\n    key: 'type',\n    value: function type(name, _type) {\n      if (typeof _type === 'function') {\n        var target = new ParameterizedTypeAlias(this);\n        target.name = name;\n        target.typeCreator = _type;\n        return target;\n      } else {\n        var _target = new TypeAlias(this);\n        _target.name = name;\n        _target.type = _type;\n        return _target;\n      }\n    }\n  }, {\n    key: 'declare',\n    value: function declare(name, type) {\n\n      if (name instanceof Declaration) {\n        type = name;\n        name = type.name;\n      } else if (name instanceof TypeAlias) {\n        type = name;\n        name = type.name;\n      }\n      if (typeof type === 'function') {\n        type = this.type(name, type);\n      }\n      if (type instanceof ModuleDeclaration) {\n        var moduleRegistry = this[ModuleRegistrySymbol];\n        moduleRegistry[name] = type;\n        return type;\n      } else {\n        invariant(typeof name === 'string', 'Name must be a string');\n        invariant(type instanceof Type, 'Type must be supplied to declaration');\n        var nameRegistry = this[NameRegistrySymbol];\n\n        if (type instanceof Declaration) {\n          nameRegistry[name] = type;\n          return type;\n        } else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n          var target = new TypeDeclaration(this);\n          target.name = name;\n          target.typeAlias = type;\n          nameRegistry[name] = target;\n          return target;\n        } else {\n          var _target2 = this.var(name, type);\n          nameRegistry[name] = _target2;\n          return _target2;\n        }\n      }\n    }\n  }, {\n    key: 'declarations',\n    value: _regeneratorRuntime.mark(function declarations() {\n      var nameRegistry, key;\n      return _regeneratorRuntime.wrap(function declarations$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              nameRegistry = this[NameRegistrySymbol];\n              _context.t0 = _regeneratorRuntime.keys(nameRegistry);\n\n            case 2:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 8;\n                break;\n              }\n\n              key = _context.t1.value;\n              _context.next = 6;\n              return [key, nameRegistry[key]];\n\n            case 6:\n              _context.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, declarations, this);\n    })\n  }, {\n    key: 'modules',\n    value: _regeneratorRuntime.mark(function modules() {\n      var moduleRegistry, key;\n      return _regeneratorRuntime.wrap(function modules$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              moduleRegistry = this[ModuleRegistrySymbol];\n              _context2.t0 = _regeneratorRuntime.keys(moduleRegistry);\n\n            case 2:\n              if ((_context2.t1 = _context2.t0()).done) {\n                _context2.next = 8;\n                break;\n              }\n\n              key = _context2.t1.value;\n              _context2.next = 6;\n              return moduleRegistry[key];\n\n            case 6:\n              _context2.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, modules, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      if (moduleRegistry[moduleName]) {\n        return moduleRegistry[moduleName];\n      }\n\n      var _moduleName$split = moduleName.split('/'),\n          _moduleName$split2 = slicedToArray(_moduleName$split, 1),\n          head = _moduleName$split2[0];\n\n      var module = moduleRegistry[head];\n      if (module) {\n        return module.import(moduleName);\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.import(moduleName);\n      }\n    }\n  }, {\n    key: 'declareTypeConstructor',\n    value: function declareTypeConstructor(_ref) {\n      var name = _ref.name,\n          impl = _ref.impl,\n          typeName = _ref.typeName,\n          errors = _ref.errors,\n          accepts = _ref.accepts,\n          inferTypeParameters = _ref.inferTypeParameters;\n\n      var nameRegistry = this[NameRegistrySymbol];\n\n      if (nameRegistry[name]) {\n        this.emitWarningMessage('Redeclaring type: ' + name + ', this may be unintended.');\n      }\n\n      var target = new TypeConstructor(this);\n      target.name = name;\n      target.typeName = typeName;\n      target.impl = impl;\n      target.errors = errors;\n      target.accepts = accepts;\n      target.inferTypeParameters = inferTypeParameters;\n\n      nameRegistry[name] = target;\n\n      if (typeof impl === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        if (handlerRegistry.has(impl)) {\n          this.emitWarningMessage('A type handler already exists for the given implementation of ' + name + '.');\n        }\n        handlerRegistry.set(impl, target);\n      }\n      return target;\n    }\n  }, {\n    key: 'getTypeConstructor',\n    value: function getTypeConstructor(impl) {\n      // Issue 252\n      var handlerRegistry = this[TypeConstructorRegistrySymbol];\n      handlerRegistry;\n\n      return handlerRegistry.get(impl);\n    }\n  }, {\n    key: 'literal',\n    value: function literal(input) {\n      if (input === undefined) {\n        return this.void();\n      } else if (input === null) {\n        return this.null();\n      } else if (typeof input === 'boolean') {\n        return this.boolean(input);\n      } else if (typeof input === 'number') {\n        return this.number(input);\n      } else if (typeof input === 'string') {\n        return this.string(input);\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return this.symbol(input);\n        } else {\n          return this.typeOf(input);\n        }\n    }\n  }, {\n    key: 'null',\n    value: function _null() {\n      return primitiveTypes.null;\n    }\n  }, {\n    key: 'nullable',\n    value: function nullable(type) {\n      var target = new NullableType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'existential',\n    value: function existential() {\n      return primitiveTypes.existential;\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return primitiveTypes.empty;\n    }\n  }, {\n    key: 'any',\n    value: function any() {\n      return primitiveTypes.any;\n    }\n  }, {\n    key: 'mixed',\n    value: function mixed() {\n      return primitiveTypes.mixed;\n    }\n  }, {\n    key: 'void',\n    value: function _void() {\n      return primitiveTypes.void;\n    }\n  }, {\n    key: 'this',\n    value: function _this(input) {\n      var target = new ThisType(this);\n      if (input !== undefined) {\n        target.recorded = input;\n      }\n      return target;\n    }\n  }, {\n    key: 'number',\n    value: function number(input) {\n      if (input !== undefined) {\n        var target = new NumericLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.number;\n      }\n    }\n  }, {\n    key: 'boolean',\n    value: function boolean(input) {\n      if (input !== undefined) {\n        var target = new BooleanLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.boolean;\n      }\n    }\n  }, {\n    key: 'string',\n    value: function string(input) {\n      if (input !== undefined) {\n        var target = new StringLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.string;\n      }\n    }\n  }, {\n    key: 'symbol',\n    value: function symbol(input) {\n      if (input !== undefined) {\n        var target = new SymbolLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.symbol;\n      }\n    }\n  }, {\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      return target;\n    }\n  }, {\n    key: 'flowInto',\n    value: function flowInto(typeParameter) {\n      return flowIntoTypeParameter(typeParameter);\n    }\n\n    /**\n     * Bind the type parameters for the parent class of the given instance.\n     */\n\n  }, {\n    key: 'bindTypeParameters',\n    value: function bindTypeParameters(subject) {\n      var instancePrototype = Object.getPrototypeOf(subject);\n      // Issue\n      var parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n      // Issue\n      var parentClass = parentPrototype && parentPrototype.constructor;\n\n      if (!parentClass) {\n        this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n        return subject;\n      }\n      // Issue 252\n      var typeParametersPointer = parentClass[TypeParametersSymbol];\n\n      if (typeParametersPointer) {\n        var typeParameters = subject[typeParametersPointer];\n        var keys = Object.keys(typeParameters);\n\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var length = Math.min(keys.length, typeInstances.length);\n        for (var i = 0; i < length; i++) {\n          var typeParam = typeParameters[keys[i]];\n          typeParam.bound = typeInstances[i];\n        }\n      }\n      return subject;\n    }\n  }, {\n    key: 'module',\n    value: function module(name, body) {\n      var target = new ModuleDeclaration(this);\n      target.name = name;\n      var innerContext = this.createContext();\n      // Issue 252\n      innerContext[ParentSymbol] = this;\n      // Issue 252\n      innerContext[CurrentModuleSymbol] = target;\n\n      target.innerContext = innerContext;\n      body(innerContext);\n      return target;\n    }\n  }, {\n    key: 'moduleExports',\n    value: function moduleExports(type) {\n      var currentModule = this[CurrentModuleSymbol];\n      if (!currentModule) {\n        throw new Error('Cannot declare module.exports outside of a module.');\n      }\n      var target = new ModuleExports(this);\n      target.type = type;\n      currentModule.moduleExports = target;\n      return target;\n    }\n  }, {\n    key: 'var',\n    value: function _var(name, type) {\n      var target = new VarDeclaration(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'class',\n    value: function _class(name, head) {\n      if (typeof head === 'function') {\n        var _target3 = new ParameterizedClassDeclaration(this);\n        _target3.name = name;\n        _target3.bodyCreator = head;\n        return _target3;\n      }\n      var target = new ClassDeclaration(this);\n      target.name = name;\n\n      for (var _len3 = arguments.length, tail = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        tail[_key3 - 2] = arguments[_key3];\n      }\n\n      if (head != null) {\n        tail.unshift(head);\n      }\n      var length = tail.length;\n\n      var properties = [];\n      var body = void 0;\n\n      for (var i = 0; i < length; i++) {\n        var item = tail[i];\n        if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n          properties.push(item);\n        } else if (item instanceof ObjectType) {\n          invariant(!body, 'Class body must only be declared once.');\n          body = item;\n        } else if (item instanceof ExtendsDeclaration) {\n          invariant(!target.superClass, 'Classes can only have one super class.');\n          target.superClass = item;\n        } else if (item != null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof Type)) {\n          for (var propertyName in item) {\n            // eslint-disable-line\n            properties.push(this.property(propertyName, item[propertyName]));\n          }\n        } else {\n          throw new Error('ClassDeclaration cannot contain the given type directly.');\n        }\n      }\n      if (!body) {\n        body = new ObjectType(this);\n      }\n      if (properties.length) {\n        var _body$properties;\n\n        (_body$properties = body.properties).push.apply(_body$properties, properties);\n      }\n      target.body = body;\n      return target;\n    }\n  }, {\n    key: 'extends',\n    value: function _extends(subject) {\n      var target = new ExtendsDeclaration(this);\n\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      target.type = this.ref.apply(this, [subject].concat(toConsumableArray(typeInstances)));\n      return target;\n    }\n  }, {\n    key: 'fn',\n    value: function fn(head) {\n      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        tail[_key5 - 1] = arguments[_key5];\n      }\n\n      return this.function.apply(this, [head].concat(tail));\n    }\n  }, {\n    key: 'function',\n    value: function _function(head) {\n      if (typeof head === 'function') {\n        var _target4 = new ParameterizedFunctionType(this);\n        _target4.bodyCreator = head;\n        return _target4;\n      }\n      var target = new FunctionType(this);\n      if (head != null) {\n        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          tail[_key6 - 1] = arguments[_key6];\n        }\n\n        tail.unshift(head);\n        var length = tail.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = tail[i];\n          if (item instanceof FunctionTypeParam) {\n            target.params.push(item);\n          } else if (item instanceof FunctionTypeRestParam) {\n            target.rest = item;\n          } else if (item instanceof FunctionTypeReturn) {\n            target.returnType = item;\n          } else {\n            throw new Error('FunctionType cannot contain the given type directly.');\n          }\n        }\n      }\n      if (!target.returnType) {\n        target.returnType = this.any();\n      }\n      return target;\n    }\n  }, {\n    key: 'param',\n    value: function param(name, type) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new FunctionTypeParam(this);\n      target.name = name;\n      target.type = type;\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'rest',\n    value: function rest(name, type) {\n      var target = new FunctionTypeRestParam(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'return',\n    value: function _return(type) {\n      var target = new FunctionTypeReturn(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'generator',\n    value: function generator(yieldType, returnType, nextType) {\n      var target = new GeneratorType(this);\n      target.yieldType = yieldType;\n      target.returnType = returnType || this.any();\n      target.nextType = nextType || this.any();\n      return target;\n    }\n  }, {\n    key: 'object',\n    value: function object(head) {\n      var target = new ObjectType(this);\n      if (head != null && (typeof head === 'undefined' ? 'undefined' : _typeof(head)) === 'object' && !(head instanceof Type)) {\n        for (var propertyName in head) {\n          // eslint-disable-line\n          target.properties.push(this.property(propertyName, head[propertyName]));\n        }\n      } else {\n        var body = void 0;\n\n        for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          tail[_key7 - 1] = arguments[_key7];\n        }\n\n        if (head) {\n          body = [head].concat(toConsumableArray(tail));\n        } else {\n          body = tail;\n        }\n        var _body = body,\n            length = _body.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = body[i];\n          if (item instanceof ObjectTypeProperty) {\n            target.properties.push(item);\n          } else if (item instanceof ObjectTypeIndexer) {\n            target.indexers.push(item);\n          } else if (item instanceof ObjectTypeCallProperty) {\n            target.callProperties.push(item);\n          } else {\n            throw new Error('ObjectType cannot contain the given type directly.');\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'exactObject',\n    value: function exactObject(head) {\n      for (var _len8 = arguments.length, tail = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        tail[_key8 - 1] = arguments[_key8];\n      }\n\n      var object = this.object.apply(this, [head].concat(toConsumableArray(tail)));\n      object.exact = true;\n      return object;\n    }\n  }, {\n    key: 'callProperty',\n    value: function callProperty(value) {\n      var target = new ObjectTypeCallProperty(this);\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'property',\n    value: function property(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new ObjectTypeProperty(this);\n      target.key = key;\n      if (value instanceof Type) {\n        target.value = value;\n      } else {\n        target.value = this.object(value);\n      }\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'indexer',\n    value: function indexer(id, key, value) {\n      var target = new ObjectTypeIndexer(this);\n      target.id = id;\n      target.key = key;\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'method',\n    value: function method(name, head) {\n      var target = new ObjectTypeProperty(this);\n      target.key = name;\n\n      for (var _len9 = arguments.length, tail = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        tail[_key9 - 2] = arguments[_key9];\n      }\n\n      target.value = this.function.apply(this, [head].concat(tail));\n      return target;\n    }\n  }, {\n    key: 'staticCallProperty',\n    value: function staticCallProperty(value) {\n      var prop = this.callProperty(value);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticProperty',\n    value: function staticProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var prop = this.property(key, value, optional);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticMethod',\n    value: function staticMethod(name, head) {\n      for (var _len10 = arguments.length, tail = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        tail[_key10 - 2] = arguments[_key10];\n      }\n\n      var prop = this.method.apply(this, [name, head].concat(tail));\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'tuple',\n    value: function tuple() {\n      var target = new TupleType(this);\n\n      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        types[_key11] = arguments[_key11];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'array',\n    value: function array(elementType) {\n      var target = new ArrayType(this);\n      target.elementType = elementType || this.any();\n      return target;\n    }\n  }, {\n    key: 'union',\n    value: function union() {\n      for (var _len12 = arguments.length, types = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        types[_key12] = arguments[_key12];\n      }\n\n      return makeUnion(this, types);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect() {\n      var target = new IntersectionType(this);\n\n      for (var _len13 = arguments.length, types = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        types[_key13] = arguments[_key13];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'intersection',\n    value: function intersection() {\n      return this.intersect.apply(this, arguments);\n    }\n  }, {\n    key: 'box',\n    value: function box(reveal) {\n      var box = new TypeBox(this);\n      box.reveal = reveal;\n      return box;\n    }\n  }, {\n    key: 'tdz',\n    value: function tdz(reveal, name) {\n      var tdz = new TypeTDZ(this);\n      tdz.reveal = reveal;\n      tdz.name = name;\n      return tdz;\n    }\n  }, {\n    key: 'ref',\n    value: function ref(subject) {\n      var target = void 0;\n      if (typeof subject === 'string') {\n        // try and eagerly resolve the reference\n        target = this.get(subject);\n        if (!target) {\n          // defer dereferencing for now\n          target = new TypeReference(this);\n          target.name = subject;\n        }\n      } else if (typeof subject === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        // see if we have a dedicated TypeConstructor for this.\n        target = handlerRegistry.get(subject);\n\n        if (!target) {\n          // just use a generic type handler.\n          target = new GenericType(this);\n          target.impl = subject;\n          target.name = subject.name;\n        }\n      } else if (subject instanceof Type) {\n        target = subject;\n      } else {\n        if (subject == null || (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) !== 'object') {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead. (got ' + String(subject) + ')');\n        } else if (!warnedInvalidReferences.has(subject)) {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n          warnedInvalidReferences.add(subject);\n        }\n        return this.any();\n      }\n\n      for (var _len14 = arguments.length, typeInstances = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n        typeInstances[_key14 - 1] = arguments[_key14];\n      }\n\n      if (typeInstances.length) {\n        var _target5;\n\n        invariant(typeof target.apply === 'function', 'Cannot apply non-applicable type: ' + target.typeName + '.');\n        return (_target5 = target).apply.apply(_target5, toConsumableArray(typeInstances));\n      } else {\n        return target;\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = new Validation(this, input);\n      if (path) {\n        var _validation$path;\n\n        (_validation$path = validation.path).push.apply(_validation$path, toConsumableArray(path));\n      } else if (typeof type.name === 'string') {\n        validation.path.push(type.name);\n      }\n      validation.prefix = prefix;\n      validation.errors = Array.from(type.errors(validation, [], input));\n      return validation;\n    }\n  }, {\n    key: 'check',\n    value: function check(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      if (this.mode === 'assert') {\n        return this.assert(type, input, prefix, path);\n      } else {\n        return this.warn(type, input, prefix, path);\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var error = this.makeTypeError(validation);\n      if (error) {\n        throw error;\n      }\n      return input;\n    }\n  }, {\n    key: 'warn',\n    value: function warn(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var message = makeWarningMessage(validation);\n      if (typeof message === 'string') {\n        this.emitWarningMessage(message);\n      }\n      return input;\n    }\n\n    /**\n     * Emits a warning message, using `console.warn()` by default.\n     */\n\n  }, {\n    key: 'emitWarningMessage',\n    value: function emitWarningMessage(message) {\n      console.warn('flow-runtime:', message);\n    }\n  }, {\n    key: 'propTypes',\n    value: function propTypes(type) {\n      return makeReactPropTypes(type.unwrap());\n    }\n  }, {\n    key: 'match',\n    value: function match() {\n      for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n\n      var clauses = args.pop();\n      if (!Array.isArray(clauses)) {\n        throw new Error('Invalid pattern, last argument must be an array.');\n      }\n      clauses;\n      var pattern = this.pattern.apply(this, toConsumableArray(clauses));\n      return pattern.apply(undefined, args);\n    }\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      for (var _len16 = arguments.length, clauses = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        clauses[_key16] = arguments[_key16];\n      }\n\n      var length = clauses.length;\n\n      var tests = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var clause = clauses[i];\n        var annotation = this.getAnnotation(clause);\n        if (!annotation) {\n          if (i !== length - 1) {\n            throw new Error('Invalid Pattern - found unannotated function in position ' + i + ', default clauses must be last.');\n          }\n          tests[i] = true;\n        } else {\n          invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n          tests[i] = annotation;\n        }\n      }\n      return function () {\n        for (var _i = 0; _i < tests.length; _i++) {\n          var test = tests[_i];\n          var _clause = clauses[_i];\n          if (test === true) {\n            return _clause.apply(undefined, arguments);\n          } else if (test.acceptsParams.apply(test, arguments)) {\n            return _clause.apply(undefined, arguments);\n          }\n        }\n        var error = new TypeError('Value did not match any of the candidates.');\n        error.name = 'RuntimeTypeError';\n        throw error;\n      };\n    }\n  }, {\n    key: 'wrapIterator',\n    value: function wrapIterator(type) {\n      var t = this;\n      return _regeneratorRuntime.mark(function wrappedIterator(input) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;\n\n        return _regeneratorRuntime.wrap(function wrappedIterator$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context3.prev = 3;\n                _iterator = input[Symbol.iterator]();\n\n              case 5:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                item = _step.value;\n                _context3.next = 9;\n                return t.check(type, item);\n\n              case 9:\n                _iteratorNormalCompletion = true;\n                _context3.next = 5;\n                break;\n\n              case 12:\n                _context3.next = 18;\n                break;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3['catch'](3);\n                _didIteratorError = true;\n                _iteratorError = _context3.t0;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.prev = 19;\n\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n\n              case 21:\n                _context3.prev = 21;\n\n                if (!_didIteratorError) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 24:\n                return _context3.finish(21);\n\n              case 25:\n                return _context3.finish(18);\n\n              case 26:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, wrappedIterator, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n      });\n    }\n  }, {\n    key: 'refinement',\n    value: function refinement(type) {\n      var target = new RefinementType(this);\n      target.type = type;\n\n      for (var _len17 = arguments.length, constraints = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n        constraints[_key17 - 1] = arguments[_key17];\n      }\n\n      target.addConstraint.apply(target, toConsumableArray(constraints));\n      return target;\n    }\n  }, {\n    key: '$diff',\n    value: function $diff(aType, bType) {\n      var target = new $DiffType(this);\n      target.aType = aType;\n      target.bType = bType;\n      return target;\n    }\n  }, {\n    key: '$flowFixMe',\n    value: function $flowFixMe() {\n      return new $FlowFixMeType(this);\n    }\n  }, {\n    key: '$keys',\n    value: function $keys(type) {\n      var target = new $KeysType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$objMap',\n    value: function $objMap(object, mapper) {\n      var target = new $ObjMapType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$objMapi',\n    value: function $objMapi(object, mapper) {\n      var target = new $ObjMapiType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$propertyType',\n    value: function $propertyType(object, property) {\n      var target = new $PropertyType(this);\n      target.object = object;\n      if (property instanceof Type) {\n        var unwrapped = property.unwrap();\n        target.property = unwrapped.value;\n      } else {\n        target.property = property;\n      }\n      return target;\n    }\n  }, {\n    key: '$shape',\n    value: function $shape(type) {\n      var target = new $ShapeType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$subtype',\n    value: function $subtype(type) {\n      var target = new $SubType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$supertype',\n    value: function $supertype(type) {\n      var target = new $SuperType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$tupleMap',\n    value: function $tupleMap(tuple, mapper) {\n      var target = new $TupleMapType(this);\n      target.tuple = tuple;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: 'Class',\n    value: function Class(instanceType) {\n      var target = new ClassType(this);\n      target.instanceType = instanceType;\n      return target;\n    }\n  }, {\n    key: 'TypeParametersSymbol',\n\n\n    // Issue 252\n    get: function get$$1() {\n      return TypeParametersSymbol;\n    }\n  }]);\n  return TypeContext;\n}();\n\nvar globalContext$1 = void 0;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext$1 = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n} else {\n  globalContext$1 = new TypeContext();\n  registerPrimitiveTypes(globalContext$1);\n  registerBuiltinTypeConstructors(globalContext$1);\n  registerTypePredicates(globalContext$1);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext$1;\n  }\n}\n\nvar globalContext$2 = globalContext$1;\n\nfunction defineProperty(name, value) {\n  Object.defineProperty(globalContext$2, name, {\n    value: value\n  });\n}\n\ndefineProperty('TypeContext', TypeContext);\ndefineProperty('Type', Type);\ndefineProperty('TypeBox', TypeBox);\ndefineProperty('TypeParameter', TypeParameter);\ndefineProperty('TypeReference', TypeReference);\ndefineProperty('TypeTDZ', TypeTDZ);\ndefineProperty('ParameterizedTypeAlias', ParameterizedTypeAlias);\ndefineProperty('TypeAlias', TypeAlias);\ndefineProperty('TypeConstructor', TypeConstructor);\ndefineProperty('GenericType', GenericType);\ndefineProperty('NullLiteralType', NullLiteralType);\ndefineProperty('NumberType', NumberType);\ndefineProperty('NumericLiteralType', NumericLiteralType);\ndefineProperty('BooleanType', BooleanType);\ndefineProperty('BooleanLiteralType', BooleanLiteralType);\ndefineProperty('SymbolType', SymbolType);\ndefineProperty('SymbolLiteralType', SymbolLiteralType);\ndefineProperty('StringType', StringType);\ndefineProperty('StringLiteralType', StringLiteralType);\ndefineProperty('ArrayType', ArrayType);\ndefineProperty('ObjectType', ObjectType);\ndefineProperty('ObjectTypeCallProperty', ObjectTypeCallProperty);\ndefineProperty('ObjectTypeIndexer', ObjectTypeIndexer);\ndefineProperty('ObjectTypeProperty', ObjectTypeProperty);\ndefineProperty('FunctionType', FunctionType);\ndefineProperty('FunctionTypeParam', FunctionTypeParam);\ndefineProperty('FunctionTypeRestParam', FunctionTypeRestParam);\ndefineProperty('FunctionTypeReturn', FunctionTypeReturn);\ndefineProperty('ParameterizedFunctionType', ParameterizedFunctionType);\ndefineProperty('PartialType', PartialType);\ndefineProperty('RefinementType', RefinementType);\ndefineProperty('TypeParameterApplication', TypeParameterApplication);\ndefineProperty('GeneratorType', GeneratorType);\ndefineProperty('ExistentialType', ExistentialType);\ndefineProperty('FlowIntoType', FlowIntoType);\ndefineProperty('AnyType', AnyType);\ndefineProperty('MixedType', MixedType);\ndefineProperty('EmptyType', EmptyType);\ndefineProperty('NullableType', NullableType);\ndefineProperty('ThisType', ThisType);\ndefineProperty('TupleType', TupleType);\ndefineProperty('UnionType', UnionType);\ndefineProperty('IntersectionType', IntersectionType);\ndefineProperty('VoidType', VoidType);\ndefineProperty('Declaration', Declaration);\ndefineProperty('VarDeclaration', VarDeclaration);\ndefineProperty('TypeDeclaration', TypeDeclaration);\ndefineProperty('ModuleDeclaration', ModuleDeclaration);\ndefineProperty('ModuleExportsDeclaration', ModuleExports);\ndefineProperty('ClassDeclaration', ClassDeclaration);\ndefineProperty('ParameterizedClassDeclaration', ParameterizedClassDeclaration);\ndefineProperty('ExtendsDeclaration', ExtendsDeclaration);\n\nreturn globalContext$2;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(4);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ts-runtime.lib.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5ca473610adcbf958f6f","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","import * as t from 'flow-runtime';\n\nconst voidType = t.void;\nconst typeOf = t.typeOf;\n\nt.undef = () => {\n  return voidType.bind(t)();\n}\n\nt.nostrict = (...args: any[]) => {\n  return t.union(...args, t.null(), t.undef());\n}\n\nt.void = () => {\n  return t.union(t.null(), t.undef());\n}\n\nt.n = (...args: any[]) => {\n  return t.nullable(...args);\n}\n\nt.enum = (...args: any[]) => {\n  return t.union(...args);\n}\n\nt.enumMember = (arg: any) => {\n  return t.literal(arg);\n}\n\nt.enumRef = (...args: any[]) => {\n  return t.typeOf(...args);\n}\n\nt.typeOf = (input: any, declaration = false) => {\n  if (declaration && typeof input === 'string') {\n    input = t.get(input);\n\n    if (input) {\n      if (input.typeName === 'ClassDeclaration') {\n        return t.Class(input);\n      }\n\n      return input;\n    }\n  }\n\n  return typeOf.bind(t)(input);\n}\n\nexport const lib = t;\nexport default t;\n\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n\n\n\n// WEBPACK FOOTER //\n// /Users/fabian/Documents/Development/ts-runtime/node_modules/source-map-loader!/Users/fabian/Documents/Development/ts-runtime/src/lib/index.ts","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeJSONError.js","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}\n\n\n// WEBPACK FOOTER //\n// ../src/cyclic.js","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/Validation.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`);\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeTypeError.js","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/makeError.js","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/compareTypes.js","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/getErrorMessage.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from './FlowIntoType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    }\n    else if (recorded) {\n      return recorded.accepts(input);\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameter.js","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/invariant.js","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/typeConstraints.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ParameterizedClassDeclaration.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else if (this.exact) {\n      result = acceptsExact(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        yield* property.errors(validation, path, input);\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/IntersectionType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedTypeAlias.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedFunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeTDZ.js","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeReactPropTypes.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeWarningMessage.js","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeUnion.js","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/classDecorators.js","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/annotateValue.js","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/ClassType.js","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction defineProperty (name: string, value: any) {\n  Object.defineProperty(globalContext, name, {\n    value: value\n  });\n}\n\ndefineProperty('TypeContext', TypeContext);\ndefineProperty('Type', Type);\ndefineProperty('TypeBox', TypeBox);\ndefineProperty('TypeParameter', TypeParameter);\ndefineProperty('TypeReference', TypeReference);\ndefineProperty('TypeTDZ', TypeTDZ);\ndefineProperty('ParameterizedTypeAlias', ParameterizedTypeAlias);\ndefineProperty('TypeAlias', TypeAlias);\ndefineProperty('TypeConstructor', TypeConstructor);\ndefineProperty('GenericType', GenericType);\ndefineProperty('NullLiteralType', NullLiteralType);\ndefineProperty('NumberType', NumberType);\ndefineProperty('NumericLiteralType', NumericLiteralType);\ndefineProperty('BooleanType', BooleanType);\ndefineProperty('BooleanLiteralType', BooleanLiteralType);\ndefineProperty('SymbolType', SymbolType);\ndefineProperty('SymbolLiteralType', SymbolLiteralType);\ndefineProperty('StringType', StringType);\ndefineProperty('StringLiteralType', StringLiteralType);\ndefineProperty('ArrayType', ArrayType);\ndefineProperty('ObjectType', ObjectType);\ndefineProperty('ObjectTypeCallProperty', ObjectTypeCallProperty);\ndefineProperty('ObjectTypeIndexer', ObjectTypeIndexer);\ndefineProperty('ObjectTypeProperty', ObjectTypeProperty);\ndefineProperty('FunctionType', FunctionType);\ndefineProperty('FunctionTypeParam', FunctionTypeParam);\ndefineProperty('FunctionTypeRestParam', FunctionTypeRestParam);\ndefineProperty('FunctionTypeReturn', FunctionTypeReturn);\ndefineProperty('ParameterizedFunctionType', ParameterizedFunctionType);\ndefineProperty('PartialType', PartialType);\ndefineProperty('RefinementType', RefinementType);\ndefineProperty('TypeParameterApplication', TypeParameterApplication);\ndefineProperty('GeneratorType', GeneratorType);\ndefineProperty('ExistentialType', ExistentialType);\ndefineProperty('FlowIntoType', FlowIntoType);\ndefineProperty('AnyType', AnyType);\ndefineProperty('MixedType', MixedType);\ndefineProperty('EmptyType', EmptyType);\ndefineProperty('NullableType', NullableType);\ndefineProperty('ThisType', ThisType);\ndefineProperty('TupleType', TupleType);\ndefineProperty('UnionType', UnionType);\ndefineProperty('IntersectionType', IntersectionType);\ndefineProperty('VoidType', VoidType);\ndefineProperty('Declaration', Declaration);\ndefineProperty('VarDeclaration', VarDeclaration);\ndefineProperty('TypeDeclaration', TypeDeclaration);\ndefineProperty('ModuleDeclaration', ModuleDeclaration);\ndefineProperty('ModuleExportsDeclaration', ModuleExportsDeclaration);\ndefineProperty('ClassDeclaration', ClassDeclaration);\ndefineProperty('ParameterizedClassDeclaration', ParameterizedClassDeclaration);\ndefineProperty('ExtendsDeclaration', ExtendsDeclaration);\n\nexport default globalContext;\n\n\n\n// WEBPACK FOOTER //\n// ../src/index.cjs.js","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;\n\n\n// WEBPACK FOOTER //\n// ../src/primitiveTypes.js","export default require(\"regenerator-runtime\");\n\n\n\n// WEBPACK FOOTER //\n// ../node_modules/rollup-regenerator-runtime/regenerator/index.js","/* @flow */\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n}\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/RuntimeTypeError.js","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/Type.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/AnyType.js","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exists on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n\n\n// WEBPACK FOOTER //\n// ../src/errorMessages.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/TupleType.js","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ArrayType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/EmptyType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ExistentialType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FlowIntoType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeRestParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeReturn.js","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\n\n\n// WEBPACK FOOTER //\n// ../src/symbols.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GeneratorType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameterApplication.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeConstructor.js","/* @flow */\n\nimport TypeConstructor from './TypeConstructor';\n\nimport type Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GenericType extends TypeConstructor {\n\n  typeName: string = 'GenericType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {name, impl, context} = this;\n    if (!(input instanceof impl)) {\n      const annotation = context.getAnnotation(impl);\n      if (annotation) {\n        yield* annotation.errors(validation, path, input);\n      }\n      else {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', name), this];\n      }\n    }\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, impl} = this;\n    if (input instanceof impl) {\n      return true;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      return annotation.accepts(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  compareWith <P> (input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const {context, impl} = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    }\n    else if (input instanceof GenericType && (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  unwrap <P> (...typeInstances: Type<P>[]) {\n    const {context, impl} = this;\n    if (typeof impl !== 'function') {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    }\n    else {\n      return this;\n    }\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GenericType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullLiteralType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/VoidType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullableType.js","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeProperty.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeIndexer.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeCallProperty.js","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/Declaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/VarDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/TypeDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleExportsDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ClassDeclaration.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/PartialType.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ExtendsDeclaration.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/MixedType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeAlias.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumericLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumberType.js","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/RefinementType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolType.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ThisType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeBox.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeReference.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/UnionType.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;\n\n\n// WEBPACK FOOTER //\n// ../src/TypeInferrer.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$DiffType.js","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$FlowFixMeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$KeysType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapiType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$PropertyType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ShapeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SubType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SuperType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$TupleMapType.js","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/TypeContext.js","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;\n\n\n// WEBPACK FOOTER //\n// ../src/globalContext.js","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerPrimitiveTypes.js","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerBuiltins.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    }\n    else if (input !== null && typeof input === 'object' && typeof input.then === 'function') {\n      return input.then.length >= 2;\n    }\n    else {\n      return false;\n    }\n  });\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerTypePredicates.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/fabian/Documents/Development/ts-runtime/node_modules/regenerator-runtime/runtime-module.js\n// module id = 3\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/fabian/Documents/Development/ts-runtime/node_modules/regenerator-runtime/runtime.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}