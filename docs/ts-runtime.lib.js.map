{"version":3,"sources":["webpack:///ts-runtime.lib.js","webpack:///webpack/bootstrap 4ae3b360737cba592af8","webpack:////Users/fabian/Development/ts-runtime-update/src/lib/index.ts","webpack:///../src/errorReporting/makeJSONError.js","webpack:///../src/cyclic.js","webpack:///../src/Validation.js","webpack:///../src/errorReporting/makeTypeError.js","webpack:///../src/makeError.js","webpack:///../src/compareTypes.js","webpack:///../src/getErrorMessage.js","webpack:///../src/typeConstraints.js","webpack:///../src/types/TypeParameter.js","webpack:///../src/invariant.js","webpack:///../src/declarations/ModuleDeclaration.js","webpack:///../src/declarations/ParameterizedClassDeclaration.js","webpack:///../src/types/ObjectType.js","webpack:///../src/types/IntersectionType.js","webpack:///../src/types/ParameterizedTypeAlias.js","webpack:///../src/types/ParameterizedFunctionType.js","webpack:///../src/types/TypeTDZ.js","webpack:///../src/makeReactPropTypes.js","webpack:///../src/errorReporting/makeWarningMessage.js","webpack:///../src/makeUnion.js","webpack:///../src/classDecorators.js","webpack:///../src/annotateValue.js","webpack:///../src/flowTypes/ClassType.js","webpack:///../src/index.cjs.js","webpack:///../src/primitiveTypes.js","webpack:///../../../node_modules/rollup-regenerator-runtime/regenerator/index.js","webpack:///../src/errorReporting/RuntimeTypeError.js","webpack:///../src/types/Type.js","webpack:///../src/types/AnyType.js","webpack:///../src/errorMessages.js","webpack:///../src/types/TupleType.js","webpack:///../src/types/ArrayType.js","webpack:///../src/types/BooleanLiteralType.js","webpack:///../src/types/BooleanType.js","webpack:///../src/types/EmptyType.js","webpack:///../src/types/ExistentialType.js","webpack:///../src/types/TypeParameterApplication.js","webpack:///../src/types/TypeAlias.js","webpack:///../src/types/FlowIntoType.js","webpack:///../src/types/FunctionTypeRestParam.js","webpack:///../src/types/FunctionTypeParam.js","webpack:///../src/types/FunctionTypeReturn.js","webpack:///../src/symbols.js","webpack:///../src/types/FunctionType.js","webpack:///../src/types/GeneratorType.js","webpack:///../src/types/TypeConstructor.js","webpack:///../src/types/GenericType.js","webpack:///../src/types/NullLiteralType.js","webpack:///../src/types/VoidType.js","webpack:///../src/types/NullableType.js","webpack:///../src/types/ObjectTypeProperty.js","webpack:///../src/types/ObjectTypeIndexer.js","webpack:///../src/types/ObjectTypeCallProperty.js","webpack:///../src/declarations/Declaration.js","webpack:///../src/declarations/VarDeclaration.js","webpack:///../src/declarations/TypeDeclaration.js","webpack:///../src/declarations/ModuleExportsDeclaration.js","webpack:///../src/declarations/ClassDeclaration.js","webpack:///../src/types/PartialType.js","webpack:///../src/declarations/ExtendsDeclaration.js","webpack:///../src/types/MixedType.js","webpack:///../src/types/NumericLiteralType.js","webpack:///../src/types/NumberType.js","webpack:///../src/types/RefinementType.js","webpack:///../src/types/StringLiteralType.js","webpack:///../src/types/StringType.js","webpack:///../src/types/SymbolLiteralType.js","webpack:///../src/types/SymbolType.js","webpack:///../src/types/ThisType.js","webpack:///../src/types/TypeBox.js","webpack:///../src/types/TypeReference.js","webpack:///../src/types/UnionType.js","webpack:///../src/TypeInferrer.js","webpack:///../src/flowTypes/$DiffType.js","webpack:///../src/flowTypes/$FlowFixMeType.js","webpack:///../src/flowTypes/$KeysType.js","webpack:///../src/flowTypes/$ObjMapiType.js","webpack:///../src/flowTypes/$ObjMapType.js","webpack:///../src/flowTypes/$PropertyType.js","webpack:///../src/flowTypes/$ShapeType.js","webpack:///../src/flowTypes/$SubType.js","webpack:///../src/flowTypes/$SuperType.js","webpack:///../src/flowTypes/$TupleMapType.js","webpack:///../src/flowTypes/$ValuesType.js","webpack:///../src/TypeContext.js","webpack:///../src/globalContext.js","webpack:///../src/registerPrimitiveTypes.js","webpack:///../src/registerBuiltins.js","webpack:///../src/registerTypePredicates.js","webpack:///(webpack)/buildin/global.js","webpack:////Users/fabian/Development/ts-runtime-update/node_modules/regenerator-runtime/runtime-module.js","webpack:////Users/fabian/Development/ts-runtime-update/node_modules/regenerator-runtime/runtime.js"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","t","voidType","void","typeOf","undef","bind","nostrict","args","_i","arguments","length","union","apply","concat","null","nullable","enum","enumMember","arg","literal","enumRef","input","declaration","typeName","Class","lib","default","global","factory","this","makeJSONError","validation","hasErrors","context","errors","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","_ref","_ref2","slicedToArray","path","message","expectedType","expected","toString","actual","resolvePath","field","stringifyPath","pointer","join","push","err","return","inValidationCycle","type","tracked","cyclicValidation","weakSetHas","e","startValidationCycle","WeakSet","set","weakSetAdd","endValidationCycle","weakSetDelete","inToStringCycle","cyclicToString","has","startToStringCycle","add","endToStringCycle","delete","weakset","parts","Array","part","validIdentifierOrAccessor","test","String","subject","Map","matchPath","candidate","makeTypeError","prefix","collected","actualType","actualAsString","makeString","RuntimeTypeError","trim","delimiter","_typeof","isArray","constructor","JSON","stringify","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeParameterApplication","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","getErrorMessage","key","_len","params","_key","errorMessages","replace","addConstraints","_subject$constraints","constraints","toConsumableArray","collectConstraintErrors","_len2","_key2","constraint","violation","_regeneratorRuntime","wrap","_context","prev","stop","_marked","constraintsAccept","_len3","_key3","flowIntoTypeParameter","typeParameter","existing","FlowIntoSymbol","target","invariant","error","Error","captureStackTrace","indent","lines","split","getPartial","parent","bodyCreator","partial","PartialType","body","class","shapeID","typeParameters","_len6","typeInstances","_key6","limit","Math","min","typeInstance","bound","intersect","acceptsCallProperties","callProperties","accepts","compareTypeCallProperties","inputCallProperties","identicalCount","loop","callProperty","j","inputCallProperty","acceptsWithIndexers","properties","indexers","seen","indexOf","indexer","acceptsKey","acceptsValue","compareTypeWithIndexers","inputIndexers","inputProperties","isGreater","inputProperty","inputIndexer","acceptsWithoutIndexers","acceptsExact","_ret2","some","v","compareTypeWithoutIndexers","collectErrorsWithIndexers","_i5","_context2","delegateYield","t1","keys","t2","abrupt","_marked$1","collectErrorsWithoutIndexers","_context3","_marked2","collectErrorsExact","_loop2","_this2","_context5","mark","_context4","t0","_marked3","getPropertyIndex","mergeProperties","source","typeProp","index","typeCreator","_len7","_key7","function","_len5","_key5","getRevealed","container","RevealedValue","reveal","warnedInstances","RevealedName","emitWarningMessage","warnedInstances$2","mixed","Type","ref","makeReactPropTypes","objectType","output","props","propName","componentName","makeWarningMessage","makeUnion","types","merged","UnionType","mergeUnionTypes","aTypes","bTypes","bType","aType","makePropertyDescriptor","typeSource","propertyName","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","resolveType","receiver","safeName","className","initializer","config","writable","objectWithoutProperties","propertyPath","_extends","check","assert","warn","originalSetter","annotateValue","TypeSymbol","checkGenericType","impl","isPrototypeOf","annotation","getAnnotation","checkType","thing","primitiveTypes","obj","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","protoProps","staticProps","assign","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","sliceIterator","arr","_arr","_n","_d","_e","_s","arr2","from","WeakMap","Validation","cyclic","didClear","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_errors","_temp","_this","_ret","getPrototypeOf","_TypeError","_Type","ERR_CONSTRAINT_VIOLATION","ERR_EXPECT_ARRAY","ERR_EXPECT_TRUE","ERR_EXPECT_FALSE","ERR_EXPECT_BOOLEAN","ERR_EXPECT_EMPTY","ERR_EXPECT_EXACT_VALUE","ERR_EXPECT_CALLABLE","ERR_EXPECT_CLASS","ERR_EXPECT_FUNCTION","ERR_EXPECT_GENERATOR","ERR_EXPECT_ITERABLE","ERR_EXPECT_ARGUMENT","ERR_EXPECT_RETURN","ERR_EXPECT_N_ARGUMENTS","ERR_EXPECT_INSTANCEOF","ERR_EXPECT_KEY_TYPE","ERR_EXPECT_NULL","ERR_EXPECT_NUMBER","ERR_EXPECT_OBJECT","ERR_EXPECT_PROMISE","ERR_EXPECT_STRING","ERR_EXPECT_SYMBOL","ERR_EXPECT_THIS","ERR_EXPECT_VOID","ERR_INVALID_DATE","ERR_MISSING_PROPERTY","ERR_NO_INDEXER","ERR_NO_UNION","ERR_UNKNOWN_KEY","TupleType","checkPredicate","inputTypes","ArrayType","elementType","inCycle","startCycle","endCycle","BooleanLiteralType","BooleanType","EmptyType","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","finish","hasConstraints","withDeclaration","boundOrDefault","recorded","withBinding","id","defaultType","hasError","_hasError","_error","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","param","annotationParam","_param","acceptsType","any","inputReturnType","returnTypeResult","inputParams","inputParam","rest","paramsLength","argsLength","_len4","_key4","empty","GeneratorType","isValid","throw","yieldType","nextType","TypeConstructor","GenericType","_TypeConstructor","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","static","isStatic","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","_Declaration","TypeDeclaration","_typeAlias","typeAlias","addConstraint","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declarations","moduleName","slice","innerContext","import","ModuleExports","ClassDeclaration","errorPath","errorMessage","isSuperClassOf","current","superClassName","bodyProps","superProps","seenStatic","expand","ParameterizedClassDeclaration","ExtendsDeclaration","ObjectType","exact","getIndexer","newProp","hasIndexer","hasCallProperties","IntersectionType","NumericLiteralType","NumberType","ParameterizedTypeAlias","_TypeAlias","identifier","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","RefinementType","StringLiteralType","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","warnedInstances$1","warnedMissing","TypeReference","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","$DiffType","$FlowFixMeType","$KeysType","$ObjMapiType","mapper","applied","invoke","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","$ValuesType","ClassType","instanceType","warnedInvalidReferences","TypeContext","mode","TypeInferrer","inferrer","infer","propertyNames","fromParent","getPredicate","predicate","Boolean","annotate","_target","nameRegistry","var","moduleRegistry","_moduleName$split","_moduleName$split2","head","handlerRegistry","instancePrototype","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","_target3","tail","unshift","_body$properties","_target4","_body","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_target$callPropertie","_target$indexers","setProperty","_len12","_key12","_len13","_key13","_len14","_key14","tdz","_len15","_key15","_target5","_validation$path","console","_len16","_key16","clauses","pop","pattern","_len17","_key17","tests","clause","wrappedIterator","_len18","_key18","_target$callPropertie2","_target$indexers2","_target$properties","_$PropertyType","globalContext","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","globalContext$1","freeze","declareTypeConstructor","Date","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref5","_ref6","findKey","Set","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","setPredicate","then","globalContext$2","g","Function","eval","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","AsyncIterator","resolve","reject","record","hasOwn","__await","enqueue","callInvokeWithMethodAndArg","previousPromise","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","GenStateSuspendedYield","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","iteratorSymbol","Op","$Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","reverse","skipTempReset","charAt","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","catch","thrown"],"mappings":"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GAAYxL,IACVI,IAAK,SACL5H,MAAoB2I,GAAoBqF,KAAK,QAAS7L,G+B37B/CH,EAA6BiB,EAAsB3B,G/B47BxD,MAAOqH,IAAoBC,KAAK,SAAiBC,GAC/C,OACE,OAAQA,EAASC,KAAOD,EAASjG,MAC/B,IAAK,GACL,IAAK,MACH,MAAOiG,GAASE,SAGrB5G,EAAQL,UAGb8F,IAAK,UACL5H,MAAO,S+Bp8BAsB,G/Bq8BL,O+Bp8BK,K/Bu8BPsG,IAAK,cACL5H,MAAO,S+Br8BIsB,G/Bs8BT,M+Br8BK,M/Bw8BPsG,IAAK,WACL5H,MAAO,WACL,M+Bt8BK,S/By8BP4H,IAAK,SACL5H,MAAO,WACL,OACEwB,S+Bv8BQM,KAAKN,c/B28BZgG,G+Bj+B4BgI,ICJ/BxH,IhCy+BJuN,yBgCx+B0B,wBhCy+B1BC,iBgCx+BkB,mBhCy+BlBC,gBgCx+BiB,ehCy+BjBC,iBgCx+BkB,gBhCy+BlBC,mBgCx+BoB,wBhCy+BpBC,iBgCx+BkB,gBhCy+BlBC,uBgCx+BwB,qBhCy+BxBC,oBgCx+BqB,mBhCy+BrBC,iBgCx+BkB,wBhCy+BlBC,oBgCx+BqB,qBhCy+BrBC,qBgCx+BsB,+BhCy+BtBC,oBgCx+BqB,mBhCy+BrBC,oBgCx+BqB,4BhCy+BrBC,kBgCx+BmB,8BhCy+BnBC,uBgCx+BwB,0BhCy+BxBC,sBgCx+BuB,4BhCy+BvBC,oBgCx+BqB,mBhCy+BrBC,gBgCx+BiB,ehCy+BjBC,kBgCx+BmB,mBhCy+BnBC,kBgCx+BmB,oBhCy+BnBC,mBgCx+BoB,0BhCy+BpBC,kBgCx+BmB,mBhCy+BnBC,kBgCx+BmB,mBhCy+BnBC,gBgCx+BiB,uBhCy+BjBC,gBgCx+BiB,oBhCy+BjBC,iBgCx+BkB,uBhCy+BlBC,qBgCx+BsB,2BhCy+BtBC,egCx+BgB,4ChCy+BhBC,agCx+Bc,qBhCy+BdC,gBgCx+BiB,oCCzBEC,ejCshCnB,QAASA,KACP,GAAIvU,GAEAmS,EAAOC,EAAOC,CAElBvC,IAAe9Q,KAAMuV,EAErB,KAAK,GAAIxP,GAAOnH,UAAUC,OAAQH,EAAO4E,MAAMyC,GAAOE,EAAO,EAAGA,EAAO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BD,W0B/6WY9S,GAAE8S,I1Bg7WdD,kB0B/6WmB7S,GAAE6S,I1Bg7WrBnI,U0B/6WW1K,GAAE0K,I1Bg7Wb8G,W0B/6WYxR,GAAEwR,I1Bg7WdlC,uB0B/6WwBtP,GAAEsP,I1Bg7W1BH,kB0B/6WmBnP,GAAEmP,I1Bg7WrBN,mB0B/6WoB7O,GAAE6O,I1Bg7WtB5B,a0B/6WcjN,GAAEiN,I1Bg7WhBX,kB0B/6WmBtM,GAAEsM,I1Bg7WrBD,sB0B/6WuBrM,GAAEqM,I1Bg7WzBG,mB0B/6WoBxM,GAAEwM,I1Bg7WtB4F,0B0B/6W2BpS,GAAEoS,I1Bg7W7B9U,Y0B/6Wa0C,GAAE1C,I1Bg7WfsV,e0B/6WgB5S,GAAE4S,I1Bg7WlBvY,yB0B/6W0B2F,GAAE3F,I1Bg7W5B6T,c0B/6WelO,GAAEkO,I1Bg7WjBvT,gB0B/6WiBqF,GAAErF,I1Bg7WnBF,a0B/6WcuF,GAAEvF,I1Bg7WhBC,Q0B/6WSsF,GAAEtF,I1Bg7WXE,U0B/6WWoF,GAAEpF,I1Bg7WbqQ,U0B/6WWjL,GAAEiL,I1Bg7Wb2D,a0B/6Wc5O,GAAE4O,I1Bg7WhBqE,S0B/6WUjT,GAAEiT,I1Bg7WZ1I,U0B/6WWvK,GAAEuK,I1Bg7WbjH,U0B/6WWtD,GAAEsD,I1Bg7WbwO,iB0B/6WkB9R,GAAE8R,I1Bg7WpBnD,S0B/6WU3O,GAAE2O,I1Bg7WZY,Y0B/6WavP,GAAEuP,I1Bg7WfC,e0B/6WgBxP,GAAEwP,I1Bg7WlBE,gB0B/6WiB1P,GAAE0P,I1Bg7WnBQ,kB0B/6WmBlQ,GAAEkQ,I1Bg7WrBkI,yB0B/6W0BpY,GAAEoY,I1Bg7W5BxH,iB0B/6WkB5Q,GAAE4Q,I1Bg7WpBU,8B0B/6W+BtR,GAAEsR,I1Bg7WjCC,mB0B/6WoBvR,GAAEuR,M1Bm7WnB+L,OAIsBxrB,KAAKJ,EAASH,EAAoB,KAIzD,SAAUI,EAAQD,G4FpjXxB,GAAA6rB,EAGAA,GAAA,WACA,MAAAvoB,QAGA,KAEAuoB,KAAAC,SAAA,qBAAAC,MAAA,QACC,MAAAnmB,GAED,gBAAAjG,UACAksB,EAAAlsB,QAOAM,EAAAD,QAAA6rB,G5F2jXM,SAAU5rB,EAAQD,EAASH,G6FtkXjC,GAAAgsB,GAAA,WAAqB,MAAAvoB,UAAcwoB,SAAA,iBAInCE,EAAAH,EAAAI,oBACAtrB,OAAAurB,oBAAAL,GAAAre,QAAA,yBAGA2e,EAAAH,GAAAH,EAAAI,kBAOA,IAJAJ,EAAAI,uBAAAloB,GAEA9D,EAAAD,QAAAH,EAAA,GAEAmsB,EAEAH,EAAAI,mBAAAE,MAGA,WACAN,GAAAI,mBACG,MAAArmB,GACHimB,EAAAI,uBAAAloB,K7FwlXM,SAAU9D,EAAQD,I8FjnXxB,SAAAoD,GACA,YA2BA,SAAAgH,GAAAgiB,EAAAC,EAAAjX,EAAAkX,GAEA,GAAAC,GAAAF,KAAAjrB,oBAAAorB,GAAAH,EAAAG,EACAC,EAAA9rB,OAAAqU,OAAAuX,EAAAnrB,WACAsC,EAAA,GAAAgpB,GAAAJ,MAMA,OAFAG,GAAAE,QAAAC,EAAAR,EAAAhX,EAAA1R,GAEA+oB,EAcA,QAAAI,GAAAnK,EAAAvO,EAAAxR,GACA,IACA,OAAc6C,KAAA,SAAA7C,IAAA+f,EAAAtiB,KAAA+T,EAAAxR,IACT,MAAA0C,GACL,OAAcG,KAAA,QAAA7C,IAAA0C,IAiBd,QAAAmnB,MACA,QAAAM,MACA,QAAAC,MA4BA,QAAAC,GAAA5rB,IACA,yBAAA6rB,QAAA,SAAA1F,GACAnmB,EAAAmmB,GAAA,SAAA5kB,GACA,MAAAW,MAAAqpB,QAAApF,EAAA5kB,MAoCA,QAAAuqB,GAAAT,GACA,QAAA1I,GAAAwD,EAAA5kB,EAAAwqB,EAAAC,GACA,GAAAC,GAAAR,EAAAJ,EAAAlF,GAAAkF,EAAA9pB,EACA,cAAA0qB,EAAA7nB,KAEO,CACP,GAAAgD,GAAA6kB,EAAA1qB,IACAnB,EAAAgH,EAAAhH,KACA,OAAAA,IACA,gBAAAA,IACA8rB,EAAAltB,KAAAoB,EAAA,WACAwoB,QAAAmD,QAAA3rB,EAAA+rB,SAAA5B,KAAA,SAAAnqB,GACAuiB,EAAA,OAAAviB,EAAA2rB,EAAAC,IACW,SAAA/nB,GACX0e,EAAA,QAAA1e,EAAA8nB,EAAAC,KAIApD,QAAAmD,QAAA3rB,GAAAmqB,KAAA,SAAApH,GAgBA/b,EAAAhH,MAAA+iB,EACA4I,EAAA3kB,IACS4kB,GAhCTA,EAAAC,EAAA1qB,KAsCA,QAAA6qB,GAAAjG,EAAA5kB,GACA,QAAA8qB,KACA,UAAAzD,SAAA,SAAAmD,EAAAC,GACArJ,EAAAwD,EAAA5kB,EAAAwqB,EAAAC,KAIA,MAAAM,GAaAA,IAAA/B,KACA8B,EAGAA,GACAA,IA3BA,GAAAC,EAgCApqB,MAAAqpB,QAAAa,EAwBA,QAAAZ,GAAAR,EAAAhX,EAAA1R,GACA,GAAAiqB,GAAAC,CAEA,iBAAArG,EAAA5kB,GACA,GAAAgrB,IAAAE,EACA,SAAA1iB,OAAA,+BAGA,IAAAwiB,IAAAG,EAAA,CACA,aAAAvG,EACA,KAAA5kB,EAKA,OAAAorB,KAMA,IAHArqB,EAAA6jB,SACA7jB,EAAAf,QAEA,CACA,GAAAqrB,GAAAtqB,EAAAsqB,QACA,IAAAA,EAAA,CACA,GAAAC,GAAAC,EAAAF,EAAAtqB,EACA,IAAAuqB,EAAA,CACA,GAAAA,IAAAE,EAAA,QACA,OAAAF,IAIA,YAAAvqB,EAAA6jB,OAGA7jB,EAAA0qB,KAAA1qB,EAAA2qB,MAAA3qB,EAAAf,QAES,cAAAe,EAAA6jB,OAAA,CACT,GAAAoG,IAAAC,EAEA,KADAD,GAAAG,EACApqB,EAAAf,GAGAe,GAAA4qB,kBAAA5qB,EAAAf,SAES,WAAAe,EAAA6jB,QACT7jB,EAAAqL,OAAA,SAAArL,EAAAf,IAGAgrB,GAAAE,CAEA,IAAAR,GAAAR,EAAAT,EAAAhX,EAAA1R,EACA,eAAA2pB,EAAA7nB,KAAA,CAOA,GAJAmoB,EAAAjqB,EAAAW,KACAypB,EACAS,EAEAlB,EAAA1qB,MAAAwrB,EACA,QAGA,QACA3sB,MAAA6rB,EAAA1qB,IACA0B,KAAAX,EAAAW,MAGS,UAAAgpB,EAAA7nB,OACTmoB,EAAAG,EAGApqB,EAAA6jB,OAAA,QACA7jB,EAAAf,IAAA0qB,EAAA1qB,OAUA,QAAAurB,GAAAF,EAAAtqB,GACA,GAAA6jB,GAAAyG,EAAA7pB,SAAAT,EAAA6jB,OACA,IAAAA,IAAAxjB,EAAA,CAKA,GAFAL,EAAAsqB,SAAA,KAEA,UAAAtqB,EAAA6jB,OAAA,CACA,GAAAyG,EAAA7pB,SAAAmB,SAGA5B,EAAA6jB,OAAA,SACA7jB,EAAAf,IAAAoB,EACAmqB,EAAAF,EAAAtqB,GAEA,UAAAA,EAAA6jB,QAGA,MAAA4G,EAIAzqB,GAAA6jB,OAAA,QACA7jB,EAAAf,IAAA,GAAA4R,WACA,kDAGA,MAAA4Z,GAGA,GAAAd,GAAAR,EAAAtF,EAAAyG,EAAA7pB,SAAAT,EAAAf,IAEA,cAAA0qB,EAAA7nB,KAIA,MAHA9B,GAAA6jB,OAAA,QACA7jB,EAAAf,IAAA0qB,EAAA1qB,IACAe,EAAAsqB,SAAA,KACAG,CAGA,IAAAK,GAAAnB,EAAA1qB,GAEA,OAAA6rB,GAOAA,EAAAnqB,MAGAX,EAAAsqB,EAAAS,YAAAD,EAAAhtB,MAGAkC,EAAAU,KAAA4pB,EAAAU,QAQA,WAAAhrB,EAAA6jB,SACA7jB,EAAA6jB,OAAA,OACA7jB,EAAAf,IAAAoB,GAUAL,EAAAsqB,SAAA,KACAG,GANAK,GA3BA9qB,EAAA6jB,OAAA,QACA7jB,EAAAf,IAAA,GAAA4R,WAAA,oCACA7Q,EAAAsqB,SAAA,KACAG,GAoDA,QAAAQ,GAAAC,GACA,GAAAC,IAAiBC,OAAAF,EAAA,GAEjB,KAAAA,KACAC,EAAAE,SAAAH,EAAA,IAGA,IAAAA,KACAC,EAAAG,WAAAJ,EAAA,GACAC,EAAAI,SAAAL,EAAA,IAGAtrB,KAAA4rB,WAAA9pB,KAAAypB,GAGA,QAAAM,GAAAN,GACA,GAAAxB,GAAAwB,EAAAO,cACA/B,GAAA7nB,KAAA,eACA6nB,GAAA1qB,IACAksB,EAAAO,WAAA/B,EAGA,QAAAX,GAAAJ,GAIAhpB,KAAA4rB,aAAwBJ,OAAA,SACxBxC,EAAAW,QAAA0B,EAAArrB,MACAA,KAAA+rB,OAAA,GA8BA,QAAAhM,GAAAiM,GACA,GAAAA,EAAA,CACA,GAAAC,GAAAD,EAAAE,EACA,IAAAD,EACA,MAAAA,GAAAnvB,KAAAkvB,EAGA,sBAAAA,GAAAlrB,KACA,MAAAkrB,EAGA,KAAAlM,MAAAkM,EAAAntB,QAAA,CACA,GAAAjC,IAAA,EAAAkE,EAAA,QAAAA,KACA,OAAAlE,EAAAovB,EAAAntB,QACA,GAAAmrB,EAAAltB,KAAAkvB,EAAApvB,GAGA,MAFAkE,GAAA5C,MAAA8tB,EAAApvB,GACAkE,EAAAC,MAAA,EACAD,CAOA,OAHAA,GAAA5C,MAAAuC,EACAK,EAAAC,MAAA,EAEAD,EAGA,OAAAA,WAKA,OAAYA,KAAA2pB,GAIZ,QAAAA,KACA,OAAYvsB,MAAAuC,EAAAM,MAAA,GA7fZ,GAEAN,GAFA0rB,EAAA9uB,OAAAS,UACAksB,EAAAmC,EAAApuB,eAEAquB,EAAA,kBAAAxrB,kBACAsrB,EAAAE,EAAAvrB,UAAA,aACAwrB,EAAAD,EAAAE,eAAA,kBACAC,EAAAH,EAAAI,aAAA,gBAEAC,EAAA,gBAAA9vB,GACA+vB,EAAA5sB,EAAA6oB,kBACA,IAAA+D,EAQA,YAPAD,IAGA9vB,EAAAD,QAAAgwB,GASAA,GAAA5sB,EAAA6oB,mBAAA8D,EAAA9vB,EAAAD,WAcAgwB,EAAA5lB,MAoBA,IAAAwjB,GAAA,iBACAW,EAAA,iBACAV,EAAA,YACAC,EAAA,YAIAK,KAYA8B,IACAA,GAAAT,GAAA,WACA,MAAAlsB,MAGA,IAAA4sB,GAAAvvB,OAAAiW,eACAuZ,EAAAD,OAAA7M,OACA8M,IACAA,IAAAV,GACAnC,EAAAltB,KAAA+vB,EAAAX,KAGAS,EAAAE,EAGA,IAAAC,GAAArD,EAAA3rB,UACAorB,EAAAprB,UAAAT,OAAAqU,OAAAib,EACAnD,GAAA1rB,UAAAgvB,EAAApoB,YAAA+kB,EACAA,EAAA/kB,YAAA8kB,EACAC,EAAA8C,GACA/C,EAAAuD,YAAA,oBAYAL,EAAAM,oBAAA,SAAAC,GACA,GAAAC,GAAA,kBAAAD,MAAAvoB,WACA,SAAAwoB,IACAA,IAAA1D,GAGA,uBAAA0D,EAAAH,aAAAG,EAAAhwB,QAIAwvB,EAAAxgB,KAAA,SAAA+gB,GAUA,MATA5vB,QAAAsU,eACAtU,OAAAsU,eAAAsb,EAAAxD,IAEAwD,EAAArb,UAAA6X,EACA8C,IAAAU,KACAA,EAAAV,GAAA,sBAGAU,EAAAnvB,UAAAT,OAAAqU,OAAAob,GACAG,GAOAP,EAAAS,MAAA,SAAA9tB,GACA,OAAY4qB,QAAA5qB,IA8EZqqB,EAAAE,EAAA9rB,WACA8rB,EAAA9rB,UAAAuuB,GAAA,WACA,MAAArsB,OAEA0sB,EAAA9C,gBAKA8C,EAAAU,MAAA,SAAAtE,EAAAC,EAAAjX,EAAAkX,GACA,GAAAqE,GAAA,GAAAzD,GACA9iB,EAAAgiB,EAAAC,EAAAjX,EAAAkX,GAGA,OAAA0D,GAAAM,oBAAAjE,GACAsE,EACAA,EAAAvsB,OAAAunB,KAAA,SAAAnjB,GACA,MAAAA,GAAAnE,KAAAmE,EAAAhH,MAAAmvB,EAAAvsB,UAsKA4oB,EAAAoD,GAEAA,EAAAP,GAAA,YAOAO,EAAAZ,GAAA,WACA,MAAAlsB,OAGA8sB,EAAAvrB,SAAA,WACA,4BAkCAmrB,EAAAnhB,KAAA,SAAA3N,GACA,GAAA2N,KACA,QAAAzF,KAAAlI,GACA2N,EAAAzJ,KAAAgE,EAMA,OAJAyF,GAAA+hB,UAIA,QAAAxsB,KACA,KAAAyK,EAAA1M,QAAA,CACA,GAAAiH,GAAAyF,EAAA+Z,KACA,IAAAxf,IAAAlI,GAGA,MAFAkD,GAAA5C,MAAA4H,EACAhF,EAAAC,MAAA,EACAD,EAQA,MADAA,GAAAC,MAAA,EACAD,IAsCA4rB,EAAA3M,SAMAqJ,EAAAtrB,WACA4G,YAAA0kB,EAEA2C,MAAA,SAAAwB,GAcA,GAbAvtB,KAAAgH,KAAA,EACAhH,KAAAc,KAAA,EAGAd,KAAA8qB,KAAA9qB,KAAA+qB,MAAAtqB,EACAT,KAAAe,MAAA,EACAf,KAAA0qB,SAAA,KAEA1qB,KAAAikB,OAAA,OACAjkB,KAAAX,IAAAoB,EAEAT,KAAA4rB,WAAAjC,QAAAkC,IAEA0B,EACA,OAAArwB,KAAA8C,MAEA,MAAA9C,EAAAswB,OAAA,IACAxD,EAAAltB,KAAAkD,KAAA9C,KACA4iB,OAAA5iB,EAAAse,MAAA,MACAxb,KAAA9C,GAAAuD,IAMAwG,KAAA,WACAjH,KAAAe,MAAA,CAEA,IAAA0sB,GAAAztB,KAAA4rB,WAAA,GACA8B,EAAAD,EAAA3B,UACA,cAAA4B,EAAAxrB,KACA,KAAAwrB,GAAAruB,GAGA,OAAAW,MAAA2tB,MAGA3C,kBAAA,SAAA4C,GAMA,QAAAC,GAAAC,EAAAC,GAYA,MAXAhE,GAAA7nB,KAAA,QACA6nB,EAAA1qB,IAAAuuB,EACAxtB,EAAAU,KAAAgtB,EAEAC,IAGA3tB,EAAA6jB,OAAA,OACA7jB,EAAAf,IAAAoB,KAGAstB,EAjBA,GAAA/tB,KAAAe,KACA,KAAA6sB,EAmBA,QAhBAxtB,GAAAJ,KAgBApD,EAAAoD,KAAA4rB,WAAA/sB,OAAA,EAA8CjC,GAAA,IAAQA,EAAA,CACtD,GAAA2uB,GAAAvrB,KAAA4rB,WAAAhvB,GACAmtB,EAAAwB,EAAAO,UAEA,aAAAP,EAAAC,OAIA,MAAAqC,GAAA,MAGA,IAAAtC,EAAAC,QAAAxrB,KAAAgH,KAAA,CACA,GAAAgnB,GAAAhE,EAAAltB,KAAAyuB,EAAA,YACA0C,EAAAjE,EAAAltB,KAAAyuB,EAAA,aAEA,IAAAyC,GAAAC,EAAA,CACA,GAAAjuB,KAAAgH,KAAAukB,EAAAE,SACA,MAAAoC,GAAAtC,EAAAE,UAAA,EACa,IAAAzrB,KAAAgH,KAAAukB,EAAAG,WACb,MAAAmC,GAAAtC,EAAAG,gBAGW,IAAAsC,GACX,GAAAhuB,KAAAgH,KAAAukB,EAAAE,SACA,MAAAoC,GAAAtC,EAAAE,UAAA,OAGW,KAAAwC,EAMX,SAAApmB,OAAA,yCALA,IAAA7H,KAAAgH,KAAAukB,EAAAG,WACA,MAAAmC,GAAAtC,EAAAG,gBAUAjgB,OAAA,SAAAvJ,EAAA7C,GACA,OAAAzC,GAAAoD,KAAA4rB,WAAA/sB,OAAA,EAA8CjC,GAAA,IAAQA,EAAA,CACtD,GAAA2uB,GAAAvrB,KAAA4rB,WAAAhvB,EACA,IAAA2uB,EAAAC,QAAAxrB,KAAAgH,MACAgjB,EAAAltB,KAAAyuB,EAAA,eACAvrB,KAAAgH,KAAAukB,EAAAG,WAAA,CACA,GAAAwC,GAAA3C,CACA,QAIA2C,IACA,UAAAhsB,GACA,aAAAA,IACAgsB,EAAA1C,QAAAnsB,GACAA,GAAA6uB,EAAAxC,aAGAwC,EAAA,KAGA,IAAAnE,GAAAmE,IAAApC,aAIA,OAHA/B,GAAA7nB,OACA6nB,EAAA1qB,MAEA6uB,GACAluB,KAAAikB,OAAA,OACAjkB,KAAAc,KAAAotB,EAAAxC,WACAb,GAGA7qB,KAAAmuB,SAAApE,IAGAoE,SAAA,SAAApE,EAAA4B,GACA,aAAA5B,EAAA7nB,KACA,KAAA6nB,GAAA1qB,GAcA,OAXA,UAAA0qB,EAAA7nB,MACA,aAAA6nB,EAAA7nB,KACAlC,KAAAc,KAAAipB,EAAA1qB,IACO,WAAA0qB,EAAA7nB,MACPlC,KAAA2tB,KAAA3tB,KAAAX,IAAA0qB,EAAA1qB,IACAW,KAAAikB,OAAA,SACAjkB,KAAAc,KAAA,OACO,WAAAipB,EAAA7nB,MAAAypB,IACP3rB,KAAAc,KAAA6qB,GAGAd,GAGApU,OAAA,SAAAiV,GACA,OAAA9uB,GAAAoD,KAAA4rB,WAAA/sB,OAAA,EAA8CjC,GAAA,IAAQA,EAAA,CACtD,GAAA2uB,GAAAvrB,KAAA4rB,WAAAhvB,EACA,IAAA2uB,EAAAG,eAGA,MAFA1rB,MAAAmuB,SAAA5C,EAAAO,WAAAP,EAAAI,UACAE,EAAAN,GACAV,IAKAuD,MAAA,SAAA5C,GACA,OAAA5uB,GAAAoD,KAAA4rB,WAAA/sB,OAAA,EAA8CjC,GAAA,IAAQA,EAAA,CACtD,GAAA2uB,GAAAvrB,KAAA4rB,WAAAhvB,EACA,IAAA2uB,EAAAC,WAAA,CACA,GAAAzB,GAAAwB,EAAAO,UACA,cAAA/B,EAAA7nB,KAAA,CACA,GAAAmsB,GAAAtE,EAAA1qB,GACAwsB,GAAAN,GAEA,MAAA8C,IAMA,SAAAxmB,OAAA,0BAGAwD,cAAA,SAAA2gB,EAAAb,EAAAC,GAaA,MAZAprB,MAAA0qB,UACA7pB,SAAAkf,EAAAiM,GACAb,aACAC,WAGA,SAAAprB,KAAAikB,SAGAjkB,KAAAX,IAAAoB,GAGAoqB,KAOA,WAAe,MAAA7qB,UAAcwoB,SAAA","file":"ts-runtime.lib.js","sourcesContent":["window[\"t\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = __webpack_require__(1);\nvar voidType = t.void;\nvar typeOf = t.typeOf;\nt.undef = function () {\n    return voidType.bind(t)();\n};\nt.nostrict = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args.concat([t.null(), t.undef()]));\n};\nt.void = function () {\n    return t.union(t.null(), t.undef());\n};\nt.n = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.nullable.apply(t, args);\n};\nt.enum = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args);\n};\nt.enumMember = function (arg) {\n    return t.literal(arg);\n};\nt.enumRef = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.typeOf.apply(t, args);\n};\nt.typeOf = function (input, declaration) {\n    if (declaration === void 0) { declaration = false; }\n    if (declaration && typeof input === 'string') {\n        input = t.get(input);\n        if (input) {\n            if (input.typeName === 'ClassDeclaration') {\n                return t.Class(input);\n            }\n            return input;\n        }\n    }\n    return typeOf.bind(t)(input);\n};\nexports.lib = t;\nexports.default = t;\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global['flow-runtime'] = factory());\n}(this, (function () { 'use strict';\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nvar primitiveTypes = {};\n\nvar _regeneratorRuntime = __webpack_require__(3);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction makeJSONError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var errors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : null;\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n      var field = stringifyPath(validation.path.concat(path));\n\n      var pointer = '/' + path.join('/');\n\n      errors.push({\n        pointer: pointer,\n        field: field,\n        message: message,\n        expected: expected,\n        actual: actual\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Tracks whether we're in validation of cyclic objects.\nvar cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\n\n\nvar cyclicToString = new WeakSet();\n\nfunction inValidationCycle(type, input) {\n  try {\n    var tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    } else {\n      return weakSetHas(tracked, input);\n    }\n  } catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nfunction startValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nfunction endValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nfunction inToStringCycle(type) {\n  return cyclicToString.has(type);\n}\n\nfunction startToStringCycle(type) {\n  cyclicToString.add(type);\n}\n\nfunction endToStringCycle(type) {\n  cyclicToString.delete(type);\n}\n\nfunction weakSetHas(weakset, value) {\n  try {\n    return weakset.has(value);\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction weakSetAdd(weakset, value) {\n  try {\n    weakset.add(value);\n  } catch (e) {}\n}\n\nfunction weakSetDelete(weakset, value) {\n  try {\n    weakset.delete(value);\n  } catch (e) {}\n}\n\nvar validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nvar Validation = function () {\n  function Validation(context, input) {\n    classCallCheck(this, Validation);\n    this.path = [];\n    this.prefix = '';\n    this.errors = [];\n    this.cyclic = new WeakMap();\n\n    this.context = context;\n    this.input = input;\n  }\n\n  // Tracks whether we're in validation of cyclic objects.\n\n\n  createClass(Validation, [{\n    key: 'inCycle',\n    value: function inCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        return false;\n      } else {\n        return weakSetHas(tracked, input);\n      }\n    }\n  }, {\n    key: 'startCycle',\n    value: function startCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        tracked = new WeakSet();\n        this.cyclic.set(type, tracked);\n      }\n      weakSetAdd(tracked, input);\n    }\n  }, {\n    key: 'endCycle',\n    value: function endCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (tracked) {\n        weakSetDelete(tracked, input);\n      }\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors(path) {\n      if (path) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var candidate = _ref2[0];\n\n            if (matchPath(path, candidate)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        return this.errors.length > 0;\n      }\n    }\n  }, {\n    key: 'addError',\n    value: function addError(path, expectedType, message) {\n      this.errors.push([path, message, expectedType]);\n      return this;\n    }\n  }, {\n    key: 'clearError',\n    value: function clearError(path) {\n      var didClear = false;\n      if (path) {\n        var _errors = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var error = _step2.value;\n\n            if (matchPath(path, error[0])) {\n              didClear = true;\n            } else {\n              _errors.push(error);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.errors = _errors;\n      } else {\n        didClear = this.errors.length > 0;\n        this.errors = [];\n      }\n      return didClear;\n    }\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path) {\n      return _resolvePath(this.input, path);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return makeJSONError(this);\n    }\n  }]);\n  return Validation;\n}();\n\nfunction stringifyPath(path) {\n  if (!path.length) {\n    return 'Value';\n  }\n  var length = path.length;\n\n  var parts = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    } else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = '[' + String(part) + ']';\n    } else if (i > 0) {\n      parts[i] = '.' + String(part);\n    } else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nfunction _resolvePath(input, path) {\n  var subject = input;\n  var length = path.length;\n\n  for (var i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    } else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nfunction matchPath(path, candidate) {\n  var length = path.length;\n\n  if (length > candidate.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar RuntimeTypeError = function (_TypeError) {\n  inherits(RuntimeTypeError, _TypeError);\n\n  function RuntimeTypeError() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RuntimeTypeError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RuntimeTypeError.__proto__ || Object.getPrototypeOf(RuntimeTypeError)).call.apply(_ref, [this].concat(args))), _this), _this.name = \"RuntimeTypeError\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return RuntimeTypeError;\n}(TypeError);\n\nvar delimiter = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeTypeError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var prefix = validation.prefix,\n      input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = _resolvePath(input, path);\n      var actualType = context.typeOf(actual).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      var actualAsString = makeString(actual);\n\n      if (typeof actualAsString === 'string') {\n        collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual Value: ' + actualAsString + '\\n\\nActual Type: ' + actualType + '\\n');\n      } else {\n        collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actualType + '\\n');\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (prefix) {\n    return new RuntimeTypeError(prefix.trim() + ' ' + collected.join(delimiter));\n  } else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\nfunction makeString(value) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n    case 'string':\n      return '\"' + value + '\"';\n    // Issue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        } catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}\n\nfunction makeError(expected, input) {\n  var context = expected.context;\n\n  var validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\n\n\nfunction compareTypes(a, b) {\n  var result = void 0;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  } else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  } else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  } else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  } else {\n    return result;\n  }\n}\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nvar Type = function () {\n  function Type(context) {\n    classCallCheck(this, Type);\n    this.typeName = 'Type';\n\n    this.context = context;\n  }\n\n  createClass(Type, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var validation = new Validation(this.context, input);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.errors(validation, [], input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n          // eslint-disable-line no-unused-vars\n          return false;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsType',\n    value: function acceptsType(input) {\n      if (compareTypes(this, input) === -1) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return -1;\n    }\n  }, {\n    key: 'assert',\n    value: function assert(input) {\n      var error = makeError(this, input);\n      if (error) {\n        if (typeof Error.captureStackTrace === 'function') {\n          Error.captureStackTrace(error, this.assert);\n        }\n        throw error;\n      }\n      return input;\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Type';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return Type;\n}();\n\nvar AnyType = function (_Type) {\n  inherits(AnyType, _Type);\n\n  function AnyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AnyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AnyType.__proto__ || Object.getPrototypeOf(AnyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'AnyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AnyType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'any';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return AnyType;\n}(Type);\n\nvar errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nfunction getErrorMessage(key) {\n  for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, function (m, i) {\n      return String(params[i]);\n    });\n  } else {\n    return message;\n  }\n}\n\nvar TupleType = function (_Type) {\n  inherits(TupleType, _Type);\n\n  function TupleType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TupleType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TupleType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, context, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < length)) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path.concat(i), input[i]), 't0', 10);\n\n            case 10:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 13:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n\n      if (!context.checkPredicate('Array', input) || input.length < length) {\n        return false;\n      }\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof TupleType)) {\n        return -1;\n      }\n      var types = this.types;\n      var inputTypes = input.types;\n      if (inputTypes.length < types.length) {\n        return -1;\n      }\n      var isGreater = false;\n      for (var i = 0; i < types.length; i++) {\n        var result = compareTypes(types[i], inputTypes[i]);\n        if (result === 1) {\n          isGreater = true;\n        } else if (result === -1) {\n          return -1;\n        }\n      }\n      if (types.length < inputTypes.length) {\n        return 0;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.types.join(', ') + ']';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return TupleType;\n}(Type);\n\nvar ArrayType = function (_Type) {\n  inherits(ArrayType, _Type);\n\n  function ArrayType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ArrayType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ArrayType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ArrayType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var context, elementType, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              validation.startCycle(this, input);\n              elementType = this.elementType;\n              length = input.length;\n              i = 0;\n\n            case 11:\n              if (!(i < length)) {\n                _context.next = 16;\n                break;\n              }\n\n              return _context.delegateYield(elementType.errors(validation, path.concat(i), input[i]), 't0', 13);\n\n            case 13:\n              i++;\n              _context.next = 11;\n              break;\n\n            case 16:\n              validation.endCycle(this, input);\n\n            case 17:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n      for (var i = 0; i < length; i++) {\n        if (!elementType.accepts(input[i])) {\n          endValidationCycle(this, input);\n          return false;\n        }\n      }\n      endValidationCycle(this, input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var elementType = this.elementType;\n\n      if (input instanceof TupleType) {\n        var types = input.types;\n\n        for (var i = 0; i < types.length; i++) {\n          var result = compareTypes(elementType, types[i]);\n          if (result === -1) {\n            return -1;\n          }\n        }\n        return 1;\n      } else if (input instanceof ArrayType) {\n        return compareTypes(elementType, input.elementType);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var elementType = this.elementType;\n\n      if (inToStringCycle(this)) {\n        if (typeof elementType.name === 'string') {\n          return 'Array<$Cycle<' + elementType.name + '>>';\n        } else {\n          return 'Array<$Cycle<Object>>';\n        }\n      }\n      startToStringCycle(this);\n      var output = 'Array<' + elementType.toString() + '>';\n      endToStringCycle(this);\n      return output;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        elementType: this.elementType\n      };\n    }\n  }]);\n  return ArrayType;\n}(Type);\n\nvar BooleanLiteralType = function (_Type) {\n  inherits(BooleanLiteralType, _Type);\n\n  function BooleanLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanLiteralType.__proto__ || Object.getPrototypeOf(BooleanLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanLiteralType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== this.value)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.value ? 'true' : 'false';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        type: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return BooleanLiteralType;\n}(Type);\n\nvar BooleanType = function (_Type) {\n  inherits(BooleanType, _Type);\n\n  function BooleanType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanType.__proto__ || Object.getPrototypeOf(BooleanType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'boolean')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'boolean';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType) {\n        return 1;\n      } else if (input instanceof BooleanType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'boolean';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return BooleanType;\n}(Type);\n\nvar EmptyType = function (_Type) {\n  inherits(EmptyType, _Type);\n\n  function EmptyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, EmptyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EmptyType.__proto__ || Object.getPrototypeOf(EmptyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'EmptyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(EmptyType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return false; // empty types accepts nothing.\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof EmptyType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'empty';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return EmptyType;\n}(Type);\n\nvar ExistentialType = function (_Type) {\n  inherits(ExistentialType, _Type);\n\n  function ExistentialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExistentialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExistentialType.__proto__ || Object.getPrototypeOf(ExistentialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExistentialType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExistentialType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '*';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ExistentialType;\n}(Type);\n\n/**\n * # TypeParameterApplication\n *\n */\nvar TypeParameterApplication = function (_Type) {\n  inherits(TypeParameterApplication, _Type);\n\n  function TypeParameterApplication() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameterApplication);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameterApplication.__proto__ || Object.getPrototypeOf(TypeParameterApplication)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameterApplication', _this.typeInstances = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeParameterApplication, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var parent, typeInstances;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              parent = this.parent, typeInstances = this.typeInstances;\n              return _context.delegateYield(parent.errors.apply(parent, [validation, path, input].concat(toConsumableArray(typeInstances))), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      return parent.accepts.apply(parent, [input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var _parent;\n\n      return (_parent = this.parent).compareWith.apply(_parent, [input].concat(toConsumableArray(this.typeInstances)));\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.hasProperty === 'function') {\n        var _ref2;\n\n        return (_ref2 = inner).hasProperty.apply(_ref2, [name].concat(toConsumableArray(this.typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.getProperty === 'function') {\n        var _ref3;\n\n        return (_ref3 = inner).getProperty.apply(_ref3, [name].concat(toConsumableArray(this.typeInstances)));\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _parent2;\n\n      return (_parent2 = this.parent).unwrap.apply(_parent2, toConsumableArray(this.typeInstances));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n      var name = parent.name;\n\n      if (typeInstances.length) {\n        var items = [];\n        for (var i = 0; i < typeInstances.length; i++) {\n          var typeInstance = typeInstances[i];\n          items.push(typeInstance.toString());\n        }\n        return name + '<' + items.join(', ') + '>';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeInstances: this.typeInstances\n      };\n    }\n  }]);\n  return TypeParameterApplication;\n}(Type);\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(collectConstraintErrors);\n\n/**\n * Add constraints to the given subject type.\n */\nfunction addConstraints(subject) {\n  var _subject$constraints;\n\n  for (var _len = arguments.length, constraints = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    constraints[_key - 1] = arguments[_key];\n  }\n\n  (_subject$constraints = subject.constraints).push.apply(_subject$constraints, toConsumableArray(constraints));\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\n\n\nfunction collectConstraintErrors(subject, validation, path) {\n  for (var _len2 = arguments.length, input = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    input[_key2 - 3] = arguments[_key2];\n  }\n\n  var constraints, length, i, constraint, violation;\n  return _regeneratorRuntime.wrap(function collectConstraintErrors$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          constraints = subject.constraints;\n          length = constraints.length;\n          i = 0;\n\n        case 3:\n          if (!(i < length)) {\n            _context.next = 12;\n            break;\n          }\n\n          constraint = constraints[i];\n          violation = constraint.apply(undefined, toConsumableArray(input));\n\n          if (!(typeof violation === 'string')) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return [path, violation, this];\n\n        case 9:\n          i++;\n          _context.next = 3;\n          break;\n\n        case 12:\n        case 'end':\n          return _context.stop();\n      }\n    }\n  }, _marked, this);\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nfunction constraintsAccept(subject) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len3 = arguments.length, input = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    input[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    if (typeof constraint.apply(undefined, toConsumableArray(input)) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar TypeAlias = function (_Type) {\n  inherits(TypeAlias, _Type);\n\n  function TypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeAlias.__proto__ || Object.getPrototypeOf(TypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeAlias', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeAlias, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          type = this.type;\n\n      if (withDeclaration) {\n        return 'type ' + name + ' = ' + type.toString() + ';';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return this.type.properties;\n    }\n  }, {\n    key: 'hasConstraints',\n    get: function get$$1() {\n      return this.constraints.length > 0;\n    }\n  }]);\n  return TypeAlias;\n}(Type);\n\nvar FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\n\nvar TypeParameter = function (_Type) {\n  inherits(TypeParameter, _Type);\n\n  function TypeParameter() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  createClass(TypeParameter, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var boundOrDefault, recorded, context, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              boundOrDefault = this.bound || this.default;\n              recorded = this.recorded, context = this.context;\n\n              if (!(boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(boundOrDefault.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 7:\n              if (!recorded) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.delegateYield(recorded.errors(validation, path, input), 't1', 9);\n\n            case 9:\n              return _context.abrupt('return');\n\n            case 12:\n              if (!boundOrDefault) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType')) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 21;\n              _iterator = boundOrDefault.errors(validation, path, input)[Symbol.iterator]();\n\n            case 23:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 31;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 28;\n              return error;\n\n            case 28:\n              _iteratorNormalCompletion = true;\n              _context.next = 23;\n              break;\n\n            case 31:\n              _context.next = 37;\n              break;\n\n            case 33:\n              _context.prev = 33;\n              _context.t2 = _context['catch'](21);\n              _didIteratorError = true;\n              _iteratorError = _context.t2;\n\n            case 37:\n              _context.prev = 37;\n              _context.prev = 38;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 40:\n              _context.prev = 40;\n\n              if (!_didIteratorError) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 43:\n              return _context.finish(40);\n\n            case 44:\n              return _context.finish(37);\n\n            case 45:\n              if (!hasErrors) {\n                _context.next = 47;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 47:\n\n              this.recorded = context.typeOf(input);\n\n            case 48:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[21, 33, 37, 45], [38,, 40, 44]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n      if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        return boundOrDefault.accepts(input);\n      } else if (recorded) {\n        return recorded.accepts(input);\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n          return true;\n        } else if (!boundOrDefault.accepts(input)) {\n          return false;\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (input instanceof TypeParameter) {\n        // We don't need to check for `recorded` or `bound` fields\n        // because the input has already been unwrapped, so\n        // if we got a type parameter it must be totally generic and\n        // we treat it like Any.\n        return 1;\n      } else if (recorded) {\n        return compareTypes(recorded, input);\n      } else if (boundOrDefault) {\n        return compareTypes(boundOrDefault, input);\n      } else {\n        // A generic type parameter accepts any input.\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (recorded) {\n        return recorded.unwrap();\n      } else if (boundOrDefault) {\n        return boundOrDefault.unwrap();\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      var id = this.id,\n          bound = this.bound,\n          defaultType = this.default;\n\n      if (withBinding) {\n        if (defaultType) {\n          return id + ' = ' + defaultType.toString();\n        } else if (bound) {\n          return id + ': ' + bound.toString();\n        }\n      }\n      return id;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        bound: this.bound,\n        recorded: this.recorded\n      };\n    }\n  }]);\n  return TypeParameter;\n}(Type);\n\nfunction flowIntoTypeParameter(typeParameter) {\n  var existing = typeParameter[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  var target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  typeParameter[FlowIntoSymbol] = target;\n  return target;\n}\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\n\nvar FlowIntoType = function (_Type) {\n  inherits(FlowIntoType, _Type);\n\n  function FlowIntoType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FlowIntoType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FlowIntoType.__proto__ || Object.getPrototypeOf(FlowIntoType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FlowIntoType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FlowIntoType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var typeParameter, context, recorded, bound, hasError, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error, _hasError, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              typeParameter = this.typeParameter, context = this.context;\n              recorded = typeParameter.recorded, bound = typeParameter.bound;\n\n              if (!(bound instanceof FlowIntoType)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.delegateYield(bound.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!recorded) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!bound) {\n                _context.next = 39;\n                break;\n              }\n\n              hasError = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 11;\n              _iterator = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 13:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 21;\n                break;\n              }\n\n              error = _step.value;\n              _context.next = 17;\n              return error;\n\n            case 17:\n              hasError = true;\n\n            case 18:\n              _iteratorNormalCompletion = true;\n              _context.next = 13;\n              break;\n\n            case 21:\n              _context.next = 27;\n              break;\n\n            case 23:\n              _context.prev = 23;\n              _context.t1 = _context['catch'](11);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 27:\n              _context.prev = 27;\n              _context.prev = 28;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 30:\n              _context.prev = 30;\n\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 33:\n              return _context.finish(30);\n\n            case 34:\n              return _context.finish(27);\n\n            case 35:\n              if (!hasError) {\n                _context.next = 37;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 37:\n              _context.next = 45;\n              break;\n\n            case 39:\n              if (!recorded.accepts(input)) {\n                _context.next = 43;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 43:\n              // we need to make a union\n              typeParameter.recorded = context.union(recorded, context.typeOf(input));\n              return _context.abrupt('return');\n\n            case 45:\n              _context.next = 82;\n              break;\n\n            case 47:\n              if (!bound) {\n                _context.next = 82;\n                break;\n              }\n\n              if (!(bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType')) {\n                _context.next = 52;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 52:\n              _hasError = false;\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 56;\n              _iterator2 = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 58:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 66;\n                break;\n              }\n\n              _error = _step2.value;\n              _context.next = 62;\n              return _error;\n\n            case 62:\n              _hasError = true;\n\n            case 63:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 58;\n              break;\n\n            case 66:\n              _context.next = 72;\n              break;\n\n            case 68:\n              _context.prev = 68;\n              _context.t2 = _context['catch'](56);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t2;\n\n            case 72:\n              _context.prev = 72;\n              _context.prev = 73;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n\n            case 75:\n              _context.prev = 75;\n\n              if (!_didIteratorError2) {\n                _context.next = 78;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 78:\n              return _context.finish(75);\n\n            case 79:\n              return _context.finish(72);\n\n            case 80:\n              if (!_hasError) {\n                _context.next = 82;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 82:\n\n              typeParameter.recorded = context.typeOf(input);\n\n            case 83:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[11, 23, 27, 35], [28,, 30, 34], [56, 68, 72, 80], [73,, 75, 79]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.accepts(input);\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound && !bound.accepts(input)) {\n          return false;\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return true;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return true;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return true;\n        } else if (!bound.accepts(input)) {\n          return false;\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.compareWith(input);\n      }\n      if (recorded) {\n        if (bound && compareTypes(bound, input) === -1) {\n          return -1;\n        }\n        var result = compareTypes(recorded, input);\n        if (result === 0) {\n          // our existing type already permits this value, there's nothing to do.\n          return 0;\n        }\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, input);\n        return 1;\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return 1;\n        }\n        var _result = compareTypes(bound, input);\n        if (_result === -1) {\n          return -1;\n        }\n      }\n\n      typeParameter.recorded = input;\n      return 0;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.typeParameter.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return this.typeParameter.toString(withBinding);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.typeParameter.toJSON();\n    }\n  }]);\n  return FlowIntoType;\n}(Type);\n\nvar FunctionTypeRestParam = function (_Type) {\n  inherits(FunctionTypeRestParam, _Type);\n\n  function FunctionTypeRestParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeRestParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeRestParam.__proto__ || Object.getPrototypeOf(FunctionTypeRestParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeRestParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeRestParam, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '...' + this.name + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeRestParam;\n}(Type);\n\nvar FunctionTypeParam = function (_Type) {\n  inherits(FunctionTypeParam, _Type);\n\n  function FunctionTypeParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeParam.__proto__ || Object.getPrototypeOf(FunctionTypeParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeParam, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              optional = this.optional, type = this.type;\n\n              if (!(optional && input === undefined)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 6);\n\n            case 6:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return true;\n      } else {\n        return type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var optional = this.optional,\n          type = this.type;\n\n      return '' + this.name + (optional ? '?' : '') + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        optional: this.optional,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeParam;\n}(Type);\n\nvar FunctionTypeReturn = function (_Type) {\n  inherits(FunctionTypeReturn, _Type);\n\n  function FunctionTypeReturn() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeReturn);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeReturn.__proto__ || Object.getPrototypeOf(FunctionTypeReturn)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeReturn', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeReturn, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path.concat('[[Return Type]]'), input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeReturn) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeReturn;\n}(Type);\n\nvar ParentSymbol = Symbol('Parent');\nvar NameRegistrySymbol = Symbol('NameRegistry');\nvar ModuleRegistrySymbol = Symbol('ModuleRegistry');\nvar CurrentModuleSymbol = Symbol('CurrentModule');\nvar TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nvar InferrerSymbol = Symbol('Inferrer');\n\n\nvar TypeSymbol = Symbol('Type');\nvar TypeParametersSymbol = Symbol('TypeParameters');\nvar TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\nvar FunctionType = function (_Type) {\n  inherits(FunctionType, _Type);\n\n  function FunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var annotation, returnType, params, i, param, annotationParam, context, _i, _param;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'function')) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              annotation = input[TypeSymbol];\n              returnType = this.returnType, params = this.params;\n\n              if (!annotation) {\n                _context.next = 29;\n                break;\n              }\n\n              if (annotation.params) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i = 0;\n\n            case 10:\n              if (!(i < params.length)) {\n                _context.next = 24;\n                break;\n              }\n\n              param = params[i];\n              annotationParam = annotation.params[i];\n\n              if (!(!annotationParam && !param.optional)) {\n                _context.next = 18;\n                break;\n              }\n\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              if (param.acceptsType(annotationParam)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 21;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 21:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 24:\n              if (returnType.acceptsType(annotation.returnType)) {\n                _context.next = 27;\n                break;\n              }\n\n              _context.next = 27;\n              return [path, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()), this];\n\n            case 27:\n              _context.next = 32;\n              break;\n\n            case 29:\n              context = this.context;\n              // We cannot safely check an unannotated function.\n              // But we need to propagate `any` type feedback upwards.\n\n              for (_i = 0; _i < params.length; _i++) {\n                _param = params[_i];\n\n                _param.acceptsType(context.any());\n              }\n              returnType.acceptsType(context.any());\n\n            case 32:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var returnType = this.returnType,\n          params = this.params;\n\n      var annotation = input[TypeSymbol];\n      if (annotation) {\n        if (!annotation.params) {\n          return true;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            return false;\n          } else if (!param.acceptsType(annotationParam)) {\n            return false;\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          return false;\n        }\n        return true;\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i2 = 0; _i2 < params.length; _i2++) {\n          var _param2 = params[_i2];\n          _param2.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof FunctionType)) {\n        return -1;\n      }\n      var returnType = this.returnType;\n      var inputReturnType = input.returnType;\n      var isGreater = false;\n      var returnTypeResult = compareTypes(returnType, inputReturnType);\n      if (returnTypeResult === -1) {\n        return -1;\n      } else if (returnTypeResult === 1) {\n        isGreater = true;\n      }\n\n      var params = this.params;\n      var inputParams = input.params;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        var inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n        if (inputParam == null) {\n          return -1;\n        }\n        var result = compareTypes(param, inputParam);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n      }\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.accepts(args[i])) {\n            return false;\n          }\n        } else if (!param.accepts(undefined)) {\n          return false;\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {\n          if (!rest.accepts(args[_i3])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          param.assert(args[i]);\n        } else {\n          param.assert(undefined);\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i4 = paramsLength; _i4 < argsLength; _i4++) {\n          rest.assert(args[_i4]);\n        }\n      }\n\n      return args;\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      this.returnType.assert(input);\n      return input;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var params = this.params,\n          rest = this.rest,\n          context = this.context;\n\n      var paramsLength = params.length;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.acceptsType(args[i])) {\n            return context.empty();\n          }\n        } else if (!param.accepts(undefined)) {\n          return context.empty();\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i5 = paramsLength; _i5 < argsLength; _i5++) {\n          if (!rest.acceptsType(args[_i5])) {\n            return context.empty();\n          }\n        }\n      }\n\n      return this.returnType.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = this.params,\n          rest = this.rest,\n          returnType = this.returnType;\n\n      var args = [];\n      for (var i = 0; i < params.length; i++) {\n        args.push(params[i].toString());\n      }\n      if (rest) {\n        args.push(rest.toString());\n      }\n      return '(' + args.join(', ') + ') => ' + returnType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        params: this.params,\n        rest: this.rest,\n        returnType: this.returnType\n      };\n    }\n  }]);\n  return FunctionType;\n}(Type);\n\nvar GeneratorType = function (_Type) {\n  inherits(GeneratorType, _Type);\n\n  function GeneratorType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeneratorType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeneratorType.__proto__ || Object.getPrototypeOf(GeneratorType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GeneratorType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeneratorType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              isValid = input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n\n              if (isValid) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof GeneratorType)) {\n        var _result = compareTypes(this.yieldType, input);\n        if (_result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      var isGreater = false;\n      var result = compareTypes(this.yieldType, input.yieldType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.returnType, input.returnType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.nextType, input.nextType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsYield',\n    value: function acceptsYield(input) {\n      return this.yieldType.accepts(input);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'acceptsNext',\n    value: function acceptsNext(input) {\n      return this.nextType.accepts(input);\n    }\n  }, {\n    key: 'assertYield',\n    value: function assertYield(input) {\n      return this.yieldType.assert(input);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return this.returnType.assert(input);\n    }\n  }, {\n    key: 'assertNext',\n    value: function assertNext(input) {\n      return this.nextType.assert(input);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var yieldType = this.yieldType,\n          returnType = this.returnType,\n          nextType = this.nextType;\n\n      return 'Generator<' + yieldType.toString() + ', ' + returnType.toString() + ', ' + nextType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        yieldType: this.yieldType,\n        returnType: this.returnType,\n        nextType: this.nextType\n      };\n    }\n  }]);\n  return GeneratorType;\n}(Type);\n\nvar warnedInstances = new WeakSet();\n\nvar TypeConstructor = function (_Type) {\n  inherits(TypeConstructor, _Type);\n\n  function TypeConstructor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeConstructor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeConstructor.__proto__ || Object.getPrototypeOf(TypeConstructor)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeConstructor', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeConstructor, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement accepts().');\n        warnedInstances.add(this);\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement compareWith().');\n        warnedInstances.add(this);\n      }\n      return -1;\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }]);\n  return TypeConstructor;\n}(Type);\n\nvar GenericType = function (_TypeConstructor) {\n  inherits(GenericType, _TypeConstructor);\n\n  function GenericType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GenericType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GenericType.__proto__ || Object.getPrototypeOf(GenericType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = \"GenericType\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GenericType, [{\n    key: \"errors\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var name, impl;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              name = this.name, impl = this.impl;\n\n              if (input instanceof impl) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: \"accepts\",\n    value: function accepts(input) {\n      var impl = this.impl;\n\n      return input instanceof impl;\n    }\n  }, {\n    key: \"compareWith\",\n    value: function compareWith(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var expected = annotation.unwrap.apply(annotation, toConsumableArray(typeInstances));\n        return compareTypes(input, expected);\n      } else if (input instanceof GenericType && (input.impl === impl || impl && impl.isPrototypeOf(input.impl))) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      var context = this.context,\n          impl = this.impl;\n\n      if (typeof impl !== \"function\") {\n        return this;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation != null) {\n        return annotation.unwrap.apply(annotation, arguments);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"inferTypeParameters\",\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }]);\n  return GenericType;\n}(TypeConstructor);\n\nfunction invariant(input, message) {\n  if (!input) {\n    var error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\nvar NullLiteralType = function (_Type) {\n  inherits(NullLiteralType, _Type);\n\n  function NullLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullLiteralType.__proto__ || Object.getPrototypeOf(NullLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullLiteralType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== null)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === null;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'null';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NullLiteralType;\n}(Type);\n\nvar VoidType = function (_Type) {\n  inherits(VoidType, _Type);\n\n  function VoidType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VoidType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VoidType.__proto__ || Object.getPrototypeOf(VoidType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VoidType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VoidType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== undefined)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === undefined;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof VoidType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'void';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return VoidType;\n}(Type);\n\nvar NullableType = function (_Type) {\n  inherits(NullableType, _Type);\n\n  function NullableType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullableType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullableType.__proto__ || Object.getPrototypeOf(NullableType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullableType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullableType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input != null)) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input == null) {\n        return true;\n      } else {\n        return this.type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType || input instanceof VoidType) {\n        return 1;\n      } else if (input instanceof NullableType) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '? ' + this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return NullableType;\n}(Type);\n\nvar ObjectTypeProperty = function (_Type) {\n  inherits(ObjectTypeProperty, _Type);\n\n  function ObjectTypeProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeProperty.__proto__ || Object.getPrototypeOf(ObjectTypeProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeProperty', _this['static'] = false, _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeProperty, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n\n    /**\n     * Determine whether the property is nullable.\n     */\n\n  }, {\n    key: 'isNullable',\n    value: function isNullable() {\n      return this.value instanceof NullableType;\n    }\n\n    /**\n     * Determine whether the property exists on the given input or its prototype chain.\n     */\n\n  }, {\n    key: 'existsOn',\n    value: function existsOn(input) {\n      // Ignore\n      var key = this.key,\n          isStatic = this.static;\n\n      return key in (isStatic ? input.constructor : input) === true;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, key, value, isStatic, target, targetPath, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              optional = this.optional, key = this.key, value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 18;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 14;\n                break;\n              }\n\n              if (optional) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 13;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 13:\n              return _context.abrupt('return');\n\n            case 14:\n              targetPath.push(key);\n              target = input.constructor[key];\n              _context.next = 20;\n              break;\n\n            case 18:\n              target = input[key];\n              targetPath = path.concat(key);\n\n            case 20:\n              if (!(optional && target === undefined)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 22:\n              if (!(this.isNullable() && !this.existsOn(input))) {\n                _context.next = 26;\n                break;\n              }\n\n              _context.next = 25;\n              return [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n\n            case 25:\n              return _context.abrupt('return');\n\n            case 26:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 30;\n              _iterator = value.errors(validation, targetPath, target)[Symbol.iterator]();\n\n            case 32:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 40;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 37;\n              return error;\n\n            case 37:\n              _iteratorNormalCompletion = true;\n              _context.next = 32;\n              break;\n\n            case 40:\n              _context.next = 46;\n              break;\n\n            case 42:\n              _context.prev = 42;\n              _context.t0 = _context['catch'](30);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 46:\n              _context.prev = 46;\n              _context.prev = 47;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 49:\n              _context.prev = 49;\n\n              if (!_didIteratorError) {\n                _context.next = 52;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 52:\n              return _context.finish(49);\n\n            case 53:\n              return _context.finish(46);\n\n            case 54:\n              if (hasErrors) {\n                _context.next = 56;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, targetPath, target), 't1', 56);\n\n            case 56:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[30, 42, 46, 54], [47,, 49, 53]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return optional ? true : false;\n        }\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n      }\n\n      if (optional && target === undefined) {\n        return true;\n      }\n\n      if (this.isNullable() && !this.existsOn(input)) {\n        return false;\n      }\n\n      if (!value.accepts(target)) {\n        return false;\n      } else {\n        return constraintsAccept(this, target);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeProperty)) {\n        return -1;\n      } else if (input.key !== this.key) {\n        return -1;\n      } else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var key = this.key;\n      // Issue 252\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol') {\n        key = '[' + key.toString() + ']';\n      }\n      if (this.static) {\n        return 'static ' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      } else {\n        return '' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        key: this.key,\n        value: this.value,\n        optional: this.optional\n      };\n    }\n  }]);\n  return ObjectTypeProperty;\n}(Type);\n\nvar ObjectTypeIndexer = function (_Type) {\n  inherits(ObjectTypeIndexer, _Type);\n\n  function ObjectTypeIndexer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeIndexer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeIndexer.__proto__ || Object.getPrototypeOf(ObjectTypeIndexer)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeIndexer', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectTypeIndexer, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, key, value) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // special case number types\n              if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n                key = +key;\n              }\n\n              return _context.delegateYield(this.key.errors(validation, path.concat('[[Key]]'), key), 't0', 2);\n\n            case 2:\n              return _context.delegateYield(this.value.errors(validation, path.concat(key), value), 't1', 3);\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'acceptsKey',\n    value: function acceptsKey(key) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n      return this.key.accepts(key);\n    }\n  }, {\n    key: 'acceptsValue',\n    value: function acceptsValue(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ObjectTypeProperty) {\n        if (!this.key.accepts(input.key)) {\n          return -1;\n        } else {\n          return compareTypes(this.value, input.value);\n        }\n      } else if (!(input instanceof ObjectTypeIndexer)) {\n        return -1;\n      }\n\n      var keyResult = compareTypes(this.key, input.key);\n      if (keyResult === -1) {\n        return -1;\n      }\n      var valueResult = compareTypes(this.value, input.value);\n      if (valueResult === -1) {\n        return -1;\n      }\n\n      if (keyResult === 0 && valueResult === 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.id + ': ' + this.key.toString() + ']: ' + this.value.toString() + ';';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        key: this.key,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeIndexer;\n}(Type);\n\nvar ObjectTypeCallProperty = function (_Type) {\n  inherits(ObjectTypeCallProperty, _Type);\n\n  function ObjectTypeCallProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeCallProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeCallProperty.__proto__ || Object.getPrototypeOf(ObjectTypeCallProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeCallProperty', _this['static'] = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeCallProperty, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value, isStatic, target, targetPath;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 16;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 12;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 12:\n              return _context.abrupt('return');\n\n            case 13:\n              target = input.constructor;\n              _context.next = 18;\n              break;\n\n            case 16:\n              target = input;\n              targetPath = path;\n\n            case 18:\n              return _context.delegateYield(value.errors(validation, targetPath, target), 't0', 19);\n\n            case 19:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return false;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n      }\n      return value.accepts(target);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeCallProperty)) {\n        return -1;\n      }\n      return compareTypes(this.value, input.value);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.static) {\n        return 'static ' + this.value.toString() + ';';\n      } else {\n        return this.value.toString();\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeCallProperty;\n}(Type);\n\nvar Declaration = function (_Type) {\n  inherits(Declaration, _Type);\n\n  function Declaration() {\n    classCallCheck(this, Declaration);\n    return possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).apply(this, arguments));\n  }\n\n  return Declaration;\n}(Type);\n\nvar VarDeclaration = function (_Declaration) {\n  inherits(VarDeclaration, _Declaration);\n\n  function VarDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VarDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VarDeclaration.__proto__ || Object.getPrototypeOf(VarDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VarDeclaration', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VarDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare var ' + this.name + ': ' + this.type.toString() + ';';\n    }\n  }]);\n  return VarDeclaration;\n}(Declaration);\n\nvar TypeDeclaration = function (_Declaration) {\n  inherits(TypeDeclaration, _Declaration);\n\n  function TypeDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeDeclaration.__proto__ || Object.getPrototypeOf(TypeDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      var _typeAlias;\n\n      (_typeAlias = this.typeAlias).addConstraint.apply(_typeAlias, arguments);\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.typeAlias.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _typeAlias2;\n\n      return (_typeAlias2 = this.typeAlias).apply.apply(_typeAlias2, arguments);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.typeAlias.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.typeAlias, input);\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var _typeAlias3;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_typeAlias3 = this.typeAlias).hasProperty.apply(_typeAlias3, [name].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var _typeAlias4;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_typeAlias4 = this.typeAlias).getProperty.apply(_typeAlias4, [name].concat(toConsumableArray(typeInstances)));\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _typeAlias5;\n\n      return (_typeAlias5 = this.typeAlias).unwrap.apply(_typeAlias5, arguments);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare ' + this.typeAlias.toString(true) + ';';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return this.typeAlias.type;\n    }\n  }]);\n  return TypeDeclaration;\n}(Declaration);\n\nvar ModuleDeclaration = function (_Declaration) {\n  inherits(ModuleDeclaration, _Declaration);\n\n  function ModuleDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleDeclaration.__proto__ || Object.getPrototypeOf(ModuleDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleDeclaration, [{\n    key: 'get',\n    value: function get$$1(name) {\n      var moduleExports = this.moduleExports;\n\n      if (moduleExports) {\n        var exporting = moduleExports.unwrap();\n        if (typeof exporting.getProperty === 'function') {\n          var prop = exporting.getProperty(name);\n          if (prop) {\n            return prop.unwrap();\n          }\n        }\n      } else {\n        var declaration = this.declarations[name];\n        if (declaration) {\n          return declaration.unwrap();\n        }\n      }\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      if (/^\\.\\//.test(moduleName)) {\n        moduleName = '' + this.name + moduleName.slice(1);\n      }\n      return this.innerContext.import(moduleName);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var name = this.name,\n          declarations = this.declarations,\n          modules = this.modules,\n          moduleExports = this.moduleExports;\n\n      var body = [];\n      for (var _name in declarations) {\n        // eslint-disable-line guard-for-in\n        var declaration = declarations[_name];\n        body.push(declaration.toString(true));\n      }\n      if (modules) {\n        for (var _name2 in modules) {\n          // eslint-disable-line guard-for-in\n          var module = modules[_name2];\n          body.push(module.toString());\n        }\n      }\n      if (moduleExports) {\n        body.push(moduleExports.toString());\n      }\n      return 'declare module \"' + name + '\" {\\n' + indent$1(body.join('\\n\\n')) + '}';\n    }\n  }, {\n    key: 'moduleType',\n    get: function get$$1() {\n      if (this.moduleExports) {\n        return 'commonjs';\n      } else {\n        return 'es6';\n      }\n    }\n  }, {\n    key: 'isCommonJS',\n    get: function get$$1() {\n      return this.moduleExports ? true : false;\n    }\n  }, {\n    key: 'isES6',\n    get: function get$$1() {\n      return this.moduleExports ? false : true;\n    }\n  }, {\n    key: 'declarations',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[NameRegistrySymbol];\n    }\n  }, {\n    key: 'modules',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[ModuleRegistrySymbol];\n    }\n  }]);\n  return ModuleDeclaration;\n}(Declaration);\n\nfunction indent$1(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar ModuleExports = function (_Declaration) {\n  inherits(ModuleExports, _Declaration);\n\n  function ModuleExports() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleExports);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleExports.__proto__ || Object.getPrototypeOf(ModuleExports)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleExports', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleExports, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare module.exports: ' + this.type.toString() + ';';\n    }\n  }]);\n  return ModuleExports;\n}(Declaration);\n\nvar ClassDeclaration = function (_Declaration) {\n  inherits(ClassDeclaration, _Declaration);\n\n  function ClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassDeclaration.__proto__ || Object.getPrototypeOf(ClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassDeclaration, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var body, superClass, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref2, _ref3, errorPath, errorMessage, expectedType, propertyName;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              body = this.body;\n              superClass = this.superClass && this.superClass.unwrap();\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n\n            case 5:\n              return _context.abrupt('return');\n\n            case 6:\n              if (!superClass) {\n                _context.next = 42;\n                break;\n              }\n\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = superClass.errors(validation, path, input)[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 28;\n                break;\n              }\n\n              _ref2 = _step.value;\n              _ref3 = slicedToArray(_ref2, 3);\n              errorPath = _ref3[0];\n              errorMessage = _ref3[1];\n              expectedType = _ref3[2];\n              propertyName = errorPath[path.length];\n\n              if (!body.getProperty(propertyName)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt('continue', 25);\n\n            case 23:\n              _context.next = 25;\n              return [errorPath, errorMessage, expectedType];\n\n            case 25:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 28:\n              _context.next = 34;\n              break;\n\n            case 30:\n              _context.prev = 30;\n              _context.t0 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 34:\n              _context.prev = 34;\n              _context.prev = 35;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 37:\n              _context.prev = 37;\n\n              if (!_didIteratorError) {\n                _context.next = 40;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 40:\n              return _context.finish(37);\n\n            case 41:\n              return _context.finish(34);\n\n            case 42:\n              return _context.delegateYield(body.errors(validation, path, input), 't1', 43);\n\n            case 43:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 30, 34, 42], [35,, 37, 41]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      } else if (superClass && !superClass.accepts(input)) {\n        return false;\n      } else if (!body.accepts(input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ClassDeclaration) {\n        if (input === this) {\n          return 0;\n        } else if (this.isSuperClassOf(input)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      return compareTypes(this.body, input);\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      var prop = body.getProperty(key);\n      if (prop) {\n        return prop;\n      } else if (superClass && typeof superClass.getProperty === 'function') {\n        return superClass.getProperty(key);\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (body.hasProperty(key)) {\n        return true;\n      } else if (superClass && typeof superClass.hasProperty === 'function') {\n        return superClass.hasProperty(key);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine whether this class declaration represents a super class of\n     * the given type.\n     */\n\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      var body = this.body,\n          shapeID = this.shapeID;\n\n      var current = candidate;\n\n      while (current != null) {\n        if (current === this || current === body || current.shapeID === shapeID) {\n          return true;\n        }\n        if (current instanceof ClassDeclaration) {\n          current = current.superClass;\n        } else {\n          current = current.unwrap();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          superClass = this.superClass,\n          body = this.body;\n\n      if (withDeclaration) {\n        var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n        return 'declare class ' + name + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (superClass == null) {\n        return body.properties;\n      }\n      var bodyProps = body.properties;\n      var superProps = superClass.unwrap().properties;\n      if (superProps == null) {\n        return bodyProps;\n      }\n      var seen = {};\n      var seenStatic = {};\n      var props = [];\n      for (var i = 0; i < superProps.length; i++) {\n        var prop = superProps[i];\n        props.push(prop);\n        if (prop.static) {\n          seenStatic[prop.key] = i;\n        } else {\n          seen[prop.key] = i;\n        }\n      }\n      for (var _i = 0; _i < bodyProps.length; _i++) {\n        var _prop = bodyProps[_i];\n        if (seen[_prop.key]) {\n          props[_i] = _prop;\n        } else {\n          props.push(_prop);\n        }\n      }\n      return props;\n    }\n  }]);\n  return ClassDeclaration;\n}(Declaration);\n\nvar PartialType = function (_Type) {\n  inherits(PartialType, _Type);\n\n  function PartialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, PartialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PartialType.__proto__ || Object.getPrototypeOf(PartialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'PartialType', _this.typeParameters = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(PartialType, [{\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this.context);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      this.typeParameters.push(target);\n      return target;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var constraints, type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              constraints = this.constraints, type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (!(!hasErrors && constraints)) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (constraints && !constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(expand) {\n      var type = this.type;\n\n      return type.toString(expand);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeParameters: this.typeParameters,\n        type: this.type\n      };\n    }\n  }]);\n  return PartialType;\n}(Type);\n\nvar ParameterizedClassDeclaration = function (_Declaration) {\n  inherits(ParameterizedClassDeclaration, _Declaration);\n\n  function ParameterizedClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedClassDeclaration.__proto__ || Object.getPrototypeOf(ParameterizedClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedClassDeclaration, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return getPartial(this).compareWith(input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).type;\n    }\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      return getPartial(this).type.isSuperClassOf(candidate);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len5 = arguments.length, typeInstances = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeInstances[_key5] = arguments[_key5];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      if (!withDeclaration) {\n        return this.name;\n      }\n      var partial = getPartial(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return partial.toString(true);\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      var superClass = type.superClass,\n          body = type.body;\n\n      var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n      return 'declare class ' + this.name + '<' + items.join(', ') + '>' + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getPartial(this).toJSON();\n    }\n  }, {\n    key: 'superClass',\n    get: function get$$1() {\n      return getPartial(this).type.superClass;\n    }\n  }, {\n    key: 'body',\n    get: function get$$1() {\n      return getPartial(this).type.body;\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial(this).type.properties;\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial(this).typeParameters;\n    }\n  }]);\n  return ParameterizedClassDeclaration;\n}(Declaration);\n\nfunction getPartial(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class.apply(context, [parent.name].concat(toConsumableArray(body)));\n  } else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  partial.type.shapeID = parent.shapeID;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len6 = arguments.length, typeInstances = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    typeInstances[_key6 - 1] = arguments[_key6];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ExtendsDeclaration = function (_Declaration) {\n  inherits(ExtendsDeclaration, _Declaration);\n\n  function ExtendsDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExtendsDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExtendsDeclaration.__proto__ || Object.getPrototypeOf(ExtendsDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExtendsDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExtendsDeclaration, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var type = this.type;\n\n      if (withDeclaration) {\n        return 'extends ' + type.toString();\n      } else {\n        return type.toString();\n      }\n    }\n  }]);\n  return ExtendsDeclaration;\n}(Declaration);\n\nvar _marked$1 = /*#__PURE__*/_regeneratorRuntime.mark(collectErrorsWithIndexers);\nvar _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(collectErrorsWithoutIndexers);\nvar _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(collectErrorsExact);\n\nvar ObjectType = function (_Type) {\n  inherits(ObjectType, _Type);\n\n  function ObjectType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectType, [{\n    key: 'getProperty',\n\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n    value: function getProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return property;\n        }\n      }\n      return this.getIndexer(key);\n    }\n  }, {\n    key: 'setProperty',\n    value: function setProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var context = this.context,\n          properties = this.properties;\n      var length = properties.length;\n\n      var newProp = new ObjectTypeProperty(context);\n      newProp.key = key;\n      newProp.value = value;\n      newProp.optional = optional;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          properties[i] = newProp;\n          return;\n        }\n      }\n      properties.push(newProp);\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return true;\n        }\n      }\n      return this.hasIndexer(key);\n    }\n\n    /**\n     * Get an indexer with which matches the given key type.\n     */\n\n  }, {\n    key: 'getIndexer',\n    value: function getIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return indexer;\n        }\n      }\n    }\n\n    /**\n     * Determine whether an indexer exists which matches the given key type.\n     */\n\n  }, {\n    key: 'hasIndexer',\n    value: function hasIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var hasCallProperties;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input === null)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              hasCallProperties = this.callProperties.length > 0;\n\n              if (!hasCallProperties) {\n                _context.next = 11;\n                break;\n              }\n\n              if (acceptsCallProperties(this, input)) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 9;\n              return [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n\n            case 9:\n              _context.next = 15;\n              break;\n\n            case 11:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object')) {\n                _context.next = 15;\n                break;\n              }\n\n              _context.next = 14;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 14:\n              return _context.abrupt('return');\n\n            case 15:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              validation.startCycle(this, input);\n\n              if (!(this.indexers.length > 0)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsWithIndexers(this, validation, path, input), 't0', 20);\n\n            case 20:\n              _context.next = 23;\n              break;\n\n            case 22:\n              return _context.delegateYield(collectErrorsWithoutIndexers(this, validation, path, input), 't1', 23);\n\n            case 23:\n              if (!this.exact) {\n                _context.next = 25;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsExact(this, validation, path, input), 't2', 25);\n\n            case 25:\n              validation.endCycle(this, input);\n\n            case 26:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input === null) {\n        return false;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          return false;\n        }\n      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = acceptsWithIndexers(this, input);\n      } else {\n        result = acceptsWithoutIndexers(this, input);\n      }\n      if (result && this.exact) {\n        result = acceptsExact(this, input);\n      }\n      endValidationCycle(this, input);\n      return result;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n        return -1;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      var isGreater = false;\n      if (hasCallProperties) {\n        var _result = compareTypeCallProperties(this, input);\n        if (_result === -1) {\n          return -1;\n        } else if (_result === 1) {\n          isGreater = true;\n        }\n      }\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = compareTypeWithIndexers(this, input);\n      } else {\n        result = compareTypeWithoutIndexers(this, input);\n      }\n\n      if (result === -1) {\n        return -1;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var callProperties = this.callProperties,\n          properties = this.properties,\n          indexers = this.indexers;\n\n      if (inToStringCycle(this)) {\n        return '$Cycle<Object>';\n      }\n      startToStringCycle(this);\n      var body = [];\n      for (var i = 0; i < callProperties.length; i++) {\n        body.push(callProperties[i].toString());\n      }\n      for (var _i = 0; _i < properties.length; _i++) {\n        body.push(properties[_i].toString());\n      }\n      for (var _i2 = 0; _i2 < indexers.length; _i2++) {\n        body.push(indexers[_i2].toString());\n      }\n      endToStringCycle(this);\n      if (this.exact) {\n        return '{|\\n' + indent(body.join('\\n')) + '\\n|}';\n      } else {\n        return '{\\n' + indent(body.join('\\n')) + '\\n}';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        callProperties: this.callProperties,\n        properties: this.properties,\n        indexers: this.indexers,\n        exact: this.exact\n      };\n    }\n  }]);\n  return ObjectType;\n}(Type);\n\nfunction acceptsCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareTypeCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  var inputCallProperties = input.callProperties;\n  var identicalCount = 0;\n  loop: for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n\n    for (var j = 0; j < inputCallProperties.length; j++) {\n      var inputCallProperty = inputCallProperties[j];\n      var result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      } else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers(type, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i3 = 0; _i3 < indexers.length; _i3++) {\n      var indexer = indexers[_i3];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers(type, input) {\n  var indexers = type.indexers,\n      properties = type.properties;\n\n  var inputIndexers = input.indexers;\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {\n    var indexer = indexers[_i4];\n    for (var _j = 0; _j < inputIndexers.length; _j++) {\n      var inputIndexer = inputIndexers[_j];\n      var _result2 = compareTypes(indexer, inputIndexer);\n      if (_result2 === 1) {\n        isGreater = true;\n        continue loop;\n      } else if (_result2 === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction acceptsWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact(type, input) {\n  var properties = type.properties;\n\n  var _loop = function _loop(key) {\n    // eslint-disable-line guard-for-in\n    if (!properties.some(function (property) {\n      return property.key === key;\n    })) {\n      return {\n        v: false\n      };\n    }\n  };\n\n  for (var key in input) {\n    var _ret2 = _loop(key);\n\n    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction collectErrorsWithIndexers(type, validation, path, input) {\n  var properties, indexers, seen, i, property, key, value, _i5, indexer;\n\n  return _regeneratorRuntime.wrap(function collectErrorsWithIndexers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          properties = type.properties, indexers = type.indexers;\n          seen = [];\n          i = 0;\n\n        case 3:\n          if (!(i < properties.length)) {\n            _context2.next = 10;\n            break;\n          }\n\n          property = properties[i];\n          return _context2.delegateYield(property.errors(validation, path, input), 't0', 6);\n\n        case 6:\n          seen.push(property.key);\n\n        case 7:\n          i++;\n          _context2.next = 3;\n          break;\n\n        case 10:\n          _context2.t1 = _regeneratorRuntime.keys(input);\n\n        case 11:\n          if ((_context2.t2 = _context2.t1()).done) {\n            _context2.next = 28;\n            break;\n          }\n\n          key = _context2.t2.value;\n\n          if (!(seen.indexOf(key) !== -1)) {\n            _context2.next = 15;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 15:\n          value = input[key];\n          _i5 = 0;\n\n        case 17:\n          if (!(_i5 < indexers.length)) {\n            _context2.next = 24;\n            break;\n          }\n\n          indexer = indexers[_i5];\n\n          if (!(indexer.acceptsKey(key) && indexer.acceptsValue(value))) {\n            _context2.next = 21;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 21:\n          _i5++;\n          _context2.next = 17;\n          break;\n\n        case 24:\n          _context2.next = 26;\n          return [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n\n        case 26:\n          _context2.next = 11;\n          break;\n\n        case 28:\n        case 'end':\n          return _context2.stop();\n      }\n    }\n  }, _marked$1, this);\n}\n\nfunction collectErrorsWithoutIndexers(type, validation, path, input) {\n  var properties, i, property;\n  return _regeneratorRuntime.wrap(function collectErrorsWithoutIndexers$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          properties = type.properties;\n          i = 0;\n\n        case 2:\n          if (!(i < properties.length)) {\n            _context3.next = 8;\n            break;\n          }\n\n          property = properties[i];\n          return _context3.delegateYield(property.errors(validation, path, input), 't0', 5);\n\n        case 5:\n          i++;\n          _context3.next = 2;\n          break;\n\n        case 8:\n        case 'end':\n          return _context3.stop();\n      }\n    }\n  }, _marked2, this);\n}\n\nfunction collectErrorsExact(type, validation, path, input) {\n  var _this2 = this;\n\n  var properties, _loop2, key;\n\n  return _regeneratorRuntime.wrap(function collectErrorsExact$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          properties = type.properties;\n          _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2(key) {\n            return _regeneratorRuntime.wrap(function _loop2$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    if (properties.some(function (property) {\n                      return property.key === key;\n                    })) {\n                      _context4.next = 3;\n                      break;\n                    }\n\n                    _context4.next = 3;\n                    return [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n\n                  case 3:\n                  case 'end':\n                    return _context4.stop();\n                }\n              }\n            }, _loop2, _this2);\n          });\n          _context5.t0 = _regeneratorRuntime.keys(input);\n\n        case 3:\n          if ((_context5.t1 = _context5.t0()).done) {\n            _context5.next = 8;\n            break;\n          }\n\n          key = _context5.t1.value;\n          return _context5.delegateYield(_loop2(key), 't2', 6);\n\n        case 6:\n          _context5.next = 3;\n          break;\n\n        case 8:\n        case 'end':\n          return _context5.stop();\n      }\n    }\n  }, _marked3, this);\n}\n\nfunction indent(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar IntersectionType = function (_Type) {\n  inherits(IntersectionType, _Type);\n\n  function IntersectionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, IntersectionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IntersectionType.__proto__ || Object.getPrototypeOf(IntersectionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'IntersectionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(IntersectionType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 8;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path, input), 't0', 5);\n\n            case 5:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = length - 1; i >= 0; i--) {\n        var type = types[i];\n        if (typeof type.getProperty === 'function') {\n          var prop = type.getProperty(key);\n          if (prop) {\n            return prop;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      var identicalCount = 0;\n      if (input instanceof IntersectionType) {\n        var inputTypes = input.types;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n        return identicalCount === types.length ? 0 : 1;\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          var _result = compareTypes(_type, input);\n          if (_result === -1) {\n            return -1;\n          } else if (_result === 0) {\n            identicalCount++;\n          }\n        }\n        return identicalCount === types.length ? 0 : 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _ref2;\n\n      var callProperties = [];\n      var properties = [];\n      var indexers = [];\n      var types = this.types,\n          context = this.context;\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        invariant(type instanceof ObjectType, 'Can only intersect object types');\n        callProperties.push.apply(callProperties, toConsumableArray(type.callProperties));\n        indexers.push.apply(indexers, toConsumableArray(type.indexers));\n        mergeProperties(properties, type.properties);\n      }\n      return (_ref2 = context).object.apply(_ref2, callProperties.concat(properties, indexers));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.types.join(' & ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return IntersectionType;\n}(Type);\n\nfunction getPropertyIndex(name, properties) {\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    var typeProp = source[i];\n    var index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    } else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\nvar MixedType = function (_Type) {\n  inherits(MixedType, _Type);\n\n  function MixedType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, MixedType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MixedType.__proto__ || Object.getPrototypeOf(MixedType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'MixedType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(MixedType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'mixed';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return MixedType;\n}(Type);\n\nvar NumericLiteralType = function (_Type) {\n  inherits(NumericLiteralType, _Type);\n\n  function NumericLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumericLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumericLiteralType.__proto__ || Object.getPrototypeOf(NumericLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumericLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumericLiteralType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumericLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '' + this.value;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return NumericLiteralType;\n}(Type);\n\nvar NumberType = function (_Type) {\n  inherits(NumberType, _Type);\n\n  function NumberType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumberType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumberType.__proto__ || Object.getPrototypeOf(NumberType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumberType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumberType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'number')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'number';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumberType) {\n        return 0;\n      } else if (input instanceof NumericLiteralType) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'number';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NumberType;\n}(Type);\n\nvar ParameterizedTypeAlias = function (_TypeAlias) {\n  inherits(ParameterizedTypeAlias, _TypeAlias);\n\n  function ParameterizedTypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedTypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedTypeAlias.__proto__ || Object.getPrototypeOf(ParameterizedTypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedTypeAlias', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedTypeAlias, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      var partial = getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances)));\n      if (!partial.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(getPartial$1(this), input);\n      }\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        typeInstances[_key5 - 1] = arguments[_key5];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len6 = arguments.length, typeInstances = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeInstances[_key6] = arguments[_key6];\n      }\n\n      return getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var partial = getPartial$1(this);\n      var typeParameters = partial.typeParameters;\n\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n\n      var name = this.name;\n\n      var identifier = typeParameters.length > 0 ? name + '<' + items.join(', ') + '>' : name;\n\n      if (withDeclaration) {\n        return 'type ' + identifier + ' = ' + partial.toString() + ';';\n      } else {\n        return identifier;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$1(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial$1(this).type.properties;\n    }\n  }]);\n  return ParameterizedTypeAlias;\n}(TypeAlias);\n\nfunction getPartial$1(parent) {\n  var typeCreator = parent.typeCreator,\n      context = parent.context,\n      name = parent.name;\n\n  var partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len7 = arguments.length, typeInstances = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    typeInstances[_key7 - 1] = arguments[_key7];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ParameterizedFunctionType = function (_Type) {\n  inherits(ParameterizedFunctionType, _Type);\n\n  function ParameterizedFunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedFunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedFunctionType.__proto__ || Object.getPrototypeOf(ParameterizedFunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedFunctionType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedFunctionType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getPartial$2(this), input);\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var _getPartial$type;\n\n      return (_getPartial$type = getPartial$2(this).type).acceptsParams.apply(_getPartial$type, arguments);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return getPartial$2(this).type.acceptsReturn(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var _getPartial$type2;\n\n      return (_getPartial$type2 = getPartial$2(this).type).assertParams.apply(_getPartial$type2, arguments);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return getPartial$2(this).type.assertReturn(input);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var partial = getPartial$2(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return type.toString();\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      return '<' + items.join(', ') + '> ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$2(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial$2(this).typeParameters;\n    }\n  }, {\n    key: 'params',\n    get: function get$$1() {\n      return getPartial$2(this).type.params;\n    }\n  }, {\n    key: 'rest',\n    get: function get$$1() {\n      return getPartial$2(this).type.rest;\n    }\n  }, {\n    key: 'returnType',\n    get: function get$$1() {\n      return getPartial$2(this).type.returnType;\n    }\n  }]);\n  return ParameterizedFunctionType;\n}(Type);\n\nfunction getPartial$2(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  partial.type = context.function.apply(context, toConsumableArray(body));\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    typeInstances[_key5 - 1] = arguments[_key5];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar RefinementType = function (_Type) {\n  inherits(RefinementType, _Type);\n\n  function RefinementType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RefinementType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RefinementType.__proto__ || Object.getPrototypeOf(RefinementType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'RefinementType', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(RefinementType, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '$Refinment<' + type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return RefinementType;\n}(Type);\n\nvar StringLiteralType = function (_Type) {\n  inherits(StringLiteralType, _Type);\n\n  function StringLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringLiteralType.__proto__ || Object.getPrototypeOf(StringLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringLiteralType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return StringLiteralType;\n}(Type);\n\nvar StringType = function (_Type) {\n  inherits(StringType, _Type);\n\n  function StringType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringType.__proto__ || Object.getPrototypeOf(StringType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'string')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'string';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType) {\n        return 1;\n      } else if (input instanceof StringType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return StringType;\n}(Type);\n\nvar SymbolLiteralType = function (_Type) {\n  inherits(SymbolLiteralType, _Type);\n\n  function SymbolLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolLiteralType.__proto__ || Object.getPrototypeOf(SymbolLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolLiteralType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'typeof ' + String(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return SymbolLiteralType;\n}(Type);\n\nvar SymbolType = function (_Type) {\n  inherits(SymbolType, _Type);\n\n  function SymbolType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolType.__proto__ || Object.getPrototypeOf(SymbolType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'symbol')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType) {\n        return 1;\n      } else if (input instanceof SymbolType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Symbol';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return SymbolType;\n}(Type);\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\n\nvar ThisType = function (_Type) {\n  inherits(ThisType, _Type);\n\n  function ThisType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ThisType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ThisType.__proto__ || Object.getPrototypeOf(ThisType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ThisType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ThisType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var recorded;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              recorded = this.recorded;\n\n              if (!(input === recorded)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              if (!(typeof recorded === 'function' && input instanceof recorded)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              if (!(recorded != null)) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return true;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return true;\n      } else if (recorded != null) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ThisType)) {\n        return -1;\n      } else if (input.recorded && this.recorded) {\n        return input.recorded === this.recorded ? 0 : -1;\n      } else if (this.recorded) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return 'this';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ThisType;\n}(Type);\n\nvar warnedInstances$1 = new WeakSet();\n\nvar TypeBox = function (_Type) {\n  inherits(TypeBox, _Type);\n\n  function TypeBox() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeBox);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeBox.__proto__ || Object.getPrototypeOf(TypeBox)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeBox', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeBox, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this.type;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.type.toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      return this.type.name;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var reveal = this.reveal;\n\n      var type = reveal();\n      if (!type) {\n        if (!warnedInstances$1.has(this)) {\n          this.context.emitWarningMessage('Failed to reveal boxed type.');\n          warnedInstances$1.add(this);\n        }\n        return this.context.mixed();\n      } else if (!(type instanceof Type)) {\n        // we got a boxed reference to something like a class\n        return this.context.ref(type);\n      }\n      return type;\n    }\n  }]);\n  return TypeBox;\n}(Type);\n\nvar warnedMissing = {};\n\nvar TypeReference = function (_Type) {\n  inherits(TypeReference, _Type);\n\n  function TypeReference() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeReference);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeReference.__proto__ || Object.getPrototypeOf(TypeReference)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeReference', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeReference, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var context = this.context,\n          name = this.name;\n\n      var type = context.get(name);\n      if (!type) {\n        if (!warnedMissing[name]) {\n          context.emitWarningMessage('Cannot resolve type: ' + name);\n          warnedMissing[name] = true;\n        }\n        return context.any();\n      }\n      return type;\n    }\n  }]);\n  return TypeReference;\n}(Type);\n\nvar warnedInstances$2 = new WeakSet();\n\nvar RevealedName = Symbol('RevealedName');\nvar RevealedValue = Symbol('RevealedValue');\n\nvar TypeTDZ = function (_Type) {\n  inherits(TypeTDZ, _Type);\n\n  function TypeTDZ() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeTDZ);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeTDZ.__proto__ || Object.getPrototypeOf(TypeTDZ)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeTDZ', _this[RevealedName] = undefined, _this[RevealedValue] = undefined, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeTDZ, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getRevealed(this).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return getRevealed(this).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getRevealed(this), input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = getRevealed(this);\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return getRevealed(this).unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return getRevealed(this).toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getRevealed(this).toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      var name = this[RevealedName];\n      if (!name) {\n        name = getRevealed(this).name;\n      }\n      return name;\n    },\n    set: function set$$1(value) {\n      this[RevealedName] = value;\n    }\n  }]);\n  return TypeTDZ;\n}(Type);\n\nfunction getRevealed(container) {\n  var existing = container[RevealedValue];\n  if (existing) {\n    return existing;\n  } else {\n    var reveal = container.reveal;\n\n    var type = reveal();\n    if (!type) {\n      if (!warnedInstances$2.has(container)) {\n        var name = container[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage('Failed to reveal type called \"' + name + '\" in Temporal Dead Zone.');\n        } else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances$2.add(container);\n      }\n      return container.context.mixed();\n    } else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\nvar UnionType = function (_Type) {\n  inherits(UnionType, _Type);\n\n  function UnionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, UnionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnionType.__proto__ || Object.getPrototypeOf(UnionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'UnionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(UnionType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 10;\n                break;\n              }\n\n              type = types[i];\n\n              if (!type.accepts(input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 10:\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      if (input instanceof UnionType) {\n        var inputTypes = input.types;\n        var identicalCount = 0;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n\n        if (identicalCount === types.length) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          if (compareTypes(_type, input) >= 0) {\n            return 1;\n          }\n        }\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var types = this.types;\n\n      var normalized = new Array(types.length);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n          normalized[i] = '(' + type.toString() + ')';\n        } else {\n          normalized[i] = type.toString();\n        }\n      }\n      return normalized.join(' | ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return UnionType;\n}(Type);\n\nfunction registerPrimitiveTypes(t) {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\nfunction registerBuiltinTypeConstructors(t) {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    errors: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (input instanceof Date) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n\n            case 3:\n              _context.next = 8;\n              break;\n\n            case 5:\n              if (!isNaN(input.getTime())) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return [path, getErrorMessage('ERR_INVALID_DATE'), this];\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith: function compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    errors: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input, futureType) {\n      var context;\n      return _regeneratorRuntime.wrap(function errors$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              invariant(futureType, 'Must specify type parameter for Promise.');\n              context = this.context;\n\n              if (context.checkPredicate('Promise', input)) {\n                _context2.next = 5;\n                break;\n              }\n\n              _context2.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n\n            case 5:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      var context = this.context;\n\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith: function compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    errors: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input, keyType, valueType) {\n      var context, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref, _ref2, key, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              invariant(keyType, 'Must specify two type parameters for Map.');\n              invariant(valueType, 'Must specify two type parameters for Map.');\n              context = this.context;\n\n              if (context.checkPredicate('Map', input)) {\n                _context3.next = 7;\n                break;\n              }\n\n              _context3.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n\n            case 6:\n              return _context3.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context3.prev = 10;\n              _iterator = input[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context3.next = 24;\n                break;\n              }\n\n              _ref = _step.value;\n              _ref2 = slicedToArray(_ref, 2);\n              key = _ref2[0];\n              value = _ref2[1];\n\n              if (keyType.accepts(key)) {\n                _context3.next = 20;\n                break;\n              }\n\n              _context3.next = 20;\n              return [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n\n            case 20:\n              return _context3.delegateYield(valueType.errors(validation, path.concat(key), value), 't0', 21);\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context3.next = 12;\n              break;\n\n            case 24:\n              _context3.next = 30;\n              break;\n\n            case 26:\n              _context3.prev = 26;\n              _context3.t1 = _context3['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context3.t1;\n\n            case 30:\n              _context3.prev = 30;\n              _context3.prev = 31;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 33:\n              _context3.prev = 33;\n\n              if (!_didIteratorError) {\n                _context3.next = 36;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 36:\n              return _context3.finish(33);\n\n            case 37:\n              return _context3.finish(30);\n\n            case 38:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, errors, this, [[10, 26, 30, 38], [31,, 33, 37]]);\n    }),\n    accepts: function accepts(input, keyType, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref3 = _step2.value;\n\n          var _ref4 = slicedToArray(_ref3, 2);\n\n          var key = _ref4[0];\n          var value = _ref4[1];\n\n          if (!keyType.accepts(key) || !valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith: function compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var keyTypes = [];\n      var valueTypes = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        loop: for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref5 = _step3.value;\n\n          var _ref6 = slicedToArray(_ref5, 2);\n\n          var key = _ref6[0];\n          var value = _ref6[1];\n\n          findKey: {\n            for (var i = 0; i < keyTypes.length; i++) {\n              var type = keyTypes[i];\n              if (type.accepts(key)) {\n                break findKey;\n              }\n            }\n            keyTypes.push(t.typeOf(key));\n          }\n\n          for (var _i = 0; _i < valueTypes.length; _i++) {\n            var _type = valueTypes[_i];\n            if (_type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    errors: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input, valueType) {\n      var context, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              invariant(valueType, 'Must specify type parameter for Set.');\n              context = this.context;\n\n              if (context.checkPredicate('Set', input)) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n\n            case 5:\n              return _context4.abrupt('return');\n\n            case 6:\n              _iteratorNormalCompletion4 = true;\n              _didIteratorError4 = false;\n              _iteratorError4 = undefined;\n              _context4.prev = 9;\n              _iterator4 = input[Symbol.iterator]();\n\n            case 11:\n              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                _context4.next = 17;\n                break;\n              }\n\n              value = _step4.value;\n              return _context4.delegateYield(valueType.errors(validation, path, value), 't0', 14);\n\n            case 14:\n              _iteratorNormalCompletion4 = true;\n              _context4.next = 11;\n              break;\n\n            case 17:\n              _context4.next = 23;\n              break;\n\n            case 19:\n              _context4.prev = 19;\n              _context4.t1 = _context4['catch'](9);\n              _didIteratorError4 = true;\n              _iteratorError4 = _context4.t1;\n\n            case 23:\n              _context4.prev = 23;\n              _context4.prev = 24;\n\n              if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n              }\n\n            case 26:\n              _context4.prev = 26;\n\n              if (!_didIteratorError4) {\n                _context4.next = 29;\n                break;\n              }\n\n              throw _iteratorError4;\n\n            case 29:\n              return _context4.finish(26);\n\n            case 30:\n              return _context4.finish(23);\n\n            case 31:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, errors, this, [[9, 19, 23, 31], [24,, 26, 30]]);\n    }),\n    accepts: function accepts(input, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (!valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    },\n    compareWith: function compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var valueTypes = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        loop: for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n\n          for (var i = 0; i < valueTypes.length; i++) {\n            var type = valueTypes[i];\n            if (type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      } else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      } else {\n        return [t.union.apply(t, valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\nfunction registerTypePredicates(context) {\n  context.setPredicate('Array', function (input) {\n    return Array.isArray(input);\n  });\n  context.setPredicate('Map', function (input) {\n    return input instanceof Map;\n  });\n  context.setPredicate('Set', function (input) {\n    return input instanceof Set;\n  });\n  context.setPredicate('Promise', function (input) {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null && ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' || typeof input === 'function') && typeof input.then === 'function';\n    }\n  });\n}\n\nvar TypeInferer = function () {\n  function TypeInferer(context) {\n    classCallCheck(this, TypeInferer);\n\n    this.context = context;\n  }\n\n  createClass(TypeInferer, [{\n    key: 'infer',\n    value: function infer(input) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      var inferred = new Map();\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferInternal',\n    value: function inferInternal(input, inferred) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferPrimitive',\n    value: function inferPrimitive(input) {\n      var context = this.context;\n\n      if (input === null) {\n        return context.null();\n      } else if (input === undefined) {\n        return context.void();\n      } else if (typeof input === 'number') {\n        return context.number();\n      } else if (typeof input === 'boolean') {\n        return context.boolean();\n      } else if (typeof input === 'string') {\n        return context.string();\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return context.symbol(input);\n        } else {\n          return undefined;\n        }\n    }\n  }, {\n    key: 'inferComplex',\n    value: function inferComplex(input, inferred) {\n      var context = this.context;\n\n\n      if (typeof input === 'function') {\n        return this.inferFunction(input, inferred);\n      } else if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\n        return this.inferObject(input, inferred);\n      } else {\n        return context.any();\n      }\n    }\n  }, {\n    key: 'inferFunction',\n    value: function inferFunction(input, inferred) {\n      var context = this.context;\n      var length = input.length;\n\n      var body = new Array(length + 1);\n      for (var i = 0; i < length; i++) {\n        body[i] = context.param(String.fromCharCode(97 + i), context.existential());\n      }\n      body[length] = context.return(context.existential());\n      return context.fn.apply(context, body);\n    }\n  }, {\n    key: 'inferObject',\n    value: function inferObject(input, inferred) {\n      var existing = inferred.get(input);\n      if (existing) {\n        return existing;\n      }\n      var context = this.context;\n\n      var type = void 0;\n\n      // Temporarily create a box for this type to catch cyclical references.\n      // Nested references to this object will receive the boxed type.\n      var box = context.box(function () {\n        return type;\n      });\n      inferred.set(input, box);\n\n      if (context.checkPredicate('Array', input)) {\n        type = this.inferArray(input, inferred);\n      } else if (!(input instanceof Object)) {\n        type = this.inferDict(input, inferred);\n      } else if (input.constructor !== Object) {\n        var handler = context.getTypeConstructor(input.constructor);\n        if (handler) {\n          var typeParameters = handler.inferTypeParameters(input);\n          type = handler.apply.apply(handler, toConsumableArray(typeParameters));\n        } else {\n          type = context.ref(input.constructor);\n        }\n      } else {\n        var body = [];\n        for (var key in input) {\n          // eslint-disable-line\n          var value = input[key];\n          body.push(context.property(key, this.inferInternal(value, inferred)));\n        }\n        type = context.object.apply(context, body);\n      }\n\n      // Overwrite the box with the real value.\n      inferred.set(input, type);\n      return type;\n    }\n  }, {\n    key: 'inferDict',\n    value: function inferDict(input, inferred) {\n      var numericIndexers = [];\n      var stringIndexers = [];\n      loop: for (var key in input) {\n        // eslint-disable-line\n        var value = input[key];\n        var types = isNaN(+key) ? stringIndexers : numericIndexers;\n        for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        types.push(this.inferInternal(value, inferred));\n      }\n\n      var context = this.context;\n\n      var body = [];\n      if (numericIndexers.length === 1) {\n        body.push(context.indexer('index', context.number(), numericIndexers[0]));\n      } else if (numericIndexers.length > 1) {\n        body.push(context.indexer('index', context.number(), context.union.apply(context, numericIndexers)));\n      }\n\n      if (stringIndexers.length === 1) {\n        body.push(context.indexer('key', context.string(), stringIndexers[0]));\n      } else if (stringIndexers.length > 1) {\n        body.push(context.indexer('key', context.string(), context.union.apply(context, stringIndexers)));\n      }\n\n      return context.object.apply(context, body);\n    }\n  }, {\n    key: 'inferArray',\n    value: function inferArray(input, inferred) {\n      var context = this.context;\n\n      var types = [];\n      var values = [];\n      var length = input.length;\n\n      loop: for (var i = 0; i < length; i++) {\n        var item = input[i];\n        var inferredType = this.inferInternal(item, inferred);\n        for (var j = 0; j < types.length; j++) {\n          var type = types[j];\n          if (type.accepts(item) && inferredType.accepts(values[j])) {\n            continue loop;\n          }\n        }\n        types.push(inferredType);\n        values.push(item);\n      }\n      if (types.length === 0) {\n        return context.array(context.any());\n      } else if (types.length === 1) {\n        return context.array(types[0]);\n      } else {\n        return context.array(context.union.apply(context, types));\n      }\n    }\n  }]);\n  return TypeInferer;\n}();\n\nfunction makeReactPropTypes(objectType) {\n  var output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n\n  var _loop = function _loop(property) {\n    output[property.key] = function (props, propName, componentName) {\n      return makeError(property, props);\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = objectType.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return output;\n}\n\nvar delimiter$1 = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeWarningMessage(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actual + '\\n');\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return 'Warning: ' + collected.join(delimiter$1);\n}\n\nfunction makeUnion(context, types) {\n  var length = types.length;\n  var merged = [];\n  for (var i = 0; i < length; i++) {\n    var type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return type;\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    } else {\n      merged.push(type);\n    }\n  }\n  var union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes(aTypes, bTypes) {\n  loop: for (var i = 0; i < bTypes.length; i++) {\n    var bType = bTypes[i];\n    for (var j = 0; j < aTypes.length; j++) {\n      var aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\nfunction makePropertyDescriptor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert);\n  } else {\n    return propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert);\n  }\n}\n\nfunction makePropertyName(name) {\n  return '_flowRuntime$' + name;\n}\n\nfunction getClassName(input) {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  } else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  } else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType(receiver, typeSource) {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  } else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  var safeName = makePropertyName(propertyName);\n  var className = getClassName(input);\n  var initializer = descriptor.initializer,\n      writable = descriptor.writable,\n      config = objectWithoutProperties(descriptor, ['initializer', 'writable']); // eslint-disable-line no-unused-vars\n\n  var propertyPath = [className, propertyName];\n\n  return _extends({}, config, {\n    type: 'accessor',\n    get: function get$$1() {\n      if (safeName in this) {\n        return this[safeName];\n      } else if (initializer) {\n        var type = resolveType(this, typeSource);\n        var _value = initializer.call(this);\n        var context = type.context;\n        context.check(type, _value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: _value\n        });\n        return _value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set: function set$$1(value) {\n      var type = resolveType(this, typeSource);\n      var context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      } else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  });\n}\n\nfunction augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert) {\n\n  var className = getClassName(input);\n  var propertyPath = [className, propertyName];\n\n  var originalSetter = descriptor.set;\n\n  descriptor.set = function set$$1(value) {\n    var type = resolveType(this, typeSource);\n    var context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    } else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n}\n\n// eslint-disable-line no-redeclare\n\nfunction annotateValue(input, type) {\n  // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  } else {\n    var _type = input;\n    return function (input) {\n      input[TypeSymbol] = _type;\n      return input;\n    };\n  }\n}\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nvar $DiffType = function (_Type) {\n  inherits($DiffType, _Type);\n\n  function $DiffType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $DiffType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $DiffType.__proto__ || Object.getPrototypeOf($DiffType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$DiffType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($DiffType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var aType, bType, properties, i, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              aType = this.aType, bType = this.bType;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              aType = aType.unwrap();\n              bType = bType.unwrap();\n              invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n              properties = aType.properties;\n              i = 0;\n\n            case 10:\n              if (!(i < properties.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!bType.hasProperty(property.key)) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt('continue', 15);\n\n            case 14:\n              return _context.delegateYield(property.errors(validation, path.concat(property.key), input), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        if (!property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var aType = this.aType,\n          bType = this.bType;\n\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      var args = [];\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        args.push(property);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Diff<' + this.aType.toString() + ', ' + this.bType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        aType: this.aType,\n        bType: this.bType\n      };\n    }\n  }]);\n  return $DiffType;\n}(Type);\n\n// Any subtype of T\n\nvar $FlowFixMeType = function (_Type) {\n  inherits($FlowFixMeType, _Type);\n\n  function $FlowFixMeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $FlowFixMeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $FlowFixMeType.__proto__ || Object.getPrototypeOf($FlowFixMeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$FlowFixMeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($FlowFixMeType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, input) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$FlowFixMe';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return $FlowFixMeType;\n}(Type);\n\n// The set of keys of T.\n\nvar $KeysType = function (_Type) {\n  inherits($KeysType, _Type);\n\n  function $KeysType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $KeysType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $KeysType.__proto__ || Object.getPrototypeOf($KeysType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$KeysType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($KeysType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, properties, length, i, property, keys, _i;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type.unwrap();\n\n              invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n              properties = type.properties;\n              length = properties.length;\n              i = 0;\n\n            case 5:\n              if (!(i < length)) {\n                _context.next = 12;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!(input === property.key)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i++;\n              _context.next = 5;\n              break;\n\n            case 12:\n              keys = new Array(length);\n\n              for (_i = 0; _i < length; _i++) {\n                keys[_i] = properties[_i].key;\n              }\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var keys = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        keys[i] = context.literal(property.key);\n      }\n      return (_context2 = this.context).union.apply(_context2, keys);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Keys<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $KeysType;\n}(Type);\n\n// Map over the keys and values in an object.\n\nvar $ObjMapiType = function (_Type) {\n  inherits($ObjMapiType, _Type);\n\n  function $ObjMapiType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapiType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapiType.__proto__ || Object.getPrototypeOf($ObjMapiType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapiType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapiType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key), prop.value);\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key), prop.value)));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMapi<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapiType;\n}(Type);\n\n// Map over the keys in an object.\n\nvar $ObjMapType = function (_Type) {\n  inherits($ObjMapType, _Type);\n\n  function $ObjMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapType.__proto__ || Object.getPrototypeOf($ObjMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key));\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key))));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMap<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapType;\n}(Type);\n\n// The type of the named object property\n\nvar $PropertyType = function (_Type) {\n  inherits($PropertyType, _Type);\n\n  function $PropertyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $PropertyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $PropertyType.__proto__ || Object.getPrototypeOf($PropertyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$PropertyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($PropertyType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.unwrap().errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.unwrap().accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          property = this.property;\n\n      var unwrapped = object.unwrap();\n      invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n      return unwrapped.getProperty(property).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$PropertyType<' + this.object.toString() + ', ' + String(this.property) + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        property: this.property\n      };\n    }\n  }]);\n  return $PropertyType;\n}(Type);\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nvar $ShapeType = function (_Type) {\n  inherits($ShapeType, _Type);\n\n  function $ShapeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ShapeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ShapeType.__proto__ || Object.getPrototypeOf($ShapeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ShapeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ShapeType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, key, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n\n              type = type.unwrap();\n              invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n              _context.t0 = _regeneratorRuntime.keys(input);\n\n            case 8:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              key = _context.t1.value;\n              // eslint-disable-line guard-for-in\n              property = type.getProperty(key);\n\n              if (property) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt('continue', 8);\n\n            case 13:\n              return _context.delegateYield(property.errors(validation, path, input), 't2', 14);\n\n            case 14:\n              _context.next = 8;\n              break;\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property || !property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var type = this.type;\n\n      type = type.unwrap();\n      var context = this.context;\n      invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n      var properties = type.properties;\n      var args = new Array(properties.length);\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        args[i] = context.property(property.key, property.value, true);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Shape<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ShapeType;\n}(Type);\n\n// Any subtype of T\n\nvar $SubType = function (_Type) {\n  inherits($SubType, _Type);\n\n  function $SubType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SubType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SubType.__proto__ || Object.getPrototypeOf($SubType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SubType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SubType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(input, path), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Subtype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SubType;\n}(Type);\n\n// Any, but at least T.\n\nvar $SuperType = function (_Type) {\n  inherits($SuperType, _Type);\n\n  function $SuperType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SuperType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SuperType.__proto__ || Object.getPrototypeOf($SuperType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SuperType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SuperType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Supertype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SuperType;\n}(Type);\n\n// Map over the values in a tuple.\n\nvar $TupleMapType = function (_Type) {\n  inherits($TupleMapType, _Type);\n\n  function $TupleMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $TupleMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $TupleMapType.__proto__ || Object.getPrototypeOf($TupleMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$TupleMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($TupleMapType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var tuple, mapper, context, target, i, type, applied, expected, value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              tuple = this.tuple, mapper = this.mapper, context = this.context;\n              target = tuple.unwrap();\n\n              invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < target.types.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              type = target.types[i];\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              expected = applied.invoke(type);\n              value = input[i];\n              return _context.delegateYield(expected.errors(validation, path.concat(i), value), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        if (!applied.invoke(type).accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n      var args = [];\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        args.push(applied.invoke(type).unwrap().unwrap());\n      }\n\n      return context.tuple.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$TupleMap<' + this.tuple.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        tuple: this.tuple,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $TupleMapType;\n}(Type);\n\n// The set of keys of T.\n\nvar $ValuesType = function (_Type) {\n  inherits($ValuesType, _Type);\n\n  function $ValuesType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ValuesType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ValuesType.__proto__ || Object.getPrototypeOf($ValuesType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ValuesType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ValuesType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, properties, length, i, property, values, _i;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type.unwrap();\n\n              invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n              properties = type.properties;\n              length = properties.length;\n              i = 0;\n\n            case 5:\n              if (!(i < length)) {\n                _context.next = 12;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!property.value.accepts(input)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i++;\n              _context.next = 5;\n              break;\n\n            case 12:\n              values = new Array(length);\n\n              for (_i = 0; _i < length; _i++) {\n                values[_i] = properties[_i].value.toString();\n              }\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.value.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var values = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        values[i] = property.value;\n      }\n      return context.union.apply(context, values);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Values<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ValuesType;\n}(Type);\n\nfunction checkGenericType(context, expected, input) {\n  var impl = expected.impl;\n\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  } else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  var annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  } else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType(context, expected, input) {\n  var annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    var result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\nvar ClassType = function (_Type) {\n  inherits(ClassType, _Type);\n\n  function ClassType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassType.__proto__ || Object.getPrototypeOf(ClassType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassType, [{\n    key: 'errors',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function errors(validation, path, input) {\n      var instanceType, context, expectedType, isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              instanceType = this.instanceType, context = this.context;\n\n              if (!(typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n              isValid = expectedType instanceof GenericType ? checkGenericType(context, expectedType, input) : checkType(context, expectedType, input);\n\n              if (isValid) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 10;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 10:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      if (expectedType instanceof GenericType) {\n        return checkGenericType(context, expectedType, input);\n      } else {\n        return checkType(context, expectedType, input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var instanceType = this.instanceType;\n\n      if (input instanceof ClassType) {\n        return compareTypes(instanceType, input.instanceType);\n      }\n      return -1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Class<' + this.instanceType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        instanceType: this.instanceType\n      };\n    }\n  }]);\n  return ClassType;\n}(Type);\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nvar warnedInvalidReferences = new WeakSet();\n\nvar TypeContext = function () {\n  function TypeContext() {\n    classCallCheck(this, TypeContext);\n    this.mode = 'assert';\n    this[NameRegistrySymbol] = {};\n    this[TypePredicateRegistrySymbol] = {};\n    this[TypeConstructorRegistrySymbol] = new Map();\n    this[InferrerSymbol] = new TypeInferer(this);\n    this[ModuleRegistrySymbol] = {};\n  }\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeContext, [{\n    key: 'makeJSONError',\n    value: function makeJSONError$$1(validation) {\n      return makeJSONError(validation);\n    }\n  }, {\n    key: 'makeTypeError',\n    value: function makeTypeError$$1(validation) {\n      return makeTypeError(validation);\n    }\n  }, {\n    key: 'createContext',\n    value: function createContext() {\n      var context = new TypeContext();\n      // Issue 252\n      context[ParentSymbol] = this;\n      return context;\n    }\n  }, {\n    key: 'typeOf',\n    value: function typeOf(input) {\n\n      var annotation = this.getAnnotation(input);\n      if (annotation) {\n        if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n          return this.Class(annotation);\n        }\n        return annotation;\n      }\n      // Issue 252\n      var inferrer = this[InferrerSymbol];\n      inferrer;\n\n      return inferrer.infer(input);\n    }\n  }, {\n    key: 'compareTypes',\n    value: function compareTypes$$1(a, b) {\n      return compareTypes(a, b);\n    }\n  }, {\n    key: 'get',\n    value: function get$$1(name) {\n      // Issue 252\n      var item = this[NameRegistrySymbol][name];\n\n      for (var _len = arguments.length, propertyNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        propertyNames[_key - 1] = arguments[_key];\n      }\n\n      if (item != null) {\n        var current = typeof item === 'function' ? new item(this) : item;\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n          if (typeof current.getProperty !== 'function') {\n            return;\n          }\n          current = current.getProperty(propertyName);\n          if (!current) {\n            return;\n          }\n          current = current.unwrap();\n        }\n        return current;\n      }\n      // Issue 252\n      var parent = this[ParentSymbol];\n      if (parent) {\n        var fromParent = parent.get.apply(parent, [name].concat(toConsumableArray(propertyNames)));\n        if (fromParent) {\n          return fromParent;\n        }\n      }\n\n      // if we got this far, see if we have a global type with this name.\n      if (typeof global[name] === 'function') {\n        var target = new GenericType(this);\n        target.name = name;\n        target.impl = global[name];\n        // Issue 252\n        this[NameRegistrySymbol][name] = target;\n        return target;\n      }\n    }\n\n    /**\n     * Get the predicate for a given type name.\n     * e.g. `t.getPredicate('Array')`.\n     */\n\n  }, {\n    key: 'getPredicate',\n    value: function getPredicate(name) {\n      var item = this[TypePredicateRegistrySymbol][name];\n      if (item) {\n        return item;\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.getPredicate(name);\n      }\n    }\n\n    /**\n     * Set the predicate for a given type name.\n     * This can be used to customise the behaviour of things like Array\n     * detection or allowing Thenables in place of the global Promise.\n     */\n\n  }, {\n    key: 'setPredicate',\n    value: function setPredicate(name, predicate) {\n      this[TypePredicateRegistrySymbol][name] = predicate;\n    }\n\n    /**\n     * Check the given value against the named predicate.\n     * Returns false if no such predicate exists.\n     * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n     */\n\n  }, {\n    key: 'checkPredicate',\n    value: function checkPredicate(name, input) {\n      var predicate = this.getPredicate(name);\n      if (predicate) {\n        return predicate(input);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Returns a decorator for a function or object with the given type.\n     */\n\n  }, {\n    key: 'decorate',\n    value: function decorate(type, shouldAssert) {\n      var _this2 = this;\n\n      if (shouldAssert == null) {\n        shouldAssert = this.mode === 'assert';\n      }\n      return function (input, propertyName, descriptor) {\n        if (descriptor && typeof propertyName === 'string') {\n          return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n        } else {\n          invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n          return _this2.annotate(input, type);\n        }\n      };\n    }\n\n    /**\n     * Annotates an object or function with the given type.\n     * If a type is specified as the sole argument, returns a\n     * function which can decorate classes or functions with the given type.\n     */\n\n  }, {\n    key: 'annotate',\n    value: function annotate(input, type) {\n      if (type === undefined) {\n        return annotateValue(input);\n      } else {\n        return annotateValue(input, type);\n      }\n    }\n  }, {\n    key: 'getAnnotation',\n    value: function getAnnotation(input) {\n      if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' || typeof input === 'function') {\n        // Issue 252\n        return input[TypeSymbol];\n      }\n    }\n  }, {\n    key: 'hasAnnotation',\n    value: function hasAnnotation(input) {\n      if (input == null) {\n        return false;\n      } else {\n        return input[TypeSymbol] ? true : false;\n      }\n    }\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(input, type) {\n      input[TypeSymbol] = type;\n      return input;\n    }\n  }, {\n    key: 'type',\n    value: function type(name, _type) {\n      if (typeof _type === 'function') {\n        var target = new ParameterizedTypeAlias(this);\n        target.name = name;\n        target.typeCreator = _type;\n        return target;\n      } else {\n        var _target = new TypeAlias(this);\n        _target.name = name;\n        _target.type = _type;\n        return _target;\n      }\n    }\n  }, {\n    key: 'declare',\n    value: function declare(name, type) {\n\n      if (name instanceof Declaration) {\n        type = name;\n        name = type.name;\n      } else if (name instanceof TypeAlias) {\n        type = name;\n        name = type.name;\n      }\n      if (typeof type === 'function') {\n        type = this.type(name, type);\n      }\n      if (type instanceof ModuleDeclaration) {\n        var moduleRegistry = this[ModuleRegistrySymbol];\n        moduleRegistry[name] = type;\n        return type;\n      } else {\n        invariant(typeof name === 'string', 'Name must be a string');\n        invariant(type instanceof Type, 'Type must be supplied to declaration');\n        var nameRegistry = this[NameRegistrySymbol];\n\n        if (type instanceof Declaration) {\n          nameRegistry[name] = type;\n          return type;\n        } else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n          var target = new TypeDeclaration(this);\n          target.name = name;\n          target.typeAlias = type;\n          nameRegistry[name] = target;\n          return target;\n        } else {\n          var _target2 = this.var(name, type);\n          nameRegistry[name] = _target2;\n          return _target2;\n        }\n      }\n    }\n  }, {\n    key: 'declarations',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function declarations() {\n      var nameRegistry, key;\n      return _regeneratorRuntime.wrap(function declarations$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              nameRegistry = this[NameRegistrySymbol];\n              _context.t0 = _regeneratorRuntime.keys(nameRegistry);\n\n            case 2:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 8;\n                break;\n              }\n\n              key = _context.t1.value;\n              _context.next = 6;\n              return [key, nameRegistry[key]];\n\n            case 6:\n              _context.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, declarations, this);\n    })\n  }, {\n    key: 'modules',\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function modules() {\n      var moduleRegistry, key;\n      return _regeneratorRuntime.wrap(function modules$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              moduleRegistry = this[ModuleRegistrySymbol];\n              _context2.t0 = _regeneratorRuntime.keys(moduleRegistry);\n\n            case 2:\n              if ((_context2.t1 = _context2.t0()).done) {\n                _context2.next = 8;\n                break;\n              }\n\n              key = _context2.t1.value;\n              _context2.next = 6;\n              return moduleRegistry[key];\n\n            case 6:\n              _context2.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, modules, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      if (moduleRegistry[moduleName]) {\n        return moduleRegistry[moduleName];\n      }\n\n      var _moduleName$split = moduleName.split('/'),\n          _moduleName$split2 = slicedToArray(_moduleName$split, 1),\n          head = _moduleName$split2[0];\n\n      var module = moduleRegistry[head];\n      if (module) {\n        return module.import(moduleName);\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.import(moduleName);\n      }\n    }\n  }, {\n    key: 'declareTypeConstructor',\n    value: function declareTypeConstructor(_ref) {\n      var name = _ref.name,\n          impl = _ref.impl,\n          typeName = _ref.typeName,\n          errors = _ref.errors,\n          accepts = _ref.accepts,\n          inferTypeParameters = _ref.inferTypeParameters,\n          compareWith = _ref.compareWith;\n\n      var nameRegistry = this[NameRegistrySymbol];\n\n      if (nameRegistry[name]) {\n        this.emitWarningMessage('Redeclaring type: ' + name + ', this may be unintended.');\n      }\n\n      var target = new TypeConstructor(this);\n      target.name = name;\n      target.typeName = typeName;\n      target.impl = impl;\n      target.errors = errors;\n      target.accepts = accepts;\n      target.inferTypeParameters = inferTypeParameters;\n      if (typeof compareWith === 'function') {\n        target.compareWith = compareWith;\n      }\n\n      nameRegistry[name] = target;\n\n      if (typeof impl === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        if (handlerRegistry.has(impl)) {\n          this.emitWarningMessage('A type handler already exists for the given implementation of ' + name + '.');\n        }\n        handlerRegistry.set(impl, target);\n      }\n      return target;\n    }\n  }, {\n    key: 'getTypeConstructor',\n    value: function getTypeConstructor(impl) {\n      // Issue 252\n      var handlerRegistry = this[TypeConstructorRegistrySymbol];\n      handlerRegistry;\n\n      return handlerRegistry.get(impl);\n    }\n  }, {\n    key: 'literal',\n    value: function literal(input) {\n      if (input === undefined) {\n        return this.void();\n      } else if (input === null) {\n        return this.null();\n      } else if (typeof input === 'boolean') {\n        return this.boolean(input);\n      } else if (typeof input === 'number') {\n        return this.number(input);\n      } else if (typeof input === 'string') {\n        return this.string(input);\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return this.symbol(input);\n        } else {\n          return this.typeOf(input);\n        }\n    }\n  }, {\n    key: 'null',\n    value: function _null() {\n      return primitiveTypes.null;\n    }\n  }, {\n    key: 'nullable',\n    value: function nullable(type) {\n      var target = new NullableType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'existential',\n    value: function existential() {\n      return primitiveTypes.existential;\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return primitiveTypes.empty;\n    }\n  }, {\n    key: 'any',\n    value: function any() {\n      return primitiveTypes.any;\n    }\n  }, {\n    key: 'mixed',\n    value: function mixed() {\n      return primitiveTypes.mixed;\n    }\n  }, {\n    key: 'void',\n    value: function _void() {\n      return primitiveTypes.void;\n    }\n  }, {\n    key: 'this',\n    value: function _this(input) {\n      var target = new ThisType(this);\n      if (input !== undefined) {\n        target.recorded = input;\n      }\n      return target;\n    }\n  }, {\n    key: 'number',\n    value: function number(input) {\n      if (input !== undefined) {\n        var target = new NumericLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.number;\n      }\n    }\n  }, {\n    key: 'boolean',\n    value: function boolean(input) {\n      if (input !== undefined) {\n        var target = new BooleanLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.boolean;\n      }\n    }\n  }, {\n    key: 'string',\n    value: function string(input) {\n      if (input !== undefined) {\n        var target = new StringLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.string;\n      }\n    }\n  }, {\n    key: 'symbol',\n    value: function symbol(input) {\n      if (input !== undefined) {\n        var target = new SymbolLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.symbol;\n      }\n    }\n  }, {\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      return target;\n    }\n  }, {\n    key: 'flowInto',\n    value: function flowInto(typeParameter) {\n      return flowIntoTypeParameter(typeParameter);\n    }\n\n    /**\n     * Bind the type parameters for the parent class of the given instance.\n     */\n\n  }, {\n    key: 'bindTypeParameters',\n    value: function bindTypeParameters(subject) {\n      var instancePrototype = Object.getPrototypeOf(subject);\n      // Issue\n      var parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n      // Issue\n      var parentClass = parentPrototype && parentPrototype.constructor;\n\n      if (!parentClass) {\n        this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n        return subject;\n      }\n      // Issue 252\n      var typeParametersPointer = parentClass[TypeParametersSymbol];\n\n      if (typeParametersPointer) {\n        var typeParameters = subject[typeParametersPointer];\n        var keys = Object.keys(typeParameters);\n\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var length = Math.min(keys.length, typeInstances.length);\n        for (var i = 0; i < length; i++) {\n          var typeParam = typeParameters[keys[i]];\n          typeParam.bound = typeInstances[i];\n        }\n      }\n      return subject;\n    }\n  }, {\n    key: 'module',\n    value: function module(name, body) {\n      var target = new ModuleDeclaration(this);\n      target.name = name;\n      var innerContext = this.createContext();\n      // Issue 252\n      innerContext[ParentSymbol] = this;\n      // Issue 252\n      innerContext[CurrentModuleSymbol] = target;\n\n      target.innerContext = innerContext;\n      body(innerContext);\n      return target;\n    }\n  }, {\n    key: 'moduleExports',\n    value: function moduleExports(type) {\n      var currentModule = this[CurrentModuleSymbol];\n      if (!currentModule) {\n        throw new Error('Cannot declare module.exports outside of a module.');\n      }\n      var target = new ModuleExports(this);\n      target.type = type;\n      currentModule.moduleExports = target;\n      return target;\n    }\n  }, {\n    key: 'var',\n    value: function _var(name, type) {\n      var target = new VarDeclaration(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'class',\n    value: function _class(name, head) {\n      if (typeof head === 'function') {\n        var _target3 = new ParameterizedClassDeclaration(this);\n        _target3.name = name;\n        _target3.bodyCreator = head;\n        return _target3;\n      }\n      var target = new ClassDeclaration(this);\n      target.name = name;\n\n      for (var _len3 = arguments.length, tail = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        tail[_key3 - 2] = arguments[_key3];\n      }\n\n      if (head != null) {\n        tail.unshift(head);\n      }\n      var length = tail.length;\n\n      var properties = [];\n      var body = void 0;\n\n      for (var i = 0; i < length; i++) {\n        var item = tail[i];\n        if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n          properties.push(item);\n        } else if (item instanceof ObjectType) {\n          invariant(!body, 'Class body must only be declared once.');\n          body = item;\n        } else if (item instanceof ExtendsDeclaration) {\n          invariant(!target.superClass, 'Classes can only have one super class.');\n          target.superClass = item;\n        } else if (item != null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof Type)) {\n          for (var propertyName in item) {\n            // eslint-disable-line\n            properties.push(this.property(propertyName, item[propertyName]));\n          }\n        } else {\n          throw new Error('ClassDeclaration cannot contain the given type directly.');\n        }\n      }\n      if (!body) {\n        body = new ObjectType(this);\n      }\n      if (properties.length) {\n        var _body$properties;\n\n        (_body$properties = body.properties).push.apply(_body$properties, properties);\n      }\n      target.body = body;\n      return target;\n    }\n  }, {\n    key: 'extends',\n    value: function _extends(subject) {\n      var target = new ExtendsDeclaration(this);\n\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      target.type = this.ref.apply(this, [subject].concat(toConsumableArray(typeInstances)));\n      return target;\n    }\n  }, {\n    key: 'fn',\n    value: function fn(head) {\n      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        tail[_key5 - 1] = arguments[_key5];\n      }\n\n      return this.function.apply(this, [head].concat(tail));\n    }\n  }, {\n    key: 'function',\n    value: function _function(head) {\n      if (typeof head === 'function') {\n        var _target4 = new ParameterizedFunctionType(this);\n        _target4.bodyCreator = head;\n        return _target4;\n      }\n      var target = new FunctionType(this);\n      if (head != null) {\n        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          tail[_key6 - 1] = arguments[_key6];\n        }\n\n        tail.unshift(head);\n        var length = tail.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = tail[i];\n          if (item instanceof FunctionTypeParam) {\n            target.params.push(item);\n          } else if (item instanceof FunctionTypeRestParam) {\n            target.rest = item;\n          } else if (item instanceof FunctionTypeReturn) {\n            target.returnType = item;\n          } else {\n            throw new Error('FunctionType cannot contain the given type directly.');\n          }\n        }\n      }\n      if (!target.returnType) {\n        target.returnType = this.any();\n      }\n      return target;\n    }\n  }, {\n    key: 'param',\n    value: function param(name, type) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new FunctionTypeParam(this);\n      target.name = name;\n      target.type = type;\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'rest',\n    value: function rest(name, type) {\n      var target = new FunctionTypeRestParam(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'return',\n    value: function _return(type) {\n      var target = new FunctionTypeReturn(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'generator',\n    value: function generator(yieldType, returnType, nextType) {\n      var target = new GeneratorType(this);\n      target.yieldType = yieldType;\n      target.returnType = returnType || this.any();\n      target.nextType = nextType || this.any();\n      return target;\n    }\n  }, {\n    key: 'object',\n    value: function object(head) {\n      var target = new ObjectType(this);\n      if (head != null && (typeof head === 'undefined' ? 'undefined' : _typeof(head)) === 'object' && !(head instanceof Type)) {\n        for (var propertyName in head) {\n          // eslint-disable-line\n          target.properties.push(this.property(propertyName, head[propertyName]));\n        }\n      } else {\n        var body = void 0;\n\n        for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          tail[_key7 - 1] = arguments[_key7];\n        }\n\n        if (head) {\n          body = [head].concat(toConsumableArray(tail));\n        } else {\n          body = tail;\n        }\n        var _body = body,\n            length = _body.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = body[i];\n          if (item instanceof ObjectTypeProperty) {\n            target.properties.push(item);\n          } else if (item instanceof ObjectTypeIndexer) {\n            target.indexers.push(item);\n          } else if (item instanceof ObjectTypeCallProperty) {\n            target.callProperties.push(item);\n          } else {\n            throw new Error('ObjectType cannot contain the given type directly.');\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'exactObject',\n    value: function exactObject(head) {\n      for (var _len8 = arguments.length, tail = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        tail[_key8 - 1] = arguments[_key8];\n      }\n\n      var object = this.object.apply(this, [head].concat(toConsumableArray(tail)));\n      object.exact = true;\n      return object;\n    }\n  }, {\n    key: 'callProperty',\n    value: function callProperty(value) {\n      var target = new ObjectTypeCallProperty(this);\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'property',\n    value: function property(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new ObjectTypeProperty(this);\n      target.key = key;\n      if (value instanceof Type) {\n        target.value = value;\n      } else {\n        target.value = this.object(value);\n      }\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'indexer',\n    value: function indexer(id, key, value) {\n      var target = new ObjectTypeIndexer(this);\n      target.id = id;\n      target.key = key;\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'method',\n    value: function method(name, head) {\n      var target = new ObjectTypeProperty(this);\n      target.key = name;\n\n      for (var _len9 = arguments.length, tail = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        tail[_key9 - 2] = arguments[_key9];\n      }\n\n      target.value = this.function.apply(this, [head].concat(tail));\n      return target;\n    }\n  }, {\n    key: 'staticCallProperty',\n    value: function staticCallProperty(value) {\n      var prop = this.callProperty(value);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticProperty',\n    value: function staticProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var prop = this.property(key, value, optional);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticMethod',\n    value: function staticMethod(name, head) {\n      for (var _len10 = arguments.length, tail = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        tail[_key10 - 2] = arguments[_key10];\n      }\n\n      var prop = this.method.apply(this, [name, head].concat(tail));\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'spread',\n    value: function spread() {\n      var target = new ObjectType(this);\n\n      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        types[_key11] = arguments[_key11];\n      }\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        if (Array.isArray(type.callProperties)) {\n          var _target$callPropertie;\n\n          (_target$callPropertie = target.callProperties).push.apply(_target$callPropertie, toConsumableArray(type.callProperties));\n        }\n        if (Array.isArray(type.indexers)) {\n          var _target$indexers;\n\n          (_target$indexers = target.indexers).push.apply(_target$indexers, toConsumableArray(type.indexers));\n        }\n        if (Array.isArray(type.properties)) {\n          for (var j = 0; j < type.properties.length; j++) {\n            var prop = type.properties[j];\n            invariant(prop instanceof ObjectTypeProperty);\n            target.setProperty(prop.key, prop.value, prop.optional);\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'tuple',\n    value: function tuple() {\n      var target = new TupleType(this);\n\n      for (var _len12 = arguments.length, types = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        types[_key12] = arguments[_key12];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'array',\n    value: function array(elementType) {\n      var target = new ArrayType(this);\n      target.elementType = elementType || this.any();\n      return target;\n    }\n  }, {\n    key: 'union',\n    value: function union() {\n      for (var _len13 = arguments.length, types = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        types[_key13] = arguments[_key13];\n      }\n\n      return makeUnion(this, types);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect() {\n      var target = new IntersectionType(this);\n\n      for (var _len14 = arguments.length, types = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        types[_key14] = arguments[_key14];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'intersection',\n    value: function intersection() {\n      return this.intersect.apply(this, arguments);\n    }\n  }, {\n    key: 'box',\n    value: function box(reveal) {\n      var box = new TypeBox(this);\n      box.reveal = reveal;\n      return box;\n    }\n  }, {\n    key: 'tdz',\n    value: function tdz(reveal, name) {\n      var tdz = new TypeTDZ(this);\n      tdz.reveal = reveal;\n      tdz.name = name;\n      return tdz;\n    }\n  }, {\n    key: 'ref',\n    value: function ref(subject) {\n      var target = void 0;\n      if (typeof subject === 'string') {\n        // try and eagerly resolve the reference\n        target = this.get(subject);\n        if (!target) {\n          // defer dereferencing for now\n          target = new TypeReference(this);\n          target.name = subject;\n        }\n      } else if (typeof subject === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        // see if we have a dedicated TypeConstructor for this.\n        target = handlerRegistry.get(subject);\n\n        if (!target) {\n          // just use a generic type handler.\n          target = new GenericType(this);\n          target.impl = subject;\n          target.name = subject.name;\n        }\n      } else if (subject instanceof Type) {\n        target = subject;\n      } else {\n        if (subject == null || (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) !== 'object') {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead. (got ' + String(subject) + ')');\n        } else if (!warnedInvalidReferences.has(subject)) {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n          warnedInvalidReferences.add(subject);\n        }\n        return this.any();\n      }\n\n      for (var _len15 = arguments.length, typeInstances = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n        typeInstances[_key15 - 1] = arguments[_key15];\n      }\n\n      if (typeInstances.length) {\n        var _target5;\n\n        invariant(typeof target.apply === 'function', 'Cannot apply non-applicable type: ' + target.typeName + '.');\n        return (_target5 = target).apply.apply(_target5, toConsumableArray(typeInstances));\n      } else {\n        return target;\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = new Validation(this, input);\n      if (path) {\n        var _validation$path;\n\n        (_validation$path = validation.path).push.apply(_validation$path, toConsumableArray(path));\n      } else if (typeof type.name === 'string') {\n        validation.path.push(type.name);\n      }\n      validation.prefix = prefix;\n      validation.errors = Array.from(type.errors(validation, [], input));\n      return validation;\n    }\n  }, {\n    key: 'check',\n    value: function check(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      if (this.mode === 'assert') {\n        return this.assert(type, input, prefix, path);\n      } else {\n        return this.warn(type, input, prefix, path);\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var error = this.makeTypeError(validation);\n      if (error) {\n        throw error;\n      }\n      return input;\n    }\n  }, {\n    key: 'warn',\n    value: function warn(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var message = makeWarningMessage(validation);\n      if (typeof message === 'string') {\n        this.emitWarningMessage(message);\n      }\n      return input;\n    }\n\n    /**\n     * Emits a warning message, using `console.warn()` by default.\n     */\n\n  }, {\n    key: 'emitWarningMessage',\n    value: function emitWarningMessage(message) {\n      console.warn('flow-runtime:', message);\n    }\n  }, {\n    key: 'propTypes',\n    value: function propTypes(type) {\n      return makeReactPropTypes(type.unwrap());\n    }\n  }, {\n    key: 'match',\n    value: function match() {\n      for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      var clauses = args.pop();\n      if (!Array.isArray(clauses)) {\n        throw new Error('Invalid pattern, last argument must be an array.');\n      }\n      clauses;\n      var pattern = this.pattern.apply(this, toConsumableArray(clauses));\n      return pattern.apply(undefined, args);\n    }\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      for (var _len17 = arguments.length, clauses = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        clauses[_key17] = arguments[_key17];\n      }\n\n      var length = clauses.length;\n\n      var tests = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var clause = clauses[i];\n        var annotation = this.getAnnotation(clause);\n        if (!annotation) {\n          if (i !== length - 1) {\n            throw new Error('Invalid Pattern - found unannotated function in position ' + i + ', default clauses must be last.');\n          }\n          tests[i] = true;\n        } else {\n          invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n          tests[i] = annotation;\n        }\n      }\n      return function () {\n        for (var _i = 0; _i < tests.length; _i++) {\n          var test = tests[_i];\n          var _clause = clauses[_i];\n          if (test === true) {\n            return _clause.apply(undefined, arguments);\n          } else if (test.acceptsParams.apply(test, arguments)) {\n            return _clause.apply(undefined, arguments);\n          }\n        }\n        var error = new TypeError('Value did not match any of the candidates.');\n        error.name = 'RuntimeTypeError';\n        throw error;\n      };\n    }\n  }, {\n    key: 'wrapIterator',\n    value: function wrapIterator(type) {\n      var t = this;\n      return (/*#__PURE__*/_regeneratorRuntime.mark(function wrappedIterator(input) {\n          var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;\n\n          return _regeneratorRuntime.wrap(function wrappedIterator$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _iteratorNormalCompletion = true;\n                  _didIteratorError = false;\n                  _iteratorError = undefined;\n                  _context3.prev = 3;\n                  _iterator = input[Symbol.iterator]();\n\n                case 5:\n                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                    _context3.next = 12;\n                    break;\n                  }\n\n                  item = _step.value;\n                  _context3.next = 9;\n                  return t.check(type, item);\n\n                case 9:\n                  _iteratorNormalCompletion = true;\n                  _context3.next = 5;\n                  break;\n\n                case 12:\n                  _context3.next = 18;\n                  break;\n\n                case 14:\n                  _context3.prev = 14;\n                  _context3.t0 = _context3['catch'](3);\n                  _didIteratorError = true;\n                  _iteratorError = _context3.t0;\n\n                case 18:\n                  _context3.prev = 18;\n                  _context3.prev = 19;\n\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n\n                case 21:\n                  _context3.prev = 21;\n\n                  if (!_didIteratorError) {\n                    _context3.next = 24;\n                    break;\n                  }\n\n                  throw _iteratorError;\n\n                case 24:\n                  return _context3.finish(21);\n\n                case 25:\n                  return _context3.finish(18);\n\n                case 26:\n                case 'end':\n                  return _context3.stop();\n              }\n            }\n          }, wrappedIterator, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n        })\n      );\n    }\n  }, {\n    key: 'refinement',\n    value: function refinement(type) {\n      var target = new RefinementType(this);\n      target.type = type;\n\n      for (var _len18 = arguments.length, constraints = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n        constraints[_key18 - 1] = arguments[_key18];\n      }\n\n      target.addConstraint.apply(target, toConsumableArray(constraints));\n      return target;\n    }\n  }, {\n    key: '$exact',\n    value: function $exact(type) {\n      var target = new ObjectType(this);\n      type = type.unwrap();\n      if (Array.isArray(type.callProperties)) {\n        var _target$callPropertie2;\n\n        (_target$callPropertie2 = target.callProperties).push.apply(_target$callPropertie2, toConsumableArray(type.callProperties));\n      }\n      if (Array.isArray(type.indexers)) {\n        var _target$indexers2;\n\n        (_target$indexers2 = target.indexers).push.apply(_target$indexers2, toConsumableArray(type.indexers));\n      }\n      if (Array.isArray(type.properties)) {\n        var _target$properties;\n\n        (_target$properties = target.properties).push.apply(_target$properties, toConsumableArray(type.properties));\n      }\n      target.exact = true;\n      return target;\n    }\n  }, {\n    key: '$diff',\n    value: function $diff(aType, bType) {\n      var target = new $DiffType(this);\n      target.aType = aType;\n      target.bType = bType;\n      return target;\n    }\n  }, {\n    key: '$flowFixMe',\n    value: function $flowFixMe() {\n      return new $FlowFixMeType(this);\n    }\n  }, {\n    key: '$keys',\n    value: function $keys(type) {\n      var target = new $KeysType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$objMap',\n    value: function $objMap(object, mapper) {\n      var target = new $ObjMapType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$objMapi',\n    value: function $objMapi(object, mapper) {\n      var target = new $ObjMapiType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$propertyType',\n    value: function $propertyType(object, property) {\n      var target = new $PropertyType(this);\n      target.object = object;\n      if (property instanceof Type) {\n        var unwrapped = property.unwrap();\n        target.property = unwrapped.value;\n      } else {\n        target.property = property;\n      }\n      return target;\n    }\n  }, {\n    key: '$shape',\n    value: function $shape(type) {\n      var target = new $ShapeType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$subtype',\n    value: function $subtype(type) {\n      var target = new $SubType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$supertype',\n    value: function $supertype(type) {\n      var target = new $SuperType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$tupleMap',\n    value: function $tupleMap(tuple, mapper) {\n      var target = new $TupleMapType(this);\n      target.tuple = tuple;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$values',\n    value: function $values(type) {\n      var target = new $ValuesType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'Class',\n    value: function Class(instanceType) {\n      var target = new ClassType(this);\n      target.instanceType = instanceType;\n      return target;\n    }\n  }, {\n    key: 'TypeParametersSymbol',\n\n\n    // Issue 252\n    get: function get$$1() {\n      return TypeParametersSymbol;\n    }\n  }]);\n  return TypeContext;\n}();\n\nvar globalContext$1 = void 0;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext$1 = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n} else {\n  globalContext$1 = new TypeContext();\n  registerPrimitiveTypes(globalContext$1);\n  registerBuiltinTypeConstructors(globalContext$1);\n  registerTypePredicates(globalContext$1);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext$1;\n  }\n}\n\nvar globalContext$2 = globalContext$1;\n\nfunction v(thing) {\n  return { value: thing };\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext$2) {\n  Object.defineProperties(globalContext$2, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExports),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration)\n  });\n}\n\nreturn globalContext$2;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(4);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ts-runtime.lib.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4ae3b360737cba592af8","import * as t from 'flow-runtime';\n\nconst voidType = t.void;\nconst typeOf = t.typeOf;\n\nt.undef = () => {\n  return voidType.bind(t)();\n}\n\nt.nostrict = (...args: any[]) => {\n  return t.union(...args, t.null(), t.undef());\n}\n\nt.void = () => {\n  return t.union(t.null(), t.undef());\n}\n\nt.n = (...args: any[]) => {\n  return t.nullable(...args);\n}\n\nt.enum = (...args: any[]) => {\n  return t.union(...args);\n}\n\nt.enumMember = (arg: any) => {\n  return t.literal(arg);\n}\n\nt.enumRef = (...args: any[]) => {\n  return t.typeOf(...args);\n}\n\nt.typeOf = (input: any, declaration = false) => {\n  if (declaration && typeof input === 'string') {\n    input = t.get(input);\n\n    if (input) {\n      if (input.typeName === 'ClassDeclaration') {\n        return t.Class(input);\n      }\n\n      return input;\n    }\n  }\n\n  return typeOf.bind(t)(input);\n}\n\nexport const lib = t;\nexport default t;\n\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n\n\n\n// WEBPACK FOOTER //\n// /Users/fabian/Development/ts-runtime-update/node_modules/source-map-loader!/Users/fabian/Development/ts-runtime-update/src/lib/index.ts","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeJSONError.js","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}\n\n\n// WEBPACK FOOTER //\n// ../src/cyclic.js","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/Validation.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = resolvePath(input, path);\n    const actualType = context.typeOf(actual).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n    const actualAsString = makeString(actual);\n\n    if (typeof actualAsString === 'string') {\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n    } else {\n      collected.push(\n        `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`\n      );\n    }\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`);\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\nfunction makeString(value: *) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // @flowIssue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        }\n        catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeTypeError.js","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/makeError.js","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeParameterApplication,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/compareTypes.js","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/getErrorMessage.js","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/typeConstraints.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from \"./FlowIntoType\";\nimport TypeAlias from './TypeAlias';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    } else if (recorded) {\n      return recorded.accepts(input);\n    } else if (boundOrDefault) {\n      if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n        return true;\n      } else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameter.js","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/invariant.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ParameterizedClassDeclaration.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  setProperty (key: string | number, value: Type<*>, optional: boolean = false) {\n    const { context, properties } = this;\n    const { length } = properties;\n    const newProp = new ObjectTypeProperty(context);\n    newProp.key = key;\n    newProp.value = value;\n    newProp.optional = optional;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        properties[i] = newProp;\n        return;\n      }\n    }\n    properties.push(newProp);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    if (result && this.exact) {\n      result = acceptsExact(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/IntersectionType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedTypeAlias.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedFunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeTDZ.js","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeReactPropTypes.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeWarningMessage.js","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeUnion.js","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/classDecorators.js","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/annotateValue.js","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/ClassType.js","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction v (thing) {\n  return { value: thing }\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext) {\n  Object.defineProperties(globalContext, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExportsDeclaration),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration),\n  })\n}\n\nexport default globalContext;\n\n\n\n// WEBPACK FOOTER //\n// ../src/index.cjs.js","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;\n\n\n// WEBPACK FOOTER //\n// ../src/primitiveTypes.js","export default require(\"regenerator-runtime\");\n\n\n\n// WEBPACK FOOTER //\n// ../../../node_modules/rollup-regenerator-runtime/regenerator/index.js","/* @flow */\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n}\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/RuntimeTypeError.js","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/Type.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/AnyType.js","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorMessages.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/TupleType.js","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ArrayType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/EmptyType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ExistentialType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameterApplication.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeAlias.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FlowIntoType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeRestParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeReturn.js","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\n\n\n// WEBPACK FOOTER //\n// ../src/symbols.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GeneratorType.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeConstructor.js","/* @flow */\n\nimport TypeConstructor from \"./TypeConstructor\";\n\nimport type Type from \"./Type\";\nimport compareTypes from \"../compareTypes\";\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, { ErrorTuple, IdentifierPath } from \"../Validation\";\n\nexport default class GenericType extends TypeConstructor {\n  typeName: string = \"GenericType\";\n\n  *errors(\n    validation: Validation<any>,\n    path: IdentifierPath,\n    input: any\n  ): Generator<ErrorTuple, void, void> {\n    const { name, impl } = this;\n    if (!(input instanceof impl)) {\n      yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n    }\n  }\n\n  accepts<P>(input: any, ...typeInstances: Type<P>[]): boolean {\n    const { impl } = this;\n    return input instanceof impl;\n  }\n\n  compareWith<P>(input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const { context, impl } = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    } else if (\n      input instanceof GenericType &&\n      (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))\n    ) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  unwrap<P>(...typeInstances: Type<P>[]) {\n    const { context, impl } = this;\n    if (typeof impl !== \"function\") {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    } else {\n      return this;\n    }\n  }\n\n  inferTypeParameters<P>(input: any): Type<P>[] {\n    return [];\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/GenericType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullLiteralType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/VoidType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullableType.js","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeProperty.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeIndexer.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeCallProperty.js","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/Declaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/VarDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/TypeDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleExportsDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    if (superProps == null) {\n      return bodyProps;\n    }\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ClassDeclaration.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/PartialType.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ExtendsDeclaration.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/MixedType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumericLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumberType.js","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/RefinementType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolType.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ThisType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeBox.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeReference.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/UnionType.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;\n\n\n// WEBPACK FOOTER //\n// ../src/TypeInferrer.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$DiffType.js","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$FlowFixMeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$KeysType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapiType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$PropertyType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ShapeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SubType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SuperType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$TupleMapType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $ValuesType<T: {}> extends Type<$Values<T>> {\n  typeName: string = '$ValuesType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return;\n      }\n    }\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = properties[i].value.toString();\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Values<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      values[i] = property.value;\n    }\n    return context.union(...values);\n  }\n\n  toString (): string {\n    return `$Values<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ValuesType.js","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  $ValuesType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  compareWith?: (Type<any>) => -1 | 0 | 1;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters, compareWith}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n    if (typeof compareWith === 'function') {\n      target.compareWith = compareWith;\n    }\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  spread <T> (...types: Type<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      if (Array.isArray(type.callProperties)) {\n        target.callProperties.push(...type.callProperties);\n      }\n      if (Array.isArray(type.indexers)) {\n        target.indexers.push(...type.indexers);\n      }\n      if (Array.isArray(type.properties)) {\n        for (let j = 0; j < type.properties.length; j++) {\n          const prop = type.properties[j];\n          invariant(prop instanceof ObjectTypeProperty);\n          target.setProperty(prop.key, prop.value, prop.optional);\n        }\n      }\n    }\n    return target;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n  $exact <T> (type: Type<T>): ObjectType<T> {\n    const target = new ObjectType(this);\n    type = type.unwrap();\n    if (Array.isArray(type.callProperties)) {\n      target.callProperties.push(...type.callProperties);\n    }\n    if (Array.isArray(type.indexers)) {\n      target.indexers.push(...type.indexers);\n    }\n    if (Array.isArray(type.properties)) {\n      target.properties.push(...type.properties);\n    }\n    target.exact = true;\n    return target;\n  }\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $values <T: {}> (type: Type<T>): $ValuesType<T> {\n    const target = new $ValuesType(this);\n    target.type = type;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/TypeContext.js","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;\n\n\n// WEBPACK FOOTER //\n// ../src/globalContext.js","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerPrimitiveTypes.js","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerBuiltins.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null\n        && (typeof input === 'object' || typeof input === 'function')\n        && typeof input.then === 'function'\n        ;\n    }\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/registerTypePredicates.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/fabian/Development/ts-runtime-update/node_modules/regenerator-runtime/runtime-module.js\n// module id = 3\n// module chunks = 0","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/fabian/Development/ts-runtime-update/node_modules/regenerator-runtime/runtime.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}