{"version":3,"sources":["webpack:///ts-runtime.lib.js","webpack:///webpack/bootstrap 6cf55abbc1b919903bb7","webpack:///(webpack)/buildin/global.js","webpack:///../src/errorReporting/makeJSONError.js","webpack:///../src/cyclic.js","webpack:///../src/Validation.js","webpack:///../src/errorReporting/makeTypeError.js","webpack:///../src/makeError.js","webpack:///../src/compareTypes.js","webpack:///../src/getErrorMessage.js","webpack:///../src/types/TypeParameter.js","webpack:///../src/invariant.js","webpack:///../src/typeConstraints.js","webpack:///../src/declarations/ModuleDeclaration.js","webpack:///../src/declarations/ParameterizedClassDeclaration.js","webpack:///../src/types/ObjectType.js","webpack:///../src/types/IntersectionType.js","webpack:///../src/types/ParameterizedTypeAlias.js","webpack:///../src/types/ParameterizedFunctionType.js","webpack:///../src/types/TypeTDZ.js","webpack:///../src/makeReactPropTypes.js","webpack:///../src/errorReporting/makeWarningMessage.js","webpack:///../src/makeUnion.js","webpack:///../src/classDecorators.js","webpack:///../src/annotateValue.js","webpack:///../src/flowTypes/ClassType.js","webpack:///../src/index.cjs.js","webpack:///../src/primitiveTypes.js","webpack:///../~/rollup-regenerator-runtime/regenerator/index.js","webpack:///../src/errorReporting/RuntimeTypeError.js","webpack:///../src/types/Type.js","webpack:///../src/types/AnyType.js","webpack:///../src/errorMessages.js","webpack:///../src/types/TupleType.js","webpack:///../src/types/ArrayType.js","webpack:///../src/types/BooleanLiteralType.js","webpack:///../src/types/BooleanType.js","webpack:///../src/types/EmptyType.js","webpack:///../src/types/ExistentialType.js","webpack:///../src/types/FlowIntoType.js","webpack:///../src/types/FunctionTypeRestParam.js","webpack:///../src/types/FunctionTypeParam.js","webpack:///../src/types/FunctionTypeReturn.js","webpack:///../src/symbols.js","webpack:///../src/types/FunctionType.js","webpack:///../src/types/GeneratorType.js","webpack:///../src/types/TypeParameterApplication.js","webpack:///../src/types/TypeConstructor.js","webpack:///../src/types/GenericType.js","webpack:///../src/types/NullLiteralType.js","webpack:///../src/types/VoidType.js","webpack:///../src/types/NullableType.js","webpack:///../src/types/ObjectTypeProperty.js","webpack:///../src/types/ObjectTypeIndexer.js","webpack:///../src/types/ObjectTypeCallProperty.js","webpack:///../src/declarations/Declaration.js","webpack:///../src/declarations/VarDeclaration.js","webpack:///../src/declarations/TypeDeclaration.js","webpack:///../src/declarations/ModuleExportsDeclaration.js","webpack:///../src/declarations/ClassDeclaration.js","webpack:///../src/types/PartialType.js","webpack:///../src/declarations/ExtendsDeclaration.js","webpack:///../src/types/MixedType.js","webpack:///../src/types/TypeAlias.js","webpack:///../src/types/NumericLiteralType.js","webpack:///../src/types/NumberType.js","webpack:///../src/types/RefinementType.js","webpack:///../src/types/StringLiteralType.js","webpack:///../src/types/StringType.js","webpack:///../src/types/SymbolLiteralType.js","webpack:///../src/types/SymbolType.js","webpack:///../src/types/ThisType.js","webpack:///../src/types/TypeBox.js","webpack:///../src/types/TypeReference.js","webpack:///../src/types/UnionType.js","webpack:///../src/TypeInferrer.js","webpack:///../src/flowTypes/$DiffType.js","webpack:///../src/flowTypes/$FlowFixMeType.js","webpack:///../src/flowTypes/$KeysType.js","webpack:///../src/flowTypes/$ObjMapiType.js","webpack:///../src/flowTypes/$ObjMapType.js","webpack:///../src/flowTypes/$PropertyType.js","webpack:///../src/flowTypes/$ShapeType.js","webpack:///../src/flowTypes/$SubType.js","webpack:///../src/flowTypes/$SuperType.js","webpack:///../src/flowTypes/$TupleMapType.js","webpack:///../src/TypeContext.js","webpack:///../src/globalContext.js","webpack:///../src/registerPrimitiveTypes.js","webpack:///../src/registerBuiltins.js","webpack:///../src/registerTypePredicates.js","webpack:///./~/regenerator-runtime/runtime-module.js","webpack:///./~/regenerator-runtime/runtime.js","webpack:///./src/lib/index.ts"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","g","this","Function","eval","e","global","factory","makeJSONError","validation","hasErrors","input","context","errors","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","_ref","_ref2","slicedToArray","path","message","expectedType","expected","toString","actual","typeOf","resolvePath","field","stringifyPath","concat","pointer","join","push","err","return","inValidationCycle","type","tracked","cyclicValidation","weakSetHas","startValidationCycle","WeakSet","set","weakSetAdd","endValidationCycle","weakSetDelete","inToStringCycle","cyclicToString","has","startToStringCycle","add","endToStringCycle","delete","weakset","length","parts","Array","part","validIdentifierOrAccessor","test","String","subject","Map","matchPath","candidate","makeTypeError","prefix","collected","RuntimeTypeError","trim","delimiter","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","getErrorMessage","key","_len","arguments","params","_key","errorMessages","replace","flowIntoTypeParameter","typeParameter","existing","FlowIntoSymbol","target","invariant","error","Error","captureStackTrace","addConstraints","_subject$constraints","constraints","apply","toConsumableArray","collectConstraintErrors","_len2","_key2","constraint","violation","_regeneratorRuntime","wrap","_context","prev","stop","_marked$1","constraintsAccept","_len3","_key3","indent","lines","split","getPartial","parent","bodyCreator","partial","PartialType","body","isArray","class","shapeID","typeParameters","_len6","typeInstances","_key6","limit","Math","min","typeInstance","bound","intersect","acceptsCallProperties","callProperties","accepts","compareTypeCallProperties","inputCallProperties","identicalCount","loop","callProperty","j","inputCallProperty","acceptsWithIndexers","properties","indexers","seen","indexOf","indexer","acceptsKey","acceptsValue","compareTypeWithIndexers","inputIndexers","inputProperties","isGreater","inputProperty","inputIndexer","acceptsWithoutIndexers","acceptsExact","compareTypeWithoutIndexers","collectErrorsWithIndexers","_i5","_context2","delegateYield","t1","keys","t2","abrupt","_marked","collectErrorsWithoutIndexers","_context3","collectErrorsExact","_context4","t0","getPropertyIndex","mergeProperties","source","typeProp","index","typeCreator","_len7","_key7","function","_len5","_key5","getRevealed","container","RevealedValue","reveal","warnedInstances","RevealedName","emitWarningMessage","warnedInstances$2","mixed","Type","ref","makeReactPropTypes","objectType","output","props","propName","componentName","makeWarningMessage","makeUnion","types","merged","UnionType","mergeUnionTypes","union","aTypes","bTypes","bType","aType","makePropertyDescriptor","typeSource","propertyName","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","constructor","resolveType","receiver","safeName","className","initializer","config","writable","objectWithoutProperties","propertyPath","_extends","check","assert","warn","originalSetter","annotateValue","TypeSymbol","_ret","v","_typeof","checkGenericType","impl","isPrototypeOf","annotation","getAnnotation","checkType","globalContext","primitiveTypes","obj","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","protoProps","staticProps","assign","inherits","subClass","superClass","create","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","arr2","from","WeakMap","Validation","cyclic","didClear","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_errors","_temp","_this","args","getPrototypeOf","_TypeError","typeName","mark","_Type","ERR_CONSTRAINT_VIOLATION","ERR_EXPECT_ARRAY","ERR_EXPECT_TRUE","ERR_EXPECT_FALSE","ERR_EXPECT_BOOLEAN","ERR_EXPECT_EMPTY","ERR_EXPECT_EXACT_VALUE","ERR_EXPECT_CALLABLE","ERR_EXPECT_CLASS","ERR_EXPECT_FUNCTION","ERR_EXPECT_GENERATOR","ERR_EXPECT_ITERABLE","ERR_EXPECT_ARGUMENT","ERR_EXPECT_RETURN","ERR_EXPECT_N_ARGUMENTS","ERR_EXPECT_INSTANCEOF","ERR_EXPECT_KEY_TYPE","ERR_EXPECT_NULL","ERR_EXPECT_NUMBER","ERR_EXPECT_OBJECT","ERR_EXPECT_PROMISE","ERR_EXPECT_STRING","ERR_EXPECT_SYMBOL","ERR_EXPECT_THIS","ERR_EXPECT_VOID","ERR_INVALID_DATE","ERR_MISSING_PROPERTY","ERR_NO_INDEXER","ERR_NO_UNION","ERR_UNKNOWN_KEY","TupleType","checkPredicate","inputTypes","ArrayType","elementType","inCycle","startCycle","endCycle","BooleanLiteralType","BooleanType","EmptyType","boundOrDefault","recorded","default","finish","withBinding","id","defaultType","hasError","_hasError","_error","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","param","annotationParam","_param","acceptsType","any","inputReturnType","returnTypeResult","inputParams","inputParam","rest","paramsLength","argsLength","_len4","_key4","empty","GeneratorType","isValid","throw","yieldType","nextType","TypeParameterApplication","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","TypeConstructor","GenericType","_TypeConstructor","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","static","isStatic","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","_Declaration","TypeDeclaration","_typeAlias","typeAlias","addConstraint","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declaration","declarations","moduleName","slice","innerContext","import","ModuleExports","ClassDeclaration","errorPath","errorMessage","isSuperClassOf","current","withDeclaration","superClassName","bodyProps","superProps","seenStatic","expand","ParameterizedClassDeclaration","ExtendsDeclaration","ObjectType","exact","getIndexer","hasIndexer","hasCallProperties","IntersectionType","hasConstraints","NumericLiteralType","NumberType","ParameterizedTypeAlias","_TypeAlias","identifier","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","RefinementType","StringLiteralType","JSON","stringify","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","warnedInstances$1","warnedMissing","TypeReference","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","null","void","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","$DiffType","$FlowFixMeType","$KeysType","literal","$ObjMapiType","mapper","applied","invoke","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","ClassType","instanceType","warnedInvalidReferences","TypeContext","mode","TypeInferrer","Class","inferrer","infer","propertyNames","fromParent","getPredicate","predicate","_this2","Boolean","annotate","_target","nameRegistry","var","moduleRegistry","_moduleName$split","_moduleName$split2","head","handlerRegistry","instancePrototype","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","_target3","tail","unshift","_body$properties","_target4","_body","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_len12","_key12","_len13","_key13","tdz","_len14","_key14","_target5","_validation$path","console","_len15","_key15","clauses","pop","pattern","_len16","_key16","tests","clause","t","wrappedIterator","_len17","_key17","_$PropertyType","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","globalContext$1","freeze","declareTypeConstructor","Date","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref5","_ref6","findKey","Set","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","setPredicate","then","globalContext$2","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","makeInvokeMethod","tryCatch","arg","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","AsyncIterator","resolve","reject","record","hasOwn","__await","enqueue","callInvokeWithMethodAndArg","previousPromise","process","domain","bind","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","GenStateSuspendedYield","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","iteratorSymbol","Op","$Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","reverse","skipTempReset","charAt","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","catch","thrown","voidType","declare","decorate","undef","nostrict","nullable","enum","enumMember","enumRef"],"mappings":"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VI,IAAK,SACLhH,MAAO0I,GAAoBiM,KAAK,QAAS7S,G+Br1BlCJ,EAA6BkB,EAAsBhB,G/Bs1BxD,MAAO8G,IAAoBC,KAAK,SAAiBC,GAC/C,OACE,OAAQA,EAASC,KAAOD,EAASrG,MAC/B,IAAK,GACL,IAAK,MACH,MAAOqG,GAASE,SAGrBhH,EAAQX,UAGb6F,IAAK,UACLhH,MAAO,S+B91BA4B,G/B+1BL,O+B91BK,K/Bi2BPoF,IAAK,cACLhH,MAAO,S+B/1BI4B,G/Bg2BT,M+B/1BK,M/Bk2BPoF,IAAK,WACLhH,MAAO,WACL,M+Bh2BK,S/Bm2BPgH,IAAK,SACLhH,MAAO,WACL,OACE0U,S+Bj2BQvT,KAAKuT,c/Bq2BZ9N,G+B33B4B0H,ICJ/BjH,IhCm4BJwN,yBgCl4B0B,wBhCm4B1BC,iBgCl4BkB,mBhCm4BlBC,gBgCl4BiB,ehCm4BjBC,iBgCl4BkB,gBhCm4BlBC,mBgCl4BoB,wBhCm4BpBC,iBgCl4BkB,gBhCm4BlBC,uBgCl4BwB,qBhCm4BxBC,oBgCl4BqB,mBhCm4BrBC,iBgCl4BkB,wBhCm4BlBC,oBgCl4BqB,qBhCm4BrBC,qBgCl4BsB,+BhCm4BtBC,oBgCl4BqB,mBhCm4BrBC,oBgCl4BqB,4BhCm4BrBC,kBgCl4BmB,8BhCm4BnBC,uBgCl4BwB,0BhCm4BxBC,sBgCl4BuB,4BhCm4BvBC,oBgCl4BqB,mBhCm4BrBC,gBgCl4BiB,ehCm4BjBC,kBgCl4BmB,mBhCm4BnBC,kBgCl4BmB,oBhCm4BnBC,mBgCl4BoB,wBhCm4BpBC,kBgCl4BmB,mBhCm4BnBC,kBgCl4BmB,mBhCm4BnBC,gBgCl4BiB,uBhCm4BjBC,gBgCl4BiB,oBhCm4BjBC,iBgCl4BkB,uBhCm4BlBC,qBgCl4BsB,4BhCm4BtBC,egCl4BgB,4ChCm4BhBC,agCl4Bc,qBhCm4BdC,gBgCl4BiB,oCCzBEC,ejCg7BnB,QAASA,KACP,GAAIlU,GAEA4R,EAAOC,EAAOnD,CAElBY,IAAe5Q,KAAMwV,EAErB,KAAK,GAAI1P,GAAOC,UAAUnC,OAAQwP,EAAOtP,MAAMgC,GAAOG,EAAO,EAAGA,EAAOH,EAAMG,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","file":"ts-runtime.lib.js","sourcesContent":["window[\"t\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global['flow-runtime'] = factory());\n}(this, (function () { 'use strict';\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nvar primitiveTypes = {};\n\nvar _regeneratorRuntime = __webpack_require__(2);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction makeJSONError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var errors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : null;\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n      var field = stringifyPath(validation.path.concat(path));\n\n      var pointer = '/' + path.join('/');\n\n      errors.push({\n        pointer: pointer,\n        field: field,\n        message: message,\n        expected: expected,\n        actual: actual\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Tracks whether we're in validation of cyclic objects.\nvar cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\n\n\nvar cyclicToString = new WeakSet();\n\nfunction inValidationCycle(type, input) {\n  try {\n    var tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    } else {\n      return weakSetHas(tracked, input);\n    }\n  } catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nfunction startValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nfunction endValidationCycle(type, input) {\n  var tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nfunction inToStringCycle(type) {\n  return cyclicToString.has(type);\n}\n\nfunction startToStringCycle(type) {\n  cyclicToString.add(type);\n}\n\nfunction endToStringCycle(type) {\n  cyclicToString.delete(type);\n}\n\nfunction weakSetHas(weakset, value) {\n  try {\n    return weakset.has(value);\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction weakSetAdd(weakset, value) {\n  try {\n    weakset.add(value);\n  } catch (e) {}\n}\n\nfunction weakSetDelete(weakset, value) {\n  try {\n    weakset.delete(value);\n  } catch (e) {}\n}\n\nvar validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nvar Validation = function () {\n  function Validation(context, input) {\n    classCallCheck(this, Validation);\n    this.path = [];\n    this.prefix = '';\n    this.errors = [];\n    this.cyclic = new WeakMap();\n\n    this.context = context;\n    this.input = input;\n  }\n\n  // Tracks whether we're in validation of cyclic objects.\n\n\n  createClass(Validation, [{\n    key: 'inCycle',\n    value: function inCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        return false;\n      } else {\n        return weakSetHas(tracked, input);\n      }\n    }\n  }, {\n    key: 'startCycle',\n    value: function startCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (!tracked) {\n        tracked = new WeakSet();\n        this.cyclic.set(type, tracked);\n      }\n      weakSetAdd(tracked, input);\n    }\n  }, {\n    key: 'endCycle',\n    value: function endCycle(type, input) {\n      var tracked = this.cyclic.get(type);\n      if (tracked) {\n        weakSetDelete(tracked, input);\n      }\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors(path) {\n      if (path) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var candidate = _ref2[0];\n\n            if (matchPath(path, candidate)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        return this.errors.length > 0;\n      }\n    }\n  }, {\n    key: 'addError',\n    value: function addError(path, expectedType, message) {\n      this.errors.push([path, message, expectedType]);\n      return this;\n    }\n  }, {\n    key: 'clearError',\n    value: function clearError(path) {\n      var didClear = false;\n      if (path) {\n        var _errors = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var error = _step2.value;\n\n            if (matchPath(path, error[0])) {\n              didClear = true;\n            } else {\n              _errors.push(error);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.errors = _errors;\n      } else {\n        didClear = this.errors.length > 0;\n        this.errors = [];\n      }\n      return didClear;\n    }\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path) {\n      return _resolvePath(this.input, path);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return makeJSONError(this);\n    }\n  }]);\n  return Validation;\n}();\n\nfunction stringifyPath(path) {\n  if (!path.length) {\n    return 'Value';\n  }\n  var length = path.length;\n\n  var parts = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    } else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = '[' + String(part) + ']';\n    } else if (i > 0) {\n      parts[i] = '.' + String(part);\n    } else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nfunction _resolvePath(input, path) {\n  var subject = input;\n  var length = path.length;\n\n  for (var i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    var part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    } else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nfunction matchPath(path, candidate) {\n  var length = path.length;\n\n  if (length > candidate.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar RuntimeTypeError = function (_TypeError) {\n  inherits(RuntimeTypeError, _TypeError);\n\n  function RuntimeTypeError() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RuntimeTypeError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RuntimeTypeError.__proto__ || Object.getPrototypeOf(RuntimeTypeError)).call.apply(_ref, [this].concat(args))), _this), _this.name = \"RuntimeTypeError\", _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return RuntimeTypeError;\n}(TypeError);\n\nvar delimiter = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeTypeError(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var prefix = validation.prefix,\n      input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actual + '\\n');\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (prefix) {\n    return new RuntimeTypeError(prefix.trim() + ' ' + collected.join(delimiter));\n  } else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\nfunction makeError(expected, input) {\n  var context = expected.context;\n\n  var validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\n\n\nfunction compareTypes(a, b) {\n\n  var result = void 0;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  } else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  } else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  } else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  } else {\n    return result;\n  }\n}\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nvar Type = function () {\n  function Type(context) {\n    classCallCheck(this, Type);\n    this.typeName = 'Type';\n\n    this.context = context;\n  }\n\n  createClass(Type, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var validation = new Validation(this.context, input);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.errors(validation, [], input)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var error = _step.value;\n          // eslint-disable-line no-unused-vars\n          return false;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsType',\n    value: function acceptsType(input) {\n      if (compareTypes(this, input) === -1) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return -1;\n    }\n  }, {\n    key: 'assert',\n    value: function assert(input) {\n      var error = makeError(this, input);\n      if (error) {\n        if (typeof Error.captureStackTrace === 'function') {\n          Error.captureStackTrace(error, this.assert);\n        }\n        throw error;\n      }\n      return input;\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Type';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return Type;\n}();\n\nvar AnyType = function (_Type) {\n  inherits(AnyType, _Type);\n\n  function AnyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AnyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AnyType.__proto__ || Object.getPrototypeOf(AnyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'AnyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AnyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'any';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return AnyType;\n}(Type);\n\nvar errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exists on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nfunction getErrorMessage(key) {\n  for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, function (m, i) {\n      return String(params[i]);\n    });\n  } else {\n    return message;\n  }\n}\n\nvar TupleType = function (_Type) {\n  inherits(TupleType, _Type);\n\n  function TupleType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TupleType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TupleType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, context, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < length)) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path.concat(i), input[i]), 't0', 10);\n\n            case 10:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 13:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n      var context = this.context;\n\n\n      if (!context.checkPredicate('Array', input) || input.length < length) {\n        return false;\n      }\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof TupleType)) {\n        return -1;\n      }\n      var types = this.types;\n      var inputTypes = input.types;\n      if (inputTypes.length < types.length) {\n        return -1;\n      }\n      var isGreater = false;\n      for (var i = 0; i < types.length; i++) {\n        var result = compareTypes(types[i], inputTypes[i]);\n        if (result === 1) {\n          isGreater = true;\n        } else if (result === -1) {\n          return -1;\n        }\n      }\n      if (types.length < inputTypes.length) {\n        return 0;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.types.join(', ') + ']';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return TupleType;\n}(Type);\n\nvar ArrayType = function (_Type) {\n  inherits(ArrayType, _Type);\n\n  function ArrayType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ArrayType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ArrayType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ArrayType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var context, elementType, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              context = this.context;\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              validation.startCycle(this, input);\n              elementType = this.elementType;\n              length = input.length;\n              i = 0;\n\n            case 11:\n              if (!(i < length)) {\n                _context.next = 16;\n                break;\n              }\n\n              return _context.delegateYield(elementType.errors(validation, path.concat(i), input[i]), 't0', 13);\n\n            case 13:\n              i++;\n              _context.next = 11;\n              break;\n\n            case 16:\n              validation.endCycle(this, input);\n\n            case 17:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n      var elementType = this.elementType;\n      var length = input.length;\n\n      for (var i = 0; i < length; i++) {\n        if (!elementType.accepts(input[i])) {\n          endValidationCycle(this, input);\n          return false;\n        }\n      }\n      endValidationCycle(this, input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var elementType = this.elementType;\n\n      if (input instanceof TupleType) {\n        var types = input.types;\n\n        for (var i = 0; i < types.length; i++) {\n          var result = compareTypes(elementType, types[i]);\n          if (result === -1) {\n            return -1;\n          }\n        }\n        return 1;\n      } else if (input instanceof ArrayType) {\n        return compareTypes(elementType, input.elementType);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var elementType = this.elementType;\n\n      if (inToStringCycle(this)) {\n        if (typeof elementType.name === 'string') {\n          return 'Array<$Cycle<' + elementType.name + '>>';\n        } else {\n          return 'Array<$Cycle<Object>>';\n        }\n      }\n      startToStringCycle(this);\n      var output = 'Array<' + elementType.toString() + '>';\n      endToStringCycle(this);\n      return output;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        elementType: this.elementType\n      };\n    }\n  }]);\n  return ArrayType;\n}(Type);\n\nvar BooleanLiteralType = function (_Type) {\n  inherits(BooleanLiteralType, _Type);\n\n  function BooleanLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanLiteralType.__proto__ || Object.getPrototypeOf(BooleanLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== this.value)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.value ? 'true' : 'false';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        type: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return BooleanLiteralType;\n}(Type);\n\nvar BooleanType = function (_Type) {\n  inherits(BooleanType, _Type);\n\n  function BooleanType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, BooleanType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = BooleanType.__proto__ || Object.getPrototypeOf(BooleanType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'BooleanType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(BooleanType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'boolean')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'boolean';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof BooleanLiteralType) {\n        return 1;\n      } else if (input instanceof BooleanType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'boolean';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return BooleanType;\n}(Type);\n\nvar EmptyType = function (_Type) {\n  inherits(EmptyType, _Type);\n\n  function EmptyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, EmptyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EmptyType.__proto__ || Object.getPrototypeOf(EmptyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'EmptyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(EmptyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return false; // empty types accepts nothing.\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof EmptyType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'empty';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return EmptyType;\n}(Type);\n\nvar ExistentialType = function (_Type) {\n  inherits(ExistentialType, _Type);\n\n  function ExistentialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExistentialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExistentialType.__proto__ || Object.getPrototypeOf(ExistentialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExistentialType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExistentialType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '*';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ExistentialType;\n}(Type);\n\nvar FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\n\nvar TypeParameter = function (_Type) {\n  inherits(TypeParameter, _Type);\n\n  function TypeParameter() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  createClass(TypeParameter, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var boundOrDefault, recorded, context, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              boundOrDefault = this.bound || this.default;\n              recorded = this.recorded, context = this.context;\n\n              if (!(boundOrDefault instanceof FlowIntoType)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(boundOrDefault.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 7:\n              if (!recorded) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.delegateYield(recorded.errors(validation, path, input), 't1', 9);\n\n            case 9:\n              return _context.abrupt('return');\n\n            case 12:\n              if (!boundOrDefault) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType')) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 21;\n              _iterator = boundOrDefault.errors(validation, path, input)[Symbol.iterator]();\n\n            case 23:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 31;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 28;\n              return error;\n\n            case 28:\n              _iteratorNormalCompletion = true;\n              _context.next = 23;\n              break;\n\n            case 31:\n              _context.next = 37;\n              break;\n\n            case 33:\n              _context.prev = 33;\n              _context.t2 = _context['catch'](21);\n              _didIteratorError = true;\n              _iteratorError = _context.t2;\n\n            case 37:\n              _context.prev = 37;\n              _context.prev = 38;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 40:\n              _context.prev = 40;\n\n              if (!_didIteratorError) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 43:\n              return _context.finish(40);\n\n            case 44:\n              return _context.finish(37);\n\n            case 45:\n              if (!hasErrors) {\n                _context.next = 47;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 47:\n\n              this.recorded = context.typeOf(input);\n\n            case 48:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[21, 33, 37, 45], [38,, 40, 44]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded,\n          context = this.context;\n\n      if (boundOrDefault instanceof FlowIntoType) {\n        // We defer to the other type parameter so that values from this\n        // one can flow \"upwards\".\n        return boundOrDefault.accepts(input);\n      } else if (recorded) {\n        return recorded.accepts(input);\n      } else if (boundOrDefault) {\n        if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n          return true;\n        } else if (!boundOrDefault.accepts(input)) {\n          return false;\n        }\n      }\n\n      this.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (input instanceof TypeParameter) {\n        // We don't need to check for `recorded` or `bound` fields\n        // because the input has already been unwrapped, so\n        // if we got a type parameter it must be totally generic and\n        // we treat it like Any.\n        return 1;\n      } else if (recorded) {\n        return compareTypes(recorded, input);\n      } else if (boundOrDefault) {\n        return compareTypes(boundOrDefault, input);\n      } else {\n        // A generic type parameter accepts any input.\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var boundOrDefault = this.bound || this.default;\n      var recorded = this.recorded;\n\n      if (recorded) {\n        return recorded.unwrap();\n      } else if (boundOrDefault) {\n        return boundOrDefault.unwrap();\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      var id = this.id,\n          bound = this.bound,\n          defaultType = this.default;\n\n      if (withBinding) {\n        if (defaultType) {\n          return id + ' = ' + defaultType.toString();\n        } else if (bound) {\n          return id + ': ' + bound.toString();\n        }\n      }\n      return id;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        bound: this.bound,\n        recorded: this.recorded\n      };\n    }\n  }]);\n  return TypeParameter;\n}(Type);\n\nfunction flowIntoTypeParameter(typeParameter) {\n  var existing = typeParameter[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  var target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  typeParameter[FlowIntoSymbol] = target;\n  return target;\n}\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\n\nvar FlowIntoType = function (_Type) {\n  inherits(FlowIntoType, _Type);\n\n  function FlowIntoType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FlowIntoType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FlowIntoType.__proto__ || Object.getPrototypeOf(FlowIntoType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FlowIntoType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FlowIntoType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var typeParameter, context, recorded, bound, hasError, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error, _hasError, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              typeParameter = this.typeParameter, context = this.context;\n              recorded = typeParameter.recorded, bound = typeParameter.bound;\n\n              if (!(bound instanceof FlowIntoType)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.delegateYield(bound.errors(validation, path, input), 't0', 4);\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              if (!recorded) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!bound) {\n                _context.next = 39;\n                break;\n              }\n\n              hasError = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 11;\n              _iterator = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 13:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 21;\n                break;\n              }\n\n              error = _step.value;\n              _context.next = 17;\n              return error;\n\n            case 17:\n              hasError = true;\n\n            case 18:\n              _iteratorNormalCompletion = true;\n              _context.next = 13;\n              break;\n\n            case 21:\n              _context.next = 27;\n              break;\n\n            case 23:\n              _context.prev = 23;\n              _context.t1 = _context['catch'](11);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 27:\n              _context.prev = 27;\n              _context.prev = 28;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 30:\n              _context.prev = 30;\n\n              if (!_didIteratorError) {\n                _context.next = 33;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 33:\n              return _context.finish(30);\n\n            case 34:\n              return _context.finish(27);\n\n            case 35:\n              if (!hasError) {\n                _context.next = 37;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 37:\n              _context.next = 45;\n              break;\n\n            case 39:\n              if (!recorded.accepts(input)) {\n                _context.next = 43;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 43:\n              // we need to make a union\n              typeParameter.recorded = context.union(recorded, context.typeOf(input));\n              return _context.abrupt('return');\n\n            case 45:\n              _context.next = 82;\n              break;\n\n            case 47:\n              if (!bound) {\n                _context.next = 82;\n                break;\n              }\n\n              if (!(bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType')) {\n                _context.next = 52;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 52:\n              _hasError = false;\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 56;\n              _iterator2 = bound.errors(validation, path, input)[Symbol.iterator]();\n\n            case 58:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 66;\n                break;\n              }\n\n              _error = _step2.value;\n              _context.next = 62;\n              return _error;\n\n            case 62:\n              _hasError = true;\n\n            case 63:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 58;\n              break;\n\n            case 66:\n              _context.next = 72;\n              break;\n\n            case 68:\n              _context.prev = 68;\n              _context.t2 = _context['catch'](56);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t2;\n\n            case 72:\n              _context.prev = 72;\n              _context.prev = 73;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n\n            case 75:\n              _context.prev = 75;\n\n              if (!_didIteratorError2) {\n                _context.next = 78;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 78:\n              return _context.finish(75);\n\n            case 79:\n              return _context.finish(72);\n\n            case 80:\n              if (!_hasError) {\n                _context.next = 82;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 82:\n\n              typeParameter.recorded = context.typeOf(input);\n\n            case 83:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[11, 23, 27, 35], [28,, 30, 34], [56, 68, 72, 80], [73,, 75, 79]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.accepts(input);\n      }\n      if (recorded) {\n        // we've already recorded a value for this type parameter\n        if (bound && !bound.accepts(input)) {\n          return false;\n        } else if (recorded.accepts(input)) {\n          // our existing type already permits this value, there's nothing to do.\n          return true;\n        } else {\n          // we need to make a union\n          typeParameter.recorded = context.union(recorded, context.typeOf(input));\n          return true;\n        }\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return true;\n        } else if (!bound.accepts(input)) {\n          return false;\n        }\n      }\n\n      typeParameter.recorded = context.typeOf(input);\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var typeParameter = this.typeParameter,\n          context = this.context;\n      var recorded = typeParameter.recorded,\n          bound = typeParameter.bound;\n\n      if (bound instanceof FlowIntoType) {\n        // We defer to the other type so that values from this\n        // one can flow \"upwards\".\n        return bound.compareWith(input);\n      }\n      if (recorded) {\n        if (bound && compareTypes(bound, input) === -1) {\n          return -1;\n        }\n        var result = compareTypes(recorded, input);\n        if (result === 0) {\n          // our existing type already permits this value, there's nothing to do.\n          return 0;\n        }\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, input);\n        return 1;\n      } else if (bound) {\n        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n          return 1;\n        }\n        var _result = compareTypes(bound, input);\n        if (_result === -1) {\n          return -1;\n        }\n      }\n\n      typeParameter.recorded = input;\n      return 0;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.typeParameter.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return this.typeParameter.toString(withBinding);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.typeParameter.toJSON();\n    }\n  }]);\n  return FlowIntoType;\n}(Type);\n\nvar FunctionTypeRestParam = function (_Type) {\n  inherits(FunctionTypeRestParam, _Type);\n\n  function FunctionTypeRestParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeRestParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeRestParam.__proto__ || Object.getPrototypeOf(FunctionTypeRestParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeRestParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeRestParam, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '...' + this.name + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeRestParam;\n}(Type);\n\nvar FunctionTypeParam = function (_Type) {\n  inherits(FunctionTypeParam, _Type);\n\n  function FunctionTypeParam() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeParam);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeParam.__proto__ || Object.getPrototypeOf(FunctionTypeParam)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeParam', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeParam, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              optional = this.optional, type = this.type;\n\n              if (!(optional && input === undefined)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              return _context.delegateYield(type.errors(validation, path, input), 't0', 6);\n\n            case 6:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var optional = this.optional,\n          type = this.type;\n\n      if (optional && input === undefined) {\n        return true;\n      } else {\n        return type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n        return compareTypes(this.type, input.type);\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var optional = this.optional,\n          type = this.type;\n\n      return '' + this.name + (optional ? '?' : '') + ': ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        optional: this.optional,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeParam;\n}(Type);\n\nvar FunctionTypeReturn = function (_Type) {\n  inherits(FunctionTypeReturn, _Type);\n\n  function FunctionTypeReturn() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionTypeReturn);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionTypeReturn.__proto__ || Object.getPrototypeOf(FunctionTypeReturn)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionTypeReturn', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionTypeReturn, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              return _context.delegateYield(type.errors(validation, path.concat('[[Return Type]]'), input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      return type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof FunctionTypeReturn) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return FunctionTypeReturn;\n}(Type);\n\nvar ParentSymbol = Symbol('Parent');\nvar NameRegistrySymbol = Symbol('NameRegistry');\nvar ModuleRegistrySymbol = Symbol('ModuleRegistry');\nvar CurrentModuleSymbol = Symbol('CurrentModule');\nvar TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nvar InferrerSymbol = Symbol('Inferrer');\n\n\nvar TypeSymbol = Symbol('Type');\nvar TypeParametersSymbol = Symbol('TypeParameters');\nvar TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\nvar FunctionType = function (_Type) {\n  inherits(FunctionType, _Type);\n\n  function FunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, FunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(FunctionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var annotation, returnType, params, i, param, annotationParam, context, _i, _param;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'function')) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              annotation = input[TypeSymbol];\n              returnType = this.returnType, params = this.params;\n\n              if (!annotation) {\n                _context.next = 29;\n                break;\n              }\n\n              if (annotation.params) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i = 0;\n\n            case 10:\n              if (!(i < params.length)) {\n                _context.next = 24;\n                break;\n              }\n\n              param = params[i];\n              annotationParam = annotation.params[i];\n\n              if (!(!annotationParam && !param.optional)) {\n                _context.next = 18;\n                break;\n              }\n\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              if (param.acceptsType(annotationParam)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 21;\n              return [path, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()), this];\n\n            case 21:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 24:\n              if (returnType.acceptsType(annotation.returnType)) {\n                _context.next = 27;\n                break;\n              }\n\n              _context.next = 27;\n              return [path, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()), this];\n\n            case 27:\n              _context.next = 32;\n              break;\n\n            case 29:\n              context = this.context;\n              // We cannot safely check an unannotated function.\n              // But we need to propagate `any` type feedback upwards.\n\n              for (_i = 0; _i < params.length; _i++) {\n                _param = params[_i];\n\n                _param.acceptsType(context.any());\n              }\n              returnType.acceptsType(context.any());\n\n            case 32:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var returnType = this.returnType,\n          params = this.params;\n\n      var annotation = input[TypeSymbol];\n      if (annotation) {\n        if (!annotation.params) {\n          return true;\n        }\n        for (var i = 0; i < params.length; i++) {\n          var param = params[i];\n          var annotationParam = annotation.params[i];\n          if (!annotationParam && !param.optional) {\n            return false;\n          } else if (!param.acceptsType(annotationParam)) {\n            return false;\n          }\n        }\n        if (!returnType.acceptsType(annotation.returnType)) {\n          return false;\n        }\n        return true;\n      } else {\n        var context = this.context;\n        // We cannot safely check an unannotated function.\n        // But we need to propagate `any` type feedback upwards.\n\n        for (var _i2 = 0; _i2 < params.length; _i2++) {\n          var _param2 = params[_i2];\n          _param2.acceptsType(context.any());\n        }\n        returnType.acceptsType(context.any());\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof FunctionType)) {\n        return -1;\n      }\n      var returnType = this.returnType;\n      var inputReturnType = input.returnType;\n      var isGreater = false;\n      var returnTypeResult = compareTypes(returnType, inputReturnType);\n      if (returnTypeResult === -1) {\n        return -1;\n      } else if (returnTypeResult === 1) {\n        isGreater = true;\n      }\n\n      var params = this.params;\n      var inputParams = input.params;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        var inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n        if (inputParam == null) {\n          return -1;\n        }\n        var result = compareTypes(param, inputParam);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n      }\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.accepts(args[i])) {\n            return false;\n          }\n        } else if (!param.accepts(undefined)) {\n          return false;\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {\n          if (!rest.accepts(args[_i3])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var params = this.params,\n          rest = this.rest;\n\n      var paramsLength = params.length;\n\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          param.assert(args[i]);\n        } else {\n          param.assert(undefined);\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i4 = paramsLength; _i4 < argsLength; _i4++) {\n          rest.assert(args[_i4]);\n        }\n      }\n\n      return args;\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      this.returnType.assert(input);\n      return input;\n    }\n  }, {\n    key: 'invoke',\n    value: function invoke() {\n      var params = this.params,\n          rest = this.rest,\n          context = this.context;\n\n      var paramsLength = params.length;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var argsLength = args.length;\n      for (var i = 0; i < paramsLength; i++) {\n        var param = params[i];\n        if (i < argsLength) {\n          if (!param.acceptsType(args[i])) {\n            return context.empty();\n          }\n        } else if (!param.accepts(undefined)) {\n          return context.empty();\n        }\n      }\n\n      if (argsLength > paramsLength && rest) {\n        for (var _i5 = paramsLength; _i5 < argsLength; _i5++) {\n          if (!rest.acceptsType(args[_i5])) {\n            return context.empty();\n          }\n        }\n      }\n\n      return this.returnType.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = this.params,\n          rest = this.rest,\n          returnType = this.returnType;\n\n      var args = [];\n      for (var i = 0; i < params.length; i++) {\n        args.push(params[i].toString());\n      }\n      if (rest) {\n        args.push(rest.toString());\n      }\n      return '(' + args.join(', ') + ') => ' + returnType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        params: this.params,\n        rest: this.rest,\n        returnType: this.returnType\n      };\n    }\n  }]);\n  return FunctionType;\n}(Type);\n\nvar GeneratorType = function (_Type) {\n  inherits(GeneratorType, _Type);\n\n  function GeneratorType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GeneratorType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeneratorType.__proto__ || Object.getPrototypeOf(GeneratorType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GeneratorType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GeneratorType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              isValid = input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n\n              if (isValid) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input && typeof input.next === 'function' && typeof input.return === 'function' && typeof input.throw === 'function';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof GeneratorType)) {\n        var _result = compareTypes(this.yieldType, input);\n        if (_result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      var isGreater = false;\n      var result = compareTypes(this.yieldType, input.yieldType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.returnType, input.returnType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      result = compareTypes(this.nextType, input.nextType);\n      if (result === -1) {\n        return -1;\n      } else if (result === 1) {\n        isGreater = true;\n      }\n\n      return isGreater ? 1 : 0;\n    }\n  }, {\n    key: 'acceptsYield',\n    value: function acceptsYield(input) {\n      return this.yieldType.accepts(input);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return this.returnType.accepts(input);\n    }\n  }, {\n    key: 'acceptsNext',\n    value: function acceptsNext(input) {\n      return this.nextType.accepts(input);\n    }\n  }, {\n    key: 'assertYield',\n    value: function assertYield(input) {\n      return this.yieldType.assert(input);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return this.returnType.assert(input);\n    }\n  }, {\n    key: 'assertNext',\n    value: function assertNext(input) {\n      return this.nextType.assert(input);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var yieldType = this.yieldType,\n          returnType = this.returnType,\n          nextType = this.nextType;\n\n      return 'Generator<' + yieldType.toString() + ', ' + returnType.toString() + ', ' + nextType.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        yieldType: this.yieldType,\n        returnType: this.returnType,\n        nextType: this.nextType\n      };\n    }\n  }]);\n  return GeneratorType;\n}(Type);\n\n/**\n * # TypeParameterApplication\n *\n */\nvar TypeParameterApplication = function (_Type) {\n  inherits(TypeParameterApplication, _Type);\n\n  function TypeParameterApplication() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeParameterApplication);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeParameterApplication.__proto__ || Object.getPrototypeOf(TypeParameterApplication)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameterApplication', _this.typeInstances = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeParameterApplication, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var parent, typeInstances;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              parent = this.parent, typeInstances = this.typeInstances;\n              return _context.delegateYield(parent.errors.apply(parent, [validation, path, input].concat(toConsumableArray(typeInstances))), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n\n      return parent.accepts.apply(parent, [input].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var _parent;\n\n      return (_parent = this.parent).compareWith.apply(_parent, [input].concat(toConsumableArray(this.typeInstances)));\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.hasProperty === 'function') {\n        var _ref2;\n\n        return (_ref2 = inner).hasProperty.apply(_ref2, [name].concat(toConsumableArray(this.typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.parent;\n      if (inner && typeof inner.getProperty === 'function') {\n        var _ref3;\n\n        return (_ref3 = inner).getProperty.apply(_ref3, [name].concat(toConsumableArray(this.typeInstances)));\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _parent2;\n\n      return (_parent2 = this.parent).unwrap.apply(_parent2, toConsumableArray(this.typeInstances));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var parent = this.parent,\n          typeInstances = this.typeInstances;\n      var name = parent.name;\n\n      if (typeInstances.length) {\n        var items = [];\n        for (var i = 0; i < typeInstances.length; i++) {\n          var typeInstance = typeInstances[i];\n          items.push(typeInstance.toString());\n        }\n        return name + '<' + items.join(', ') + '>';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeInstances: this.typeInstances\n      };\n    }\n  }]);\n  return TypeParameterApplication;\n}(Type);\n\nvar warnedInstances = new WeakSet();\n\nvar TypeConstructor = function (_Type) {\n  inherits(TypeConstructor, _Type);\n\n  function TypeConstructor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeConstructor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeConstructor.__proto__ || Object.getPrototypeOf(TypeConstructor)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeConstructor', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeConstructor, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement accepts().');\n        warnedInstances.add(this);\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          name = this.name;\n\n      if (!warnedInstances.has(this)) {\n        context.emitWarningMessage('TypeConstructor ' + name + ' does not implement compareWith().');\n        warnedInstances.add(this);\n      }\n      return -1;\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }]);\n  return TypeConstructor;\n}(Type);\n\nvar GenericType = function (_TypeConstructor) {\n  inherits(GenericType, _TypeConstructor);\n\n  function GenericType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, GenericType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GenericType.__proto__ || Object.getPrototypeOf(GenericType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'GenericType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(GenericType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var name, impl, context, annotation;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              name = this.name, impl = this.impl, context = this.context;\n\n              if (input instanceof impl) {\n                _context.next = 9;\n                break;\n              }\n\n              annotation = context.getAnnotation(impl);\n\n              if (!annotation) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(annotation.errors(validation, path, input), 't0', 5);\n\n            case 5:\n              _context.next = 9;\n              break;\n\n            case 7:\n              _context.next = 9;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', name), this];\n\n            case 9:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      if (input instanceof impl) {\n        return true;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        return annotation.accepts(input);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var context = this.context,\n          impl = this.impl;\n\n      var annotation = context.getAnnotation(impl);\n      if (annotation) {\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var expected = annotation.unwrap.apply(annotation, toConsumableArray(typeInstances));\n        return compareTypes(input, expected);\n      } else if (input instanceof GenericType && (input.impl === impl || impl && impl.isPrototypeOf(input.impl))) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var context = this.context,\n          impl = this.impl;\n\n      if (typeof impl !== 'function') {\n        return this;\n      }\n      var annotation = context.getAnnotation(impl);\n      if (annotation != null) {\n        return annotation.unwrap.apply(annotation, arguments);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: 'inferTypeParameters',\n    value: function inferTypeParameters(input) {\n      return [];\n    }\n  }]);\n  return GenericType;\n}(TypeConstructor);\n\nfunction invariant(input, message) {\n  if (!input) {\n    var error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\nvar NullLiteralType = function (_Type) {\n  inherits(NullLiteralType, _Type);\n\n  function NullLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullLiteralType.__proto__ || Object.getPrototypeOf(NullLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== null)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === null;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'null';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NullLiteralType;\n}(Type);\n\nvar VoidType = function (_Type) {\n  inherits(VoidType, _Type);\n\n  function VoidType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VoidType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VoidType.__proto__ || Object.getPrototypeOf(VoidType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VoidType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VoidType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input !== undefined)) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === undefined;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof VoidType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'void';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return VoidType;\n}(Type);\n\nvar NullableType = function (_Type) {\n  inherits(NullableType, _Type);\n\n  function NullableType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NullableType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NullableType.__proto__ || Object.getPrototypeOf(NullableType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NullableType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NullableType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input != null)) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 2);\n\n            case 2:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input == null) {\n        return true;\n      } else {\n        return this.type.accepts(input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NullLiteralType || input instanceof VoidType) {\n        return 1;\n      } else if (input instanceof NullableType) {\n        return compareTypes(this.type, input.type);\n      } else {\n        var result = compareTypes(this.type, input);\n        if (result === -1) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '? ' + this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return NullableType;\n}(Type);\n\nvar _marked$1 = [collectConstraintErrors].map(_regeneratorRuntime.mark);\n\n/**\n * Add constraints to the given subject type.\n */\nfunction addConstraints(subject) {\n  var _subject$constraints;\n\n  for (var _len = arguments.length, constraints = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    constraints[_key - 1] = arguments[_key];\n  }\n\n  (_subject$constraints = subject.constraints).push.apply(_subject$constraints, toConsumableArray(constraints));\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\n\n\nfunction collectConstraintErrors(subject, validation, path) {\n  for (var _len2 = arguments.length, input = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    input[_key2 - 3] = arguments[_key2];\n  }\n\n  var constraints, length, i, constraint, violation;\n  return _regeneratorRuntime.wrap(function collectConstraintErrors$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          constraints = subject.constraints;\n          length = constraints.length;\n          i = 0;\n\n        case 3:\n          if (!(i < length)) {\n            _context.next = 12;\n            break;\n          }\n\n          constraint = constraints[i];\n          violation = constraint.apply(undefined, toConsumableArray(input));\n\n          if (!(typeof violation === 'string')) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return [path, violation, this];\n\n        case 9:\n          i++;\n          _context.next = 3;\n          break;\n\n        case 12:\n        case 'end':\n          return _context.stop();\n      }\n    }\n  }, _marked$1[0], this);\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nfunction constraintsAccept(subject) {\n  var constraints = subject.constraints;\n  var length = constraints.length;\n\n  for (var _len3 = arguments.length, input = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    input[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var i = 0; i < length; i++) {\n    var constraint = constraints[i];\n    if (typeof constraint.apply(undefined, toConsumableArray(input)) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar ObjectTypeProperty = function (_Type) {\n  inherits(ObjectTypeProperty, _Type);\n\n  function ObjectTypeProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeProperty.__proto__ || Object.getPrototypeOf(ObjectTypeProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeProperty', _this['static'] = false, _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeProperty, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n\n    /**\n     * Determine whether the property is nullable.\n     */\n\n  }, {\n    key: 'isNullable',\n    value: function isNullable() {\n      return this.value instanceof NullableType;\n    }\n\n    /**\n     * Determine whether the property exists on the given input or its prototype chain.\n     */\n\n  }, {\n    key: 'existsOn',\n    value: function existsOn(input) {\n      // Ignore\n      var key = this.key,\n          isStatic = this.static;\n\n      return key in (isStatic ? input.constructor : input) === true;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var optional, key, value, isStatic, target, targetPath, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              optional = this.optional, key = this.key, value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 18;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 14;\n                break;\n              }\n\n              if (optional) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 13;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 13:\n              return _context.abrupt('return');\n\n            case 14:\n              targetPath.push(key);\n              target = input.constructor[key];\n              _context.next = 20;\n              break;\n\n            case 18:\n              target = input[key];\n              targetPath = path.concat(key);\n\n            case 20:\n              if (!(optional && target === undefined)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 22:\n              if (!(this.isNullable() && !this.existsOn(input))) {\n                _context.next = 26;\n                break;\n              }\n\n              _context.next = 25;\n              return [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n\n            case 25:\n              return _context.abrupt('return');\n\n            case 26:\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 30;\n              _iterator = value.errors(validation, targetPath, target)[Symbol.iterator]();\n\n            case 32:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 40;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 37;\n              return error;\n\n            case 37:\n              _iteratorNormalCompletion = true;\n              _context.next = 32;\n              break;\n\n            case 40:\n              _context.next = 46;\n              break;\n\n            case 42:\n              _context.prev = 42;\n              _context.t0 = _context['catch'](30);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 46:\n              _context.prev = 46;\n              _context.prev = 47;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 49:\n              _context.prev = 49;\n\n              if (!_didIteratorError) {\n                _context.next = 52;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 52:\n              return _context.finish(49);\n\n            case 53:\n              return _context.finish(46);\n\n            case 54:\n              if (hasErrors) {\n                _context.next = 56;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, targetPath, target), 't1', 56);\n\n            case 56:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[30, 42, 46, 54], [47,, 49, 53]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var optional = this.optional,\n          key = this.key,\n          value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return optional ? true : false;\n        }\n        target = input.constructor[key];\n      } else {\n        target = input[key];\n      }\n\n      if (optional && target === undefined) {\n        return true;\n      }\n\n      if (this.isNullable() && !this.existsOn(input)) {\n        return false;\n      }\n\n      if (!value.accepts(target)) {\n        return false;\n      } else {\n        return constraintsAccept(this, target);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeProperty)) {\n        return -1;\n      } else if (input.key !== this.key) {\n        return -1;\n      } else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var key = this.key;\n      // Issue 252\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'symbol') {\n        key = '[' + key.toString() + ']';\n      }\n      if (this.static) {\n        return 'static ' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      } else {\n        return '' + key + (this.optional ? '?' : '') + ': ' + this.value.toString() + ';';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        key: this.key,\n        value: this.value,\n        optional: this.optional\n      };\n    }\n  }]);\n  return ObjectTypeProperty;\n}(Type);\n\nvar ObjectTypeIndexer = function (_Type) {\n  inherits(ObjectTypeIndexer, _Type);\n\n  function ObjectTypeIndexer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeIndexer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeIndexer.__proto__ || Object.getPrototypeOf(ObjectTypeIndexer)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeIndexer', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectTypeIndexer, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, key, value) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // special case number types\n              if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n                key = +key;\n              }\n\n              return _context.delegateYield(this.key.errors(validation, path.concat('[[Key]]'), key), 't0', 2);\n\n            case 2:\n              return _context.delegateYield(this.value.errors(validation, path.concat(key), value), 't1', 3);\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'acceptsKey',\n    value: function acceptsKey(key) {\n      // special case number types\n      if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n        key = +key;\n      }\n      return this.key.accepts(key);\n    }\n  }, {\n    key: 'acceptsValue',\n    value: function acceptsValue(value) {\n      return this.value.accepts(value);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ObjectTypeProperty) {\n        if (!this.key.accepts(input.key)) {\n          return -1;\n        } else {\n          return compareTypes(this.value, input.value);\n        }\n      } else if (!(input instanceof ObjectTypeIndexer)) {\n        return -1;\n      }\n\n      var keyResult = compareTypes(this.key, input.key);\n      if (keyResult === -1) {\n        return -1;\n      }\n      var valueResult = compareTypes(this.value, input.value);\n      if (valueResult === -1) {\n        return -1;\n      }\n\n      if (keyResult === 0 && valueResult === 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[' + this.id + ': ' + this.key.toString() + ']: ' + this.value.toString() + ';';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        id: this.id,\n        key: this.key,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeIndexer;\n}(Type);\n\nvar ObjectTypeCallProperty = function (_Type) {\n  inherits(ObjectTypeCallProperty, _Type);\n\n  function ObjectTypeCallProperty() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectTypeCallProperty);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectTypeCallProperty.__proto__ || Object.getPrototypeOf(ObjectTypeCallProperty)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectTypeCallProperty', _this['static'] = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  // Ignore\n\n\n  createClass(ObjectTypeCallProperty, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value, isStatic, target, targetPath;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // Ignore\n              value = this.value, isStatic = this.static;\n              target = void 0;\n              targetPath = void 0;\n\n              if (!isStatic) {\n                _context.next = 16;\n                break;\n              }\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 7;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 7:\n              return _context.abrupt('return');\n\n            case 8:\n              targetPath = path.concat('constructor');\n\n              if (!(typeof input.constructor !== 'function')) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 12;\n              return [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n\n            case 12:\n              return _context.abrupt('return');\n\n            case 13:\n              target = input.constructor;\n              _context.next = 18;\n              break;\n\n            case 16:\n              target = input;\n              targetPath = path;\n\n            case 18:\n              return _context.delegateYield(value.errors(validation, targetPath, target), 't0', 19);\n\n            case 19:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      // Ignore\n      var value = this.value,\n          isStatic = this.static;\n\n      var target = void 0;\n      if (isStatic) {\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n          return false;\n        }\n        if (typeof input.constructor !== 'function') {\n          return false;\n        }\n        target = input.constructor;\n      } else {\n        target = input;\n      }\n      return value.accepts(target);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectTypeCallProperty)) {\n        return -1;\n      }\n      return compareTypes(this.value, input.value);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.value.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      if (this.static) {\n        return 'static ' + this.value.toString() + ';';\n      } else {\n        return this.value.toString();\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return ObjectTypeCallProperty;\n}(Type);\n\nvar Declaration = function (_Type) {\n  inherits(Declaration, _Type);\n\n  function Declaration() {\n    classCallCheck(this, Declaration);\n    return possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).apply(this, arguments));\n  }\n\n  return Declaration;\n}(Type);\n\nvar VarDeclaration = function (_Declaration) {\n  inherits(VarDeclaration, _Declaration);\n\n  function VarDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, VarDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VarDeclaration.__proto__ || Object.getPrototypeOf(VarDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'VarDeclaration', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(VarDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare var ' + this.name + ': ' + this.type.toString() + ';';\n    }\n  }]);\n  return VarDeclaration;\n}(Declaration);\n\nvar TypeDeclaration = function (_Declaration) {\n  inherits(TypeDeclaration, _Declaration);\n\n  function TypeDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeDeclaration.__proto__ || Object.getPrototypeOf(TypeDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeDeclaration, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      var _typeAlias;\n\n      (_typeAlias = this.typeAlias).addConstraint.apply(_typeAlias, arguments);\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.typeAlias.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var _typeAlias2;\n\n      return (_typeAlias2 = this.typeAlias).apply.apply(_typeAlias2, arguments);\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.typeAlias.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.typeAlias, input);\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var _typeAlias3;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_typeAlias3 = this.typeAlias).hasProperty.apply(_typeAlias3, [name].concat(toConsumableArray(typeInstances)));\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var _typeAlias4;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_typeAlias4 = this.typeAlias).getProperty.apply(_typeAlias4, [name].concat(toConsumableArray(typeInstances)));\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _typeAlias5;\n\n      return (_typeAlias5 = this.typeAlias).unwrap.apply(_typeAlias5, arguments);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare ' + this.typeAlias.toString(true) + ';';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return this.typeAlias.type;\n    }\n  }]);\n  return TypeDeclaration;\n}(Declaration);\n\nvar ModuleDeclaration = function (_Declaration) {\n  inherits(ModuleDeclaration, _Declaration);\n\n  function ModuleDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleDeclaration.__proto__ || Object.getPrototypeOf(ModuleDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleDeclaration, [{\n    key: 'get',\n    value: function get$$1(name) {\n      var moduleExports = this.moduleExports;\n\n      if (moduleExports) {\n        var exporting = moduleExports.unwrap();\n        if (typeof exporting.getProperty === 'function') {\n          var prop = exporting.getProperty(name);\n          if (prop) {\n            return prop.unwrap();\n          }\n        }\n      } else {\n        var declaration = this.declarations[name];\n        if (declaration) {\n          return declaration.unwrap();\n        }\n      }\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      if (/^\\.\\//.test(moduleName)) {\n        moduleName = '' + this.name + moduleName.slice(1);\n      }\n      return this.innerContext.import(moduleName);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var name = this.name,\n          declarations = this.declarations,\n          modules = this.modules,\n          moduleExports = this.moduleExports;\n\n      var body = [];\n      for (var _name in declarations) {\n        // eslint-disable-line guard-for-in\n        var declaration = declarations[_name];\n        body.push(declaration.toString(true));\n      }\n      if (modules) {\n        for (var _name2 in modules) {\n          // eslint-disable-line guard-for-in\n          var module = modules[_name2];\n          body.push(module.toString());\n        }\n      }\n      if (moduleExports) {\n        body.push(moduleExports.toString());\n      }\n      return 'declare module \"' + name + '\" {\\n' + indent$1(body.join('\\n\\n')) + '}';\n    }\n  }, {\n    key: 'moduleType',\n    get: function get$$1() {\n      if (this.moduleExports) {\n        return 'commonjs';\n      } else {\n        return 'es6';\n      }\n    }\n  }, {\n    key: 'isCommonJS',\n    get: function get$$1() {\n      return this.moduleExports ? true : false;\n    }\n  }, {\n    key: 'isES6',\n    get: function get$$1() {\n      return this.moduleExports ? false : true;\n    }\n  }, {\n    key: 'declarations',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[NameRegistrySymbol];\n    }\n  }, {\n    key: 'modules',\n    get: function get$$1() {\n      var innerContext = this.innerContext;\n\n      return innerContext[ModuleRegistrySymbol];\n    }\n  }]);\n  return ModuleDeclaration;\n}(Declaration);\n\nfunction indent$1(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar ModuleExports = function (_Declaration) {\n  inherits(ModuleExports, _Declaration);\n\n  function ModuleExports() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ModuleExports);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ModuleExports.__proto__ || Object.getPrototypeOf(ModuleExports)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ModuleExports', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ModuleExports, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'declare module.exports: ' + this.type.toString() + ';';\n    }\n  }]);\n  return ModuleExports;\n}(Declaration);\n\nvar ClassDeclaration = function (_Declaration) {\n  inherits(ClassDeclaration, _Declaration);\n\n  function ClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassDeclaration.__proto__ || Object.getPrototypeOf(ClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var body, superClass, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref2, _ref3, errorPath, errorMessage, expectedType, propertyName;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              body = this.body;\n              superClass = this.superClass && this.superClass.unwrap();\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n\n            case 5:\n              return _context.abrupt('return');\n\n            case 6:\n              if (!superClass) {\n                _context.next = 42;\n                break;\n              }\n\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = superClass.errors(validation, path, input)[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 28;\n                break;\n              }\n\n              _ref2 = _step.value;\n              _ref3 = slicedToArray(_ref2, 3);\n              errorPath = _ref3[0];\n              errorMessage = _ref3[1];\n              expectedType = _ref3[2];\n              propertyName = errorPath[path.length];\n\n              if (!body.getProperty(propertyName)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt('continue', 25);\n\n            case 23:\n              _context.next = 25;\n              return [errorPath, errorMessage, expectedType];\n\n            case 25:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 28:\n              _context.next = 34;\n              break;\n\n            case 30:\n              _context.prev = 30;\n              _context.t0 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 34:\n              _context.prev = 34;\n              _context.prev = 35;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 37:\n              _context.prev = 37;\n\n              if (!_didIteratorError) {\n                _context.next = 40;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 40:\n              return _context.finish(37);\n\n            case 41:\n              return _context.finish(34);\n\n            case 42:\n              return _context.delegateYield(body.errors(validation, path, input), 't1', 43);\n\n            case 43:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 30, 34, 42], [35,, 37, 41]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var body = this.body;\n\n      var superClass = this.superClass && this.superClass.unwrap();\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      } else if (superClass && !superClass.accepts(input)) {\n        return false;\n      } else if (!body.accepts(input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof ClassDeclaration) {\n        if (input === this) {\n          return 0;\n        } else if (this.isSuperClassOf(input)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      return compareTypes(this.body, input);\n    }\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      var prop = body.getProperty(key);\n      if (prop) {\n        return prop;\n      } else if (superClass && typeof superClass.getProperty === 'function') {\n        return superClass.getProperty(key);\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (body.hasProperty(key)) {\n        return true;\n      } else if (superClass && typeof superClass.hasProperty === 'function') {\n        return superClass.hasProperty(key);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine whether this class declaration represents a super class of\n     * the given type.\n     */\n\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      var body = this.body,\n          shapeID = this.shapeID;\n\n      var current = candidate;\n\n      while (current != null) {\n        if (current === this || current === body || current.shapeID === shapeID) {\n          return true;\n        }\n        if (current instanceof ClassDeclaration) {\n          current = current.superClass;\n        } else {\n          current = current.unwrap();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          superClass = this.superClass,\n          body = this.body;\n\n      if (withDeclaration) {\n        var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n        return 'declare class ' + name + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      var body = this.body,\n          superClass = this.superClass;\n\n      if (superClass == null) {\n        return body.properties;\n      }\n      var bodyProps = body.properties;\n      var superProps = superClass.unwrap().properties;\n      var seen = {};\n      var seenStatic = {};\n      var props = [];\n      for (var i = 0; i < superProps.length; i++) {\n        var prop = superProps[i];\n        props.push(prop);\n        if (prop.static) {\n          seenStatic[prop.key] = i;\n        } else {\n          seen[prop.key] = i;\n        }\n      }\n      for (var _i = 0; _i < bodyProps.length; _i++) {\n        var _prop = bodyProps[_i];\n        if (seen[_prop.key]) {\n          props[_i] = _prop;\n        } else {\n          props.push(_prop);\n        }\n      }\n      return props;\n    }\n  }]);\n  return ClassDeclaration;\n}(Declaration);\n\nvar PartialType = function (_Type) {\n  inherits(PartialType, _Type);\n\n  function PartialType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, PartialType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = PartialType.__proto__ || Object.getPrototypeOf(PartialType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'PartialType', _this.typeParameters = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(PartialType, [{\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this.context);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      this.typeParameters.push(target);\n      return target;\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var constraints, type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              constraints = this.constraints, type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (!(!hasErrors && constraints)) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var constraints = this.constraints,\n          type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (constraints && !constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(expand) {\n      var type = this.type;\n\n      return type.toString(expand);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        typeParameters: this.typeParameters,\n        type: this.type\n      };\n    }\n  }]);\n  return PartialType;\n}(Type);\n\nvar ParameterizedClassDeclaration = function (_Declaration) {\n  inherits(ParameterizedClassDeclaration, _Declaration);\n\n  function ParameterizedClassDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedClassDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedClassDeclaration.__proto__ || Object.getPrototypeOf(ParameterizedClassDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedClassDeclaration', _this.shapeID = Symbol(), _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedClassDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return getPartial(this).compareWith(input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial.apply(undefined, [this].concat(toConsumableArray(typeInstances))).type;\n    }\n  }, {\n    key: 'isSuperClassOf',\n    value: function isSuperClassOf(candidate) {\n      return getPartial(this).type.isSuperClassOf(candidate);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len5 = arguments.length, typeInstances = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeInstances[_key5] = arguments[_key5];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      if (!withDeclaration) {\n        return this.name;\n      }\n      var partial = getPartial(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return partial.toString(true);\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      var superClass = type.superClass,\n          body = type.body;\n\n      var superClassName = superClass && (typeof superClass.name === 'string' && superClass.name || superClass.toString());\n      return 'declare class ' + this.name + '<' + items.join(', ') + '>' + (superClassName ? ' extends ' + superClassName : '') + ' ' + body.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getPartial(this).toJSON();\n    }\n  }, {\n    key: 'superClass',\n    get: function get$$1() {\n      return getPartial(this).type.superClass;\n    }\n  }, {\n    key: 'body',\n    get: function get$$1() {\n      return getPartial(this).type.body;\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial(this).type.properties;\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial(this).typeParameters;\n    }\n  }]);\n  return ParameterizedClassDeclaration;\n}(Declaration);\n\nfunction getPartial(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class.apply(context, [parent.name].concat(toConsumableArray(body)));\n  } else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  partial.type.shapeID = parent.shapeID;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len6 = arguments.length, typeInstances = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    typeInstances[_key6 - 1] = arguments[_key6];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ExtendsDeclaration = function (_Declaration) {\n  inherits(ExtendsDeclaration, _Declaration);\n\n  function ExtendsDeclaration() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ExtendsDeclaration);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ExtendsDeclaration.__proto__ || Object.getPrototypeOf(ExtendsDeclaration)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ExtendsDeclaration', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ExtendsDeclaration, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var type = this.type;\n\n      if (withDeclaration) {\n        return 'extends ' + type.toString();\n      } else {\n        return type.toString();\n      }\n    }\n  }]);\n  return ExtendsDeclaration;\n}(Declaration);\n\nvar _marked = [collectErrorsWithIndexers, collectErrorsWithoutIndexers, collectErrorsExact].map(_regeneratorRuntime.mark);\n\nvar ObjectType = function (_Type) {\n  inherits(ObjectType, _Type);\n\n  function ObjectType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ObjectType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ObjectType, [{\n    key: 'getProperty',\n\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n    value: function getProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return property;\n        }\n      }\n      return this.getIndexer(key);\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var properties = this.properties;\n      var length = properties.length;\n\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (property.key === key) {\n          return true;\n        }\n      }\n      return this.hasIndexer(key);\n    }\n\n    /**\n     * Get an indexer with which matches the given key type.\n     */\n\n  }, {\n    key: 'getIndexer',\n    value: function getIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return indexer;\n        }\n      }\n    }\n\n    /**\n     * Determine whether an indexer exists which matches the given key type.\n     */\n\n  }, {\n    key: 'hasIndexer',\n    value: function hasIndexer(key) {\n      var indexers = this.indexers;\n      var length = indexers.length;\n\n      for (var i = 0; i < length; i++) {\n        var indexer = indexers[i];\n        if (indexer.acceptsKey(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var hasCallProperties;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(input === null)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 3:\n              return _context.abrupt('return');\n\n            case 4:\n              hasCallProperties = this.callProperties.length > 0;\n\n              if (!hasCallProperties) {\n                _context.next = 11;\n                break;\n              }\n\n              if (acceptsCallProperties(this, input)) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 9;\n              return [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n\n            case 9:\n              _context.next = 15;\n              break;\n\n            case 11:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object')) {\n                _context.next = 15;\n                break;\n              }\n\n              _context.next = 14;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 14:\n              return _context.abrupt('return');\n\n            case 15:\n              if (!validation.inCycle(this, input)) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 17:\n              validation.startCycle(this, input);\n\n              if (!(this.indexers.length > 0)) {\n                _context.next = 22;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsWithIndexers(this, validation, path, input), 't0', 20);\n\n            case 20:\n              _context.next = 27;\n              break;\n\n            case 22:\n              if (!this.exact) {\n                _context.next = 26;\n                break;\n              }\n\n              return _context.delegateYield(collectErrorsExact(this, validation, path, input), 't1', 24);\n\n            case 24:\n              _context.next = 27;\n              break;\n\n            case 26:\n              return _context.delegateYield(collectErrorsWithoutIndexers(this, validation, path, input), 't2', 27);\n\n            case 27:\n              validation.endCycle(this, input);\n\n            case 28:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      if (input === null) {\n        return false;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      if (hasCallProperties) {\n        if (!acceptsCallProperties(this, input)) {\n          return false;\n        }\n      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {\n        return false;\n      }\n      if (inValidationCycle(this, input)) {\n        return true;\n      }\n      startValidationCycle(this, input);\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = acceptsWithIndexers(this, input);\n      } else if (this.exact) {\n        result = acceptsExact(this, input);\n      } else {\n        result = acceptsWithoutIndexers(this, input);\n      }\n      endValidationCycle(this, input);\n      return result;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n        return -1;\n      }\n      var hasCallProperties = this.callProperties.length > 0;\n\n      var isGreater = false;\n      if (hasCallProperties) {\n        var _result = compareTypeCallProperties(this, input);\n        if (_result === -1) {\n          return -1;\n        } else if (_result === 1) {\n          isGreater = true;\n        }\n      }\n\n      var result = void 0;\n      if (this.indexers.length > 0) {\n        result = compareTypeWithIndexers(this, input);\n      } else {\n        result = compareTypeWithoutIndexers(this, input);\n      }\n\n      if (result === -1) {\n        return -1;\n      } else if (isGreater) {\n        return 1;\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var callProperties = this.callProperties,\n          properties = this.properties,\n          indexers = this.indexers;\n\n      if (inToStringCycle(this)) {\n        return '$Cycle<Object>';\n      }\n      startToStringCycle(this);\n      var body = [];\n      for (var i = 0; i < callProperties.length; i++) {\n        body.push(callProperties[i].toString());\n      }\n      for (var _i = 0; _i < properties.length; _i++) {\n        body.push(properties[_i].toString());\n      }\n      for (var _i2 = 0; _i2 < indexers.length; _i2++) {\n        body.push(indexers[_i2].toString());\n      }\n      endToStringCycle(this);\n      if (this.exact) {\n        return '{|\\n' + indent(body.join('\\n')) + '\\n|}';\n      } else {\n        return '{\\n' + indent(body.join('\\n')) + '\\n}';\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        callProperties: this.callProperties,\n        properties: this.properties,\n        indexers: this.indexers,\n        exact: this.exact\n      };\n    }\n  }]);\n  return ObjectType;\n}(Type);\n\nfunction acceptsCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareTypeCallProperties(type, input) {\n  var callProperties = type.callProperties;\n\n  var inputCallProperties = input.callProperties;\n  var identicalCount = 0;\n  loop: for (var i = 0; i < callProperties.length; i++) {\n    var callProperty = callProperties[i];\n\n    for (var j = 0; j < inputCallProperties.length; j++) {\n      var inputCallProperty = inputCallProperties[j];\n      var result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      } else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers(type, input) {\n  var properties = type.properties,\n      indexers = type.indexers;\n\n  var seen = [];\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (var key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    var value = input[key];\n    for (var _i3 = 0; _i3 < indexers.length; _i3++) {\n      var indexer = indexers[_i3];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers(type, input) {\n  var indexers = type.indexers,\n      properties = type.properties;\n\n  var inputIndexers = input.indexers;\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {\n    var indexer = indexers[_i4];\n    for (var _j = 0; _j < inputIndexers.length; _j++) {\n      var inputIndexer = inputIndexers[_j];\n      var _result2 = compareTypes(indexer, inputIndexer);\n      if (_result2 === 1) {\n        isGreater = true;\n        continue loop;\n      } else if (_result2 === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction acceptsWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact(type, input) {\n  var properties = type.properties;\n  var length = properties.length;\n\n  loop: for (var key in input) {\n    // eslint-disable-line guard-for-in\n    for (var i = 0; i < length; i++) {\n      var property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers(type, input) {\n  var properties = type.properties;\n\n  var inputProperties = input.properties;\n  var isGreater = false;\n  loop: for (var i = 0; i < properties.length; i++) {\n    var property = properties[i];\n    for (var j = 0; j < inputProperties.length; j++) {\n      var inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        var result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        } else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\nfunction collectErrorsWithIndexers(type, validation, path, input) {\n  var properties, indexers, seen, i, property, key, value, _i5, indexer;\n\n  return _regeneratorRuntime.wrap(function collectErrorsWithIndexers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          properties = type.properties, indexers = type.indexers;\n          seen = [];\n          i = 0;\n\n        case 3:\n          if (!(i < properties.length)) {\n            _context2.next = 10;\n            break;\n          }\n\n          property = properties[i];\n          return _context2.delegateYield(property.errors(validation, path, input), 't0', 6);\n\n        case 6:\n          seen.push(property.key);\n\n        case 7:\n          i++;\n          _context2.next = 3;\n          break;\n\n        case 10:\n          _context2.t1 = _regeneratorRuntime.keys(input);\n\n        case 11:\n          if ((_context2.t2 = _context2.t1()).done) {\n            _context2.next = 28;\n            break;\n          }\n\n          key = _context2.t2.value;\n\n          if (!(seen.indexOf(key) !== -1)) {\n            _context2.next = 15;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 15:\n          value = input[key];\n          _i5 = 0;\n\n        case 17:\n          if (!(_i5 < indexers.length)) {\n            _context2.next = 24;\n            break;\n          }\n\n          indexer = indexers[_i5];\n\n          if (!(indexer.acceptsKey(key) && indexer.acceptsValue(value))) {\n            _context2.next = 21;\n            break;\n          }\n\n          return _context2.abrupt('continue', 11);\n\n        case 21:\n          _i5++;\n          _context2.next = 17;\n          break;\n\n        case 24:\n          _context2.next = 26;\n          return [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n\n        case 26:\n          _context2.next = 11;\n          break;\n\n        case 28:\n        case 'end':\n          return _context2.stop();\n      }\n    }\n  }, _marked[0], this);\n}\n\nfunction collectErrorsWithoutIndexers(type, validation, path, input) {\n  var properties, i, property;\n  return _regeneratorRuntime.wrap(function collectErrorsWithoutIndexers$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          properties = type.properties;\n          i = 0;\n\n        case 2:\n          if (!(i < properties.length)) {\n            _context3.next = 8;\n            break;\n          }\n\n          property = properties[i];\n          return _context3.delegateYield(property.errors(validation, path, input), 't0', 5);\n\n        case 5:\n          i++;\n          _context3.next = 2;\n          break;\n\n        case 8:\n        case 'end':\n          return _context3.stop();\n      }\n    }\n  }, _marked[1], this);\n}\n\nfunction collectErrorsExact(type, validation, path, input) {\n  var properties, length, key, i, property;\n  return _regeneratorRuntime.wrap(function collectErrorsExact$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          properties = type.properties;\n          length = properties.length;\n          _context4.t0 = _regeneratorRuntime.keys(input);\n\n        case 3:\n          if ((_context4.t1 = _context4.t0()).done) {\n            _context4.next = 18;\n            break;\n          }\n\n          key = _context4.t1.value;\n          i = 0;\n\n        case 6:\n          if (!(i < length)) {\n            _context4.next = 14;\n            break;\n          }\n\n          property = properties[i];\n\n          if (!(property.key === key)) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield(property.errors(validation, path, input), 't2', 10);\n\n        case 10:\n          return _context4.abrupt('continue', 3);\n\n        case 11:\n          i++;\n          _context4.next = 6;\n          break;\n\n        case 14:\n          _context4.next = 16;\n          return [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n\n        case 16:\n          _context4.next = 3;\n          break;\n\n        case 18:\n        case 'end':\n          return _context4.stop();\n      }\n    }\n  }, _marked[2], this);\n}\n\nfunction indent(input) {\n  var lines = input.split('\\n');\n  var length = lines.length;\n\n  for (var i = 0; i < length; i++) {\n    lines[i] = '  ' + lines[i];\n  }\n  return lines.join('\\n');\n}\n\nvar IntersectionType = function (_Type) {\n  inherits(IntersectionType, _Type);\n\n  function IntersectionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, IntersectionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IntersectionType.__proto__ || Object.getPrototypeOf(IntersectionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'IntersectionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(IntersectionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 8;\n                break;\n              }\n\n              return _context.delegateYield(types[i].errors(validation, path, input), 't0', 5);\n\n            case 5:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n\n    /**\n     * Get a property with the given name, or undefined if it does not exist.\n     */\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = length - 1; i >= 0; i--) {\n        var type = types[i];\n        if (typeof type.getProperty === 'function') {\n          var prop = type.getProperty(key);\n          if (prop) {\n            return prop;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine whether a property with the given name exists.\n     */\n\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(key) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (!type.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      var identicalCount = 0;\n      if (input instanceof IntersectionType) {\n        var inputTypes = input.types;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n        return identicalCount === types.length ? 0 : 1;\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          var _result = compareTypes(_type, input);\n          if (_result === -1) {\n            return -1;\n          } else if (_result === 0) {\n            identicalCount++;\n          }\n        }\n        return identicalCount === types.length ? 0 : 1;\n      }\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _ref2;\n\n      var callProperties = [];\n      var properties = [];\n      var indexers = [];\n      var types = this.types,\n          context = this.context;\n\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i].unwrap();\n        invariant(type instanceof ObjectType, 'Can only intersect object types');\n        callProperties.push.apply(callProperties, toConsumableArray(type.callProperties));\n        indexers.push.apply(indexers, toConsumableArray(type.indexers));\n        mergeProperties(properties, type.properties);\n      }\n      return (_ref2 = context).object.apply(_ref2, callProperties.concat(properties, indexers));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.types.join(' & ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return IntersectionType;\n}(Type);\n\nfunction getPropertyIndex(name, properties) {\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    var typeProp = source[i];\n    var index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    } else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\nvar MixedType = function (_Type) {\n  inherits(MixedType, _Type);\n\n  function MixedType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, MixedType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = MixedType.__proto__ || Object.getPrototypeOf(MixedType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'MixedType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(MixedType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'mixed';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return MixedType;\n}(Type);\n\nvar TypeAlias = function (_Type) {\n  inherits(TypeAlias, _Type);\n\n  function TypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeAlias.__proto__ || Object.getPrototypeOf(TypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeAlias', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeAlias, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(this.type, input);\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var name = this.name,\n          type = this.type;\n\n      if (withDeclaration) {\n        return 'type ' + name + ' = ' + type.toString() + ';';\n      } else {\n        return name;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name,\n        type: this.type\n      };\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return this.type.properties;\n    }\n  }, {\n    key: 'hasConstraints',\n    get: function get$$1() {\n      return this.constraints.length > 0;\n    }\n  }]);\n  return TypeAlias;\n}(Type);\n\nvar NumericLiteralType = function (_Type) {\n  inherits(NumericLiteralType, _Type);\n\n  function NumericLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumericLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumericLiteralType.__proto__ || Object.getPrototypeOf(NumericLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumericLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumericLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumericLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '' + this.value;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return NumericLiteralType;\n}(Type);\n\nvar NumberType = function (_Type) {\n  inherits(NumberType, _Type);\n\n  function NumberType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, NumberType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = NumberType.__proto__ || Object.getPrototypeOf(NumberType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'NumberType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(NumberType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'number')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'number';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof NumberType) {\n        return 0;\n      } else if (input instanceof NumericLiteralType) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'number';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return NumberType;\n}(Type);\n\nvar ParameterizedTypeAlias = function (_TypeAlias) {\n  inherits(ParameterizedTypeAlias, _TypeAlias);\n\n  function ParameterizedTypeAlias() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedTypeAlias);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedTypeAlias.__proto__ || Object.getPrototypeOf(ParameterizedTypeAlias)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedTypeAlias', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedTypeAlias, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      var partial = getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances)));\n      if (!partial.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0; // should never need this because it's taken care of by compareTypes.\n      } else if (this.hasConstraints) {\n        // if we have constraints the types cannot be the same\n        return -1;\n      } else {\n        return compareTypes(getPartial$1(this), input);\n      }\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        typeInstances[_key5 - 1] = arguments[_key5];\n      }\n\n      var inner = this.unwrap.apply(this, toConsumableArray(typeInstances));\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty.apply(inner, [name].concat(toConsumableArray(typeInstances)));\n      }\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len6 = arguments.length, typeInstances = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeInstances[_key6] = arguments[_key6];\n      }\n\n      return getPartial$1.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withDeclaration) {\n      var partial = getPartial$1(this);\n      var typeParameters = partial.typeParameters;\n\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n\n      var name = this.name;\n\n      var identifier = typeParameters.length > 0 ? name + '<' + items.join(', ') + '>' : name;\n\n      if (withDeclaration) {\n        return 'type ' + identifier + ' = ' + partial.toString() + ';';\n      } else {\n        return identifier;\n      }\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$1(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'properties',\n    get: function get$$1() {\n      return getPartial$1(this).type.properties;\n    }\n  }]);\n  return ParameterizedTypeAlias;\n}(TypeAlias);\n\nfunction getPartial$1(parent) {\n  var typeCreator = parent.typeCreator,\n      context = parent.context,\n      name = parent.name;\n\n  var partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len7 = arguments.length, typeInstances = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    typeInstances[_key7 - 1] = arguments[_key7];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar ParameterizedFunctionType = function (_Type) {\n  inherits(ParameterizedFunctionType, _Type);\n\n  function ParameterizedFunctionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ParameterizedFunctionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ParameterizedFunctionType.__proto__ || Object.getPrototypeOf(ParameterizedFunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ParameterizedFunctionType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ParameterizedFunctionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      for (var _len2 = arguments.length, typeInstances = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n        typeInstances[_key2 - 3] = arguments[_key2];\n      }\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        typeInstances[_key3 - 1] = arguments[_key3];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getPartial$2(this), input);\n    }\n  }, {\n    key: 'acceptsParams',\n    value: function acceptsParams() {\n      var _getPartial$type;\n\n      return (_getPartial$type = getPartial$2(this).type).acceptsParams.apply(_getPartial$type, arguments);\n    }\n  }, {\n    key: 'acceptsReturn',\n    value: function acceptsReturn(input) {\n      return getPartial$2(this).type.acceptsReturn(input);\n    }\n  }, {\n    key: 'assertParams',\n    value: function assertParams() {\n      var _getPartial$type2;\n\n      return (_getPartial$type2 = getPartial$2(this).type).assertParams.apply(_getPartial$type2, arguments);\n    }\n  }, {\n    key: 'assertReturn',\n    value: function assertReturn(input) {\n      return getPartial$2(this).type.assertReturn(input);\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      for (var _len4 = arguments.length, typeInstances = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeInstances[_key4] = arguments[_key4];\n      }\n\n      return getPartial$2.apply(undefined, [this].concat(toConsumableArray(typeInstances))).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var partial = getPartial$2(this);\n      var type = partial.type,\n          typeParameters = partial.typeParameters;\n\n      if (typeParameters.length === 0) {\n        return type.toString();\n      }\n      var items = [];\n      for (var i = 0; i < typeParameters.length; i++) {\n        var typeParameter = typeParameters[i];\n        items.push(typeParameter.toString(true));\n      }\n      return '<' + items.join(', ') + '> ' + type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var partial = getPartial$2(this);\n      return partial.toJSON();\n    }\n  }, {\n    key: 'typeParameters',\n    get: function get$$1() {\n      return getPartial$2(this).typeParameters;\n    }\n  }, {\n    key: 'params',\n    get: function get$$1() {\n      return getPartial$2(this).type.params;\n    }\n  }, {\n    key: 'rest',\n    get: function get$$1() {\n      return getPartial$2(this).type.rest;\n    }\n  }, {\n    key: 'returnType',\n    get: function get$$1() {\n      return getPartial$2(this).type.returnType;\n    }\n  }]);\n  return ParameterizedFunctionType;\n}(Type);\n\nfunction getPartial$2(parent) {\n  var context = parent.context,\n      bodyCreator = parent.bodyCreator;\n\n  var partial = new PartialType(context);\n  var body = bodyCreator(partial);\n  partial.type = context.function.apply(context, toConsumableArray(body));\n\n  var typeParameters = partial.typeParameters;\n\n  for (var _len5 = arguments.length, typeInstances = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    typeInstances[_key5 - 1] = arguments[_key5];\n  }\n\n  var limit = Math.min(typeInstances.length, typeParameters.length);\n  for (var i = 0; i < limit; i++) {\n    var typeParameter = typeParameters[i];\n    var typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    } else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\nvar RefinementType = function (_Type) {\n  inherits(RefinementType, _Type);\n\n  function RefinementType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, RefinementType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RefinementType.__proto__ || Object.getPrototypeOf(RefinementType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'RefinementType', _this.constraints = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(RefinementType, [{\n    key: 'addConstraint',\n    value: function addConstraint() {\n      for (var _len2 = arguments.length, constraints = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        constraints[_key2] = arguments[_key2];\n      }\n\n      addConstraints.apply(undefined, [this].concat(toConsumableArray(constraints)));\n      return this;\n    }\n  }, {\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, hasErrors, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, error;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n              hasErrors = false;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 5;\n              _iterator = type.errors(validation, path, input)[Symbol.iterator]();\n\n            case 7:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 15;\n                break;\n              }\n\n              error = _step.value;\n\n              hasErrors = true;\n              _context.next = 12;\n              return error;\n\n            case 12:\n              _iteratorNormalCompletion = true;\n              _context.next = 7;\n              break;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context['catch'](5);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 21:\n              _context.prev = 21;\n              _context.prev = 22;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(21);\n\n            case 29:\n              if (hasErrors) {\n                _context.next = 31;\n                break;\n              }\n\n              return _context.delegateYield(collectConstraintErrors(this, validation, path, input), 't1', 31);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[5, 17, 21, 29], [22,, 24, 28]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (!type.accepts(input)) {\n        return false;\n      } else if (!constraintsAccept(this, input)) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input === this) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len3 = arguments.length, typeInstances = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeInstances[_key3] = arguments[_key3];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var type = this.type;\n\n      return '$Refinment<' + type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return RefinementType;\n}(Type);\n\nvar StringLiteralType = function (_Type) {\n  inherits(StringLiteralType, _Type);\n\n  function StringLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringLiteralType.__proto__ || Object.getPrototypeOf(StringLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return JSON.stringify(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return StringLiteralType;\n}(Type);\n\nvar StringType = function (_Type) {\n  inherits(StringType, _Type);\n\n  function StringType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, StringType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = StringType.__proto__ || Object.getPrototypeOf(StringType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'StringType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(StringType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof input !== 'string')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return typeof input === 'string';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof StringLiteralType) {\n        return 1;\n      } else if (input instanceof StringType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return StringType;\n}(Type);\n\nvar SymbolLiteralType = function (_Type) {\n  inherits(SymbolLiteralType, _Type);\n\n  function SymbolLiteralType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolLiteralType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolLiteralType.__proto__ || Object.getPrototypeOf(SymbolLiteralType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolLiteralType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolLiteralType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = this.value;\n\n              if (!(input !== value)) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n\n            case 4:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return input === this.value;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType && input.value === this.value) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'typeof ' + String(this.value);\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        value: this.value\n      };\n    }\n  }]);\n  return SymbolLiteralType;\n}(Type);\n\nvar SymbolType = function (_Type) {\n  inherits(SymbolType, _Type);\n\n  function SymbolType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, SymbolType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SymbolType.__proto__ || Object.getPrototypeOf(SymbolType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'SymbolType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(SymbolType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'symbol')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n\n            case 3:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol';\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (input instanceof SymbolLiteralType) {\n        return 1;\n      } else if (input instanceof SymbolType) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Symbol';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return SymbolType;\n}(Type);\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\n\nvar ThisType = function (_Type) {\n  inherits(ThisType, _Type);\n\n  function ThisType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ThisType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ThisType.__proto__ || Object.getPrototypeOf(ThisType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ThisType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ThisType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var recorded;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              recorded = this.recorded;\n\n              if (!(input === recorded)) {\n                _context.next = 5;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 5:\n              if (!(typeof recorded === 'function' && input instanceof recorded)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              if (!(recorded != null)) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var recorded = this.recorded;\n\n      if (input === recorded) {\n        return true;\n      } else if (typeof recorded === 'function' && input instanceof recorded) {\n        return true;\n      } else if (recorded != null) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      if (!(input instanceof ThisType)) {\n        return -1;\n      } else if (input.recorded && this.recorded) {\n        return input.recorded === this.recorded ? 0 : -1;\n      } else if (this.recorded) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n\n    /**\n     * Get the inner type.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(withBinding) {\n      return 'this';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return ThisType;\n}(Type);\n\nvar warnedInstances$1 = new WeakSet();\n\nvar TypeBox = function (_Type) {\n  inherits(TypeBox, _Type);\n\n  function TypeBox() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeBox);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeBox.__proto__ || Object.getPrototypeOf(TypeBox)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeBox', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeBox, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this.type;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.type.toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.type.toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      return this.type.name;\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var reveal = this.reveal;\n\n      var type = reveal();\n      if (!type) {\n        if (!warnedInstances$1.has(this)) {\n          this.context.emitWarningMessage('Failed to reveal boxed type.');\n          warnedInstances$1.add(this);\n        }\n        return this.context.mixed();\n      } else if (!(type instanceof Type)) {\n        // we got a boxed reference to something like a class\n        return this.context.ref(type);\n      }\n      return type;\n    }\n  }]);\n  return TypeBox;\n}(Type);\n\nvar warnedMissing = {};\n\nvar TypeReference = function (_Type) {\n  inherits(TypeReference, _Type);\n\n  function TypeReference() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeReference);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeReference.__proto__ || Object.getPrototypeOf(TypeReference)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeReference', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(TypeReference, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.type, input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = this;\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type.unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        name: this.name\n      };\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var context = this.context,\n          name = this.name;\n\n      var type = context.get(name);\n      if (!type) {\n        if (!warnedMissing[name]) {\n          context.emitWarningMessage('Cannot resolve type: ' + name);\n          warnedMissing[name] = true;\n        }\n        return context.any();\n      }\n      return type;\n    }\n  }]);\n  return TypeReference;\n}(Type);\n\nvar warnedInstances$2 = new WeakSet();\n\nvar RevealedName = Symbol('RevealedName');\nvar RevealedValue = Symbol('RevealedValue');\n\nvar TypeTDZ = function (_Type) {\n  inherits(TypeTDZ, _Type);\n\n  function TypeTDZ() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TypeTDZ);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TypeTDZ.__proto__ || Object.getPrototypeOf(TypeTDZ)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeTDZ', _this[RevealedName] = undefined, _this[RevealedValue] = undefined, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeTDZ, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(getRevealed(this).errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return getRevealed(this).accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(getRevealed(this), input);\n    }\n  }, {\n    key: 'apply',\n    value: function apply() {\n      var target = new TypeParameterApplication(this.context);\n      target.parent = getRevealed(this);\n\n      for (var _len2 = arguments.length, typeInstances = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeInstances[_key2] = arguments[_key2];\n      }\n\n      target.typeInstances = typeInstances;\n      return target;\n    }\n\n    /**\n     * Get the inner type or value.\n     */\n\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return getRevealed(this).unwrap();\n    }\n  }, {\n    key: 'hasProperty',\n    value: function hasProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.hasProperty === 'function') {\n        return inner.hasProperty(name);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: 'getProperty',\n    value: function getProperty(name) {\n      var inner = this.unwrap();\n      if (inner && typeof inner.getProperty === 'function') {\n        return inner.getProperty(name);\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return getRevealed(this).toString();\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return getRevealed(this).toJSON();\n    }\n  }, {\n    key: 'name',\n    get: function get$$1() {\n      var name = this[RevealedName];\n      if (!name) {\n        name = getRevealed(this).name;\n      }\n      return name;\n    },\n    set: function set$$1(value) {\n      this[RevealedName] = value;\n    }\n  }]);\n  return TypeTDZ;\n}(Type);\n\nfunction getRevealed(container) {\n  var existing = container[RevealedValue];\n  if (existing) {\n    return existing;\n  } else {\n    var reveal = container.reveal;\n\n    var type = reveal();\n    if (!type) {\n      if (!warnedInstances$2.has(container)) {\n        var name = container[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage('Failed to reveal type called \"' + name + '\" in Temporal Dead Zone.');\n        } else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances$2.add(container);\n      }\n      return container.context.mixed();\n    } else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\nvar UnionType = function (_Type) {\n  inherits(UnionType, _Type);\n\n  function UnionType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, UnionType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnionType.__proto__ || Object.getPrototypeOf(UnionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'UnionType', _this.types = [], _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(UnionType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var types, length, i, type;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              types = this.types;\n              length = types.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 10;\n                break;\n              }\n\n              type = types[i];\n\n              if (!type.accepts(input)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 7:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 10:\n              _context.next = 12;\n              return [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var types = this.types;\n      var length = types.length;\n\n      for (var i = 0; i < length; i++) {\n        var type = types[i];\n        if (type.accepts(input)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var types = this.types;\n      if (input instanceof UnionType) {\n        var inputTypes = input.types;\n        var identicalCount = 0;\n        loop: for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          for (var j = 0; j < inputTypes.length; j++) {\n            var result = compareTypes(type, inputTypes[i]);\n            if (result === 0) {\n              identicalCount++;\n              continue loop;\n            } else if (result === 1) {\n              continue loop;\n            }\n          }\n          // if we got this far then nothing accepted this type.\n          return -1;\n        }\n\n        if (identicalCount === types.length) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        for (var _i = 0; _i < types.length; _i++) {\n          var _type = types[_i];\n          if (compareTypes(_type, input) >= 0) {\n            return 1;\n          }\n        }\n        return -1;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var types = this.types;\n\n      var normalized = new Array(types.length);\n      for (var i = 0; i < types.length; i++) {\n        var type = types[i];\n        if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n          normalized[i] = '(' + type.toString() + ')';\n        } else {\n          normalized[i] = type.toString();\n        }\n      }\n      return normalized.join(' | ');\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        types: this.types\n      };\n    }\n  }]);\n  return UnionType;\n}(Type);\n\nfunction registerPrimitiveTypes(t) {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\nfunction registerBuiltinTypeConstructors(t) {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (input instanceof Date) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n\n            case 3:\n              _context.next = 8;\n              break;\n\n            case 5:\n              if (!isNaN(input.getTime())) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return [path, getErrorMessage('ERR_INVALID_DATE'), this];\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, futureType) {\n      var context;\n      return _regeneratorRuntime.wrap(function errors$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              invariant(futureType, 'Must specify type parameter for Promise.');\n              context = this.context;\n\n              if (context.checkPredicate('Promise', input)) {\n                _context2.next = 5;\n                break;\n              }\n\n              _context2.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n\n            case 5:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, errors, this);\n    }),\n    accepts: function accepts(input) {\n      var context = this.context;\n\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, keyType, valueType) {\n      var context, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref, _ref2, key, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              invariant(keyType, 'Must specify two type parameters for Map.');\n              invariant(valueType, 'Must specify two type parameters for Map.');\n              context = this.context;\n\n              if (context.checkPredicate('Map', input)) {\n                _context3.next = 7;\n                break;\n              }\n\n              _context3.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n\n            case 6:\n              return _context3.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context3.prev = 10;\n              _iterator = input[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context3.next = 24;\n                break;\n              }\n\n              _ref = _step.value;\n              _ref2 = slicedToArray(_ref, 2);\n              key = _ref2[0];\n              value = _ref2[1];\n\n              if (keyType.accepts(key)) {\n                _context3.next = 20;\n                break;\n              }\n\n              _context3.next = 20;\n              return [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n\n            case 20:\n              return _context3.delegateYield(valueType.errors(validation, path.concat(key), value), 't0', 21);\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context3.next = 12;\n              break;\n\n            case 24:\n              _context3.next = 30;\n              break;\n\n            case 26:\n              _context3.prev = 26;\n              _context3.t1 = _context3['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context3.t1;\n\n            case 30:\n              _context3.prev = 30;\n              _context3.prev = 31;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 33:\n              _context3.prev = 33;\n\n              if (!_didIteratorError) {\n                _context3.next = 36;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 36:\n              return _context3.finish(33);\n\n            case 37:\n              return _context3.finish(30);\n\n            case 38:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, errors, this, [[10, 26, 30, 38], [31,, 33, 37]]);\n    }),\n    accepts: function accepts(input, keyType, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref3 = _step2.value;\n\n          var _ref4 = slicedToArray(_ref3, 2);\n\n          var key = _ref4[0];\n          var value = _ref4[1];\n\n          if (!keyType.accepts(key) || !valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var keyTypes = [];\n      var valueTypes = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        loop: for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref5 = _step3.value;\n\n          var _ref6 = slicedToArray(_ref5, 2);\n\n          var key = _ref6[0];\n          var value = _ref6[1];\n\n          findKey: {\n            for (var i = 0; i < keyTypes.length; i++) {\n              var type = keyTypes[i];\n              if (type.accepts(key)) {\n                break findKey;\n              }\n            }\n            keyTypes.push(t.typeOf(key));\n          }\n\n          for (var _i = 0; _i < valueTypes.length; _i++) {\n            var _type = valueTypes[_i];\n            if (_type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      } else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      } else {\n        typeInstances.push(t.union.apply(t, valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    errors: _regeneratorRuntime.mark(function errors(validation, path, input, valueType) {\n      var context, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              invariant(valueType, 'Must specify type parameter for Set.');\n              context = this.context;\n\n              if (context.checkPredicate('Set', input)) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 5;\n              return [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n\n            case 5:\n              return _context4.abrupt('return');\n\n            case 6:\n              _iteratorNormalCompletion4 = true;\n              _didIteratorError4 = false;\n              _iteratorError4 = undefined;\n              _context4.prev = 9;\n              _iterator4 = input[Symbol.iterator]();\n\n            case 11:\n              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                _context4.next = 17;\n                break;\n              }\n\n              value = _step4.value;\n              return _context4.delegateYield(valueType.errors(validation, path, value), 't0', 14);\n\n            case 14:\n              _iteratorNormalCompletion4 = true;\n              _context4.next = 11;\n              break;\n\n            case 17:\n              _context4.next = 23;\n              break;\n\n            case 19:\n              _context4.prev = 19;\n              _context4.t1 = _context4['catch'](9);\n              _didIteratorError4 = true;\n              _iteratorError4 = _context4.t1;\n\n            case 23:\n              _context4.prev = 23;\n              _context4.prev = 24;\n\n              if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n              }\n\n            case 26:\n              _context4.prev = 26;\n\n              if (!_didIteratorError4) {\n                _context4.next = 29;\n                break;\n              }\n\n              throw _iteratorError4;\n\n            case 29:\n              return _context4.finish(26);\n\n            case 30:\n              return _context4.finish(23);\n\n            case 31:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, errors, this, [[9, 19, 23, 31], [24,, 26, 30]]);\n    }),\n    accepts: function accepts(input, valueType) {\n      var context = this.context;\n\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var value = _step5.value;\n\n          if (!valueType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    },\n    inferTypeParameters: function inferTypeParameters(input) {\n      var valueTypes = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        loop: for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var value = _step6.value;\n\n          for (var i = 0; i < valueTypes.length; i++) {\n            var type = valueTypes[i];\n            if (type.accepts(value)) {\n              continue loop;\n            }\n          }\n          valueTypes.push(t.typeOf(value));\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      } else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      } else {\n        return [t.union.apply(t, valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\nfunction registerTypePredicates(context) {\n  context.setPredicate('Array', function (input) {\n    return Array.isArray(input);\n  });\n  context.setPredicate('Map', function (input) {\n    return input instanceof Map;\n  });\n  context.setPredicate('Set', function (input) {\n    return input instanceof Set;\n  });\n  context.setPredicate('Promise', function (input) {\n    if (input instanceof Promise) {\n      return true;\n    } else if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && typeof input.then === 'function') {\n      return input.then.length >= 2;\n    } else {\n      return false;\n    }\n  });\n}\n\nvar TypeInferer = function () {\n  function TypeInferer(context) {\n    classCallCheck(this, TypeInferer);\n\n    this.context = context;\n  }\n\n  createClass(TypeInferer, [{\n    key: 'infer',\n    value: function infer(input) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      var inferred = new Map();\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferInternal',\n    value: function inferInternal(input, inferred) {\n      var primitive = this.inferPrimitive(input);\n      if (primitive) {\n        return primitive;\n      }\n      return this.inferComplex(input, inferred);\n    }\n  }, {\n    key: 'inferPrimitive',\n    value: function inferPrimitive(input) {\n      var context = this.context;\n\n      if (input === null) {\n        return context.null();\n      } else if (input === undefined) {\n        return context.void();\n      } else if (typeof input === 'number') {\n        return context.number();\n      } else if (typeof input === 'boolean') {\n        return context.boolean();\n      } else if (typeof input === 'string') {\n        return context.string();\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return context.symbol(input);\n        } else {\n          return undefined;\n        }\n    }\n  }, {\n    key: 'inferComplex',\n    value: function inferComplex(input, inferred) {\n      var context = this.context;\n\n\n      if (typeof input === 'function') {\n        return this.inferFunction(input, inferred);\n      } else if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\n        return this.inferObject(input, inferred);\n      } else {\n        return context.any();\n      }\n    }\n  }, {\n    key: 'inferFunction',\n    value: function inferFunction(input, inferred) {\n      var context = this.context;\n      var length = input.length;\n\n      var body = new Array(length + 1);\n      for (var i = 0; i < length; i++) {\n        body[i] = context.param(String.fromCharCode(97 + i), context.existential());\n      }\n      body[length] = context.return(context.existential());\n      return context.fn.apply(context, body);\n    }\n  }, {\n    key: 'inferObject',\n    value: function inferObject(input, inferred) {\n      var existing = inferred.get(input);\n      if (existing) {\n        return existing;\n      }\n      var context = this.context;\n\n      var type = void 0;\n\n      // Temporarily create a box for this type to catch cyclical references.\n      // Nested references to this object will receive the boxed type.\n      var box = context.box(function () {\n        return type;\n      });\n      inferred.set(input, box);\n\n      if (context.checkPredicate('Array', input)) {\n        type = this.inferArray(input, inferred);\n      } else if (!(input instanceof Object)) {\n        type = this.inferDict(input, inferred);\n      } else if (input.constructor !== Object) {\n        var handler = context.getTypeConstructor(input.constructor);\n        if (handler) {\n          var typeParameters = handler.inferTypeParameters(input);\n          type = handler.apply.apply(handler, toConsumableArray(typeParameters));\n        } else {\n          type = context.ref(input.constructor);\n        }\n      } else {\n        var body = [];\n        for (var key in input) {\n          // eslint-disable-line\n          var value = input[key];\n          body.push(context.property(key, this.inferInternal(value, inferred)));\n        }\n        type = context.object.apply(context, body);\n      }\n\n      // Overwrite the box with the real value.\n      inferred.set(input, type);\n      return type;\n    }\n  }, {\n    key: 'inferDict',\n    value: function inferDict(input, inferred) {\n      var numericIndexers = [];\n      var stringIndexers = [];\n      loop: for (var key in input) {\n        // eslint-disable-line\n        var value = input[key];\n        var types = isNaN(+key) ? stringIndexers : numericIndexers;\n        for (var i = 0; i < types.length; i++) {\n          var type = types[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        types.push(this.inferInternal(value, inferred));\n      }\n\n      var context = this.context;\n\n      var body = [];\n      if (numericIndexers.length === 1) {\n        body.push(context.indexer('index', context.number(), numericIndexers[0]));\n      } else if (numericIndexers.length > 1) {\n        body.push(context.indexer('index', context.number(), context.union.apply(context, numericIndexers)));\n      }\n\n      if (stringIndexers.length === 1) {\n        body.push(context.indexer('key', context.string(), stringIndexers[0]));\n      } else if (stringIndexers.length > 1) {\n        body.push(context.indexer('key', context.string(), context.union.apply(context, stringIndexers)));\n      }\n\n      return context.object.apply(context, body);\n    }\n  }, {\n    key: 'inferArray',\n    value: function inferArray(input, inferred) {\n      var context = this.context;\n\n      var types = [];\n      var values = [];\n      var length = input.length;\n\n      loop: for (var i = 0; i < length; i++) {\n        var item = input[i];\n        var inferredType = this.inferInternal(item, inferred);\n        for (var j = 0; j < types.length; j++) {\n          var type = types[j];\n          if (type.accepts(item) && inferredType.accepts(values[j])) {\n            continue loop;\n          }\n        }\n        types.push(inferredType);\n        values.push(item);\n      }\n      if (types.length === 0) {\n        return context.array(context.any());\n      } else if (types.length === 1) {\n        return context.array(types[0]);\n      } else {\n        return context.array(context.union.apply(context, types));\n      }\n    }\n  }]);\n  return TypeInferer;\n}();\n\nfunction makeReactPropTypes(objectType) {\n  var output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n\n  var _loop = function _loop(property) {\n    output[property.key] = function (props, propName, componentName) {\n      return makeError(property, props);\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = objectType.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return output;\n}\n\nvar delimiter$1 = '\\n-------------------------------------------------\\n\\n';\n\nfunction makeWarningMessage(validation) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  var input = validation.input,\n      context = validation.context;\n\n  var collected = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validation.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = slicedToArray(_ref, 3);\n\n      var path = _ref2[0];\n      var message = _ref2[1];\n      var expectedType = _ref2[2];\n\n      var expected = expectedType ? expectedType.toString() : \"*\";\n      var actual = context.typeOf(_resolvePath(input, path)).toString();\n\n      var field = stringifyPath(validation.path.concat(path));\n\n      collected.push(field + ' ' + message + '\\n\\nExpected: ' + expected + '\\n\\nActual: ' + actual + '\\n');\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return 'Warning: ' + collected.join(delimiter$1);\n}\n\nfunction makeUnion(context, types) {\n  var length = types.length;\n  var merged = [];\n  for (var i = 0; i < length; i++) {\n    var type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return type;\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    } else {\n      merged.push(type);\n    }\n  }\n  var union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes(aTypes, bTypes) {\n  loop: for (var i = 0; i < bTypes.length; i++) {\n    var bType = bTypes[i];\n    for (var j = 0; j < aTypes.length; j++) {\n      var aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\nfunction makePropertyDescriptor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert);\n  } else {\n    return propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert);\n  }\n}\n\nfunction makePropertyName(name) {\n  return '_flowRuntime$' + name;\n}\n\nfunction getClassName(input) {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  } else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  } else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType(receiver, typeSource) {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  } else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor(typeSource, input, propertyName, descriptor, shouldAssert) {\n  var safeName = makePropertyName(propertyName);\n  var className = getClassName(input);\n  var initializer = descriptor.initializer,\n      writable = descriptor.writable,\n      config = objectWithoutProperties(descriptor, ['initializer', 'writable']); // eslint-disable-line no-unused-vars\n\n  var propertyPath = [className, propertyName];\n\n  return _extends({}, config, {\n    type: 'accessor',\n    get: function get$$1() {\n      if (safeName in this) {\n        return this[safeName];\n      } else if (initializer) {\n        var type = resolveType(this, typeSource);\n        var _value = initializer.call(this);\n        var context = type.context;\n        context.check(type, _value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: _value\n        });\n        return _value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set: function set$$1(value) {\n      var type = resolveType(this, typeSource);\n      var context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      } else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      } else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  });\n}\n\nfunction augmentExistingAccessors(typeSource, input, propertyName, descriptor, shouldAssert) {\n\n  var className = getClassName(input);\n  var propertyPath = [className, propertyName];\n\n  var originalSetter = descriptor.set;\n\n  descriptor.set = function set$$1(value) {\n    var type = resolveType(this, typeSource);\n    var context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    } else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n}\n\n// eslint-disable-line no-redeclare\n\nfunction annotateValue(input, type) {\n  // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  } else {\n    var _ret = function () {\n      var type = input;\n      return {\n        v: function v(input) {\n          input[TypeSymbol] = type;\n          return input;\n        }\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n}\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nvar $DiffType = function (_Type) {\n  inherits($DiffType, _Type);\n\n  function $DiffType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $DiffType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $DiffType.__proto__ || Object.getPrototypeOf($DiffType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$DiffType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($DiffType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var aType, bType, properties, i, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              aType = this.aType, bType = this.bType;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              aType = aType.unwrap();\n              bType = bType.unwrap();\n              invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n              properties = aType.properties;\n              i = 0;\n\n            case 10:\n              if (!(i < properties.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!bType.hasProperty(property.key)) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt('continue', 15);\n\n            case 14:\n              return _context.delegateYield(property.errors(validation, path.concat(property.key), input), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 10;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var aType = this.aType,\n          bType = this.bType;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        if (!property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var aType = this.aType,\n          bType = this.bType;\n\n      aType = aType.unwrap();\n      bType = bType.unwrap();\n      invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n      var properties = aType.properties;\n      var args = [];\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        if (bType.hasProperty(property.key)) {\n          continue;\n        }\n        args.push(property);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Diff<' + this.aType.toString() + ', ' + this.bType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        aType: this.aType,\n        bType: this.bType\n      };\n    }\n  }]);\n  return $DiffType;\n}(Type);\n\n// Any subtype of T\n\nvar $FlowFixMeType = function (_Type) {\n  inherits($FlowFixMeType, _Type);\n\n  function $FlowFixMeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $FlowFixMeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $FlowFixMeType.__proto__ || Object.getPrototypeOf($FlowFixMeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$FlowFixMeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($FlowFixMeType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, input) {\n      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return 1;\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$FlowFixMe';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName\n      };\n    }\n  }]);\n  return $FlowFixMeType;\n}(Type);\n\n// The set of keys of T.\n\nvar $KeysType = function (_Type) {\n  inherits($KeysType, _Type);\n\n  function $KeysType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $KeysType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $KeysType.__proto__ || Object.getPrototypeOf($KeysType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$KeysType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($KeysType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, properties, length, i, property, keys, _i;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type.unwrap();\n\n              invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n              properties = type.properties;\n              length = properties.length;\n              i = 0;\n\n            case 5:\n              if (!(i < length)) {\n                _context.next = 12;\n                break;\n              }\n\n              property = properties[i];\n\n              if (!(input === property.key)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt('return');\n\n            case 9:\n              i++;\n              _context.next = 5;\n              break;\n\n            case 12:\n              keys = new Array(length);\n\n              for (_i = 0; _i < length; _i++) {\n                keys[_i] = properties[_i].key;\n              }\n              _context.next = 16;\n              return [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        if (input === property.key) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var context = this.context;\n      var type = this.type.unwrap();\n      invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n      var properties = type.properties;\n      var length = properties.length;\n      var keys = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var property = properties[i];\n        keys[i] = context.literal(property.key);\n      }\n      return (_context2 = this.context).union.apply(_context2, keys);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Keys<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $KeysType;\n}(Type);\n\n// Map over the keys and values in an object.\n\nvar $ObjMapiType = function (_Type) {\n  inherits($ObjMapiType, _Type);\n\n  function $ObjMapiType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapiType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapiType.__proto__ || Object.getPrototypeOf($ObjMapiType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapiType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapiType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key), prop.value);\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key), prop.value)));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMapi<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapiType;\n}(Type);\n\n// Map over the keys in an object.\n\nvar $ObjMapType = function (_Type) {\n  inherits($ObjMapType, _Type);\n\n  function $ObjMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ObjMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ObjMapType.__proto__ || Object.getPrototypeOf($ObjMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ObjMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ObjMapType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var object, mapper, context, target, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, applied, returnType, value;\n\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              object = this.object, mapper = this.mapper, context = this.context;\n              target = object.unwrap();\n\n              invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 10;\n              _iterator = target.properties[Symbol.iterator]();\n\n            case 12:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              prop = _step.value;\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              returnType = applied.invoke(context.literal(prop.key));\n              value = input[prop.key];\n              return _context.delegateYield(returnType.errors(validation, path.concat(prop.key), value), 't0', 19);\n\n            case 19:\n              _iteratorNormalCompletion = true;\n              _context.next = 12;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context['catch'](10);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n\n            case 31:\n              _context.prev = 31;\n\n              if (!_didIteratorError) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 34:\n              return _context.finish(31);\n\n            case 35:\n              return _context.finish(28);\n\n            case 36:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this, [[10, 24, 28, 36], [29,, 31, 35]]);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var prop = _step2.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          var returnType = applied.invoke(context.literal(prop.key));\n\n          var value = input[prop.key];\n          if (!returnType.accepts(value)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = object.unwrap();\n      invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n      var args = [];\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var prop = _step3.value;\n\n          var applied = mapper.unwrap();\n          invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n          args.push(context.property(prop.key, applied.invoke(context.literal(prop.key))));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return context.object.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$ObjMap<' + this.object.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $ObjMapType;\n}(Type);\n\n// The type of the named object property\n\nvar $PropertyType = function (_Type) {\n  inherits($PropertyType, _Type);\n\n  function $PropertyType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $PropertyType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $PropertyType.__proto__ || Object.getPrototypeOf($PropertyType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$PropertyType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($PropertyType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.unwrap().errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.unwrap().accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var object = this.object,\n          property = this.property;\n\n      var unwrapped = object.unwrap();\n      invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n      return unwrapped.getProperty(property).unwrap();\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$PropertyType<' + this.object.toString() + ', ' + String(this.property) + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        object: this.object,\n        property: this.property\n      };\n    }\n  }]);\n  return $PropertyType;\n}(Type);\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nvar $ShapeType = function (_Type) {\n  inherits($ShapeType, _Type);\n\n  function $ShapeType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $ShapeType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $ShapeType.__proto__ || Object.getPrototypeOf($ShapeType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$ShapeType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($ShapeType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var type, key, property;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              type = this.type;\n\n              if (!(input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n\n              type = type.unwrap();\n              invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n              _context.t0 = _regeneratorRuntime.keys(input);\n\n            case 8:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              key = _context.t1.value;\n              // eslint-disable-line guard-for-in\n              property = type.getProperty(key);\n\n              if (property) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt('continue', 8);\n\n            case 13:\n              return _context.delegateYield(property.errors(validation, path, input), 't2', 14);\n\n            case 14:\n              _context.next = 8;\n              break;\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var type = this.type;\n\n      if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object' && typeof input !== 'function') {\n        return false;\n      }\n      type = type.unwrap();\n      invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n      for (var key in input) {\n        // eslint-disable-line guard-for-in\n        var property = type.getProperty(key);\n        if (!property || !property.accepts(input)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var _context2;\n\n      var type = this.type;\n\n      type = type.unwrap();\n      var context = this.context;\n      invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n      var properties = type.properties;\n      var args = new Array(properties.length);\n      for (var i = 0; i < properties.length; i++) {\n        var property = properties[i];\n        args[i] = context.property(property.key, property.value, true);\n      }\n      return (_context2 = this.context).object.apply(_context2, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Shape<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $ShapeType;\n}(Type);\n\n// Any subtype of T\n\nvar $SubType = function (_Type) {\n  inherits($SubType, _Type);\n\n  function $SubType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SubType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SubType.__proto__ || Object.getPrototypeOf($SubType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SubType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SubType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(input, path), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Subtype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SubType;\n}(Type);\n\n// Any, but at least T.\n\nvar $SuperType = function (_Type) {\n  inherits($SuperType, _Type);\n\n  function $SuperType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $SuperType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $SuperType.__proto__ || Object.getPrototypeOf($SuperType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$SuperType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($SuperType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.type.errors(validation, path, input), 't0', 1);\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      return this.type.accepts(input);\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      return this.type;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$Supertype<' + this.type.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        type: this.type\n      };\n    }\n  }]);\n  return $SuperType;\n}(Type);\n\n// Map over the values in a tuple.\n\nvar $TupleMapType = function (_Type) {\n  inherits($TupleMapType, _Type);\n\n  function $TupleMapType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, $TupleMapType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = $TupleMapType.__proto__ || Object.getPrototypeOf($TupleMapType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = '$TupleMapType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass($TupleMapType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var tuple, mapper, context, target, i, type, applied, expected, value;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              tuple = this.tuple, mapper = this.mapper, context = this.context;\n              target = tuple.unwrap();\n\n              invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n              if (context.checkPredicate('Array', input)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n\n            case 6:\n              return _context.abrupt('return');\n\n            case 7:\n              i = 0;\n\n            case 8:\n              if (!(i < target.types.length)) {\n                _context.next = 18;\n                break;\n              }\n\n              type = target.types[i];\n              applied = mapper.unwrap();\n\n              invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n              expected = applied.invoke(type);\n              value = input[i];\n              return _context.delegateYield(expected.errors(validation, path.concat(i), value), 't0', 15);\n\n            case 15:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 18:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n      if (!context.checkPredicate('Array', input)) {\n        return false;\n      }\n\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        if (!applied.invoke(type).accepts(input[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      return compareTypes(this.unwrap(), input);\n    }\n  }, {\n    key: 'unwrap',\n    value: function unwrap() {\n      var tuple = this.tuple,\n          mapper = this.mapper,\n          context = this.context;\n\n      var target = tuple.unwrap();\n      invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n      var args = [];\n      for (var i = 0; i < target.types.length; i++) {\n        var type = target.types[i];\n        var applied = mapper.unwrap();\n        invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n        args.push(applied.invoke(type).unwrap().unwrap());\n      }\n\n      return context.tuple.apply(context, args);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '$TupleMap<' + this.tuple.toString() + ', ' + this.mapper.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        tuple: this.tuple,\n        mapper: this.mapper\n      };\n    }\n  }]);\n  return $TupleMapType;\n}(Type);\n\nfunction checkGenericType(context, expected, input) {\n  var impl = expected.impl;\n\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  } else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  var annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  } else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType(context, expected, input) {\n  var annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    var result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\nvar ClassType = function (_Type) {\n  inherits(ClassType, _Type);\n\n  function ClassType() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ClassType);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ClassType.__proto__ || Object.getPrototypeOf(ClassType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ClassType', _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(ClassType, [{\n    key: 'errors',\n    value: _regeneratorRuntime.mark(function errors(validation, path, input) {\n      var instanceType, context, expectedType, isValid;\n      return _regeneratorRuntime.wrap(function errors$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              instanceType = this.instanceType, context = this.context;\n\n              if (!(typeof input !== 'function')) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 4:\n              return _context.abrupt('return');\n\n            case 5:\n              expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n              isValid = expectedType instanceof GenericType ? checkGenericType(context, expectedType, input) : checkType(context, expectedType, input);\n\n              if (isValid) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 10;\n              return [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n\n            case 10:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, errors, this);\n    })\n  }, {\n    key: 'accepts',\n    value: function accepts(input) {\n      var instanceType = this.instanceType,\n          context = this.context;\n\n      if (typeof input !== 'function') {\n        return false;\n      }\n      var expectedType = instanceType.typeName === 'ClassDeclaration' ? instanceType : instanceType.unwrap();\n      if (expectedType instanceof GenericType) {\n        return checkGenericType(context, expectedType, input);\n      } else {\n        return checkType(context, expectedType, input);\n      }\n    }\n  }, {\n    key: 'compareWith',\n    value: function compareWith(input) {\n      var instanceType = this.instanceType;\n\n      if (input instanceof ClassType) {\n        return compareTypes(instanceType, input.instanceType);\n      }\n      return -1;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return 'Class<' + this.instanceType.toString() + '>';\n    }\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        typeName: this.typeName,\n        instanceType: this.instanceType\n      };\n    }\n  }]);\n  return ClassType;\n}(Type);\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nvar warnedInvalidReferences = new WeakSet();\n\nvar TypeContext = function () {\n  function TypeContext() {\n    classCallCheck(this, TypeContext);\n    this.mode = 'assert';\n    this[NameRegistrySymbol] = {};\n    this[TypePredicateRegistrySymbol] = {};\n    this[TypeConstructorRegistrySymbol] = new Map();\n    this[InferrerSymbol] = new TypeInferer(this);\n    this[ModuleRegistrySymbol] = {};\n  }\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  // Issue 252\n\n\n  createClass(TypeContext, [{\n    key: 'makeJSONError',\n    value: function makeJSONError$$1(validation) {\n      return makeJSONError(validation);\n    }\n  }, {\n    key: 'makeTypeError',\n    value: function makeTypeError$$1(validation) {\n      return makeTypeError(validation);\n    }\n  }, {\n    key: 'createContext',\n    value: function createContext() {\n      var context = new TypeContext();\n      // Issue 252\n      context[ParentSymbol] = this;\n      return context;\n    }\n  }, {\n    key: 'typeOf',\n    value: function typeOf(input) {\n\n      var annotation = this.getAnnotation(input);\n      if (annotation) {\n        if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n          return this.Class(annotation);\n        }\n        return annotation;\n      }\n      // Issue 252\n      var inferrer = this[InferrerSymbol];\n      inferrer;\n\n      return inferrer.infer(input);\n    }\n  }, {\n    key: 'compareTypes',\n    value: function compareTypes$$1(a, b) {\n      return compareTypes(a, b);\n    }\n  }, {\n    key: 'get',\n    value: function get$$1(name) {\n      // Issue 252\n      var item = this[NameRegistrySymbol][name];\n\n      for (var _len = arguments.length, propertyNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        propertyNames[_key - 1] = arguments[_key];\n      }\n\n      if (item != null) {\n        var current = typeof item === 'function' ? new item(this) : item;\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n          if (typeof current.getProperty !== 'function') {\n            return;\n          }\n          current = current.getProperty(propertyName);\n          if (!current) {\n            return;\n          }\n          current = current.unwrap();\n        }\n        return current;\n      }\n      // Issue 252\n      var parent = this[ParentSymbol];\n      if (parent) {\n        var fromParent = parent.get.apply(parent, [name].concat(toConsumableArray(propertyNames)));\n        if (fromParent) {\n          return fromParent;\n        }\n      }\n\n      // if we got this far, see if we have a global type with this name.\n      if (typeof global[name] === 'function') {\n        var target = new GenericType(this);\n        target.name = name;\n        target.impl = global[name];\n        // Issue 252\n        this[NameRegistrySymbol][name] = target;\n        return target;\n      }\n    }\n\n    /**\n     * Get the predicate for a given type name.\n     * e.g. `t.getPredicate('Array')`.\n     */\n\n  }, {\n    key: 'getPredicate',\n    value: function getPredicate(name) {\n      var item = this[TypePredicateRegistrySymbol][name];\n      if (item) {\n        return item;\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.getPredicate(name);\n      }\n    }\n\n    /**\n     * Set the predicate for a given type name.\n     * This can be used to customise the behaviour of things like Array\n     * detection or allowing Thenables in place of the global Promise.\n     */\n\n  }, {\n    key: 'setPredicate',\n    value: function setPredicate(name, predicate) {\n      this[TypePredicateRegistrySymbol][name] = predicate;\n    }\n\n    /**\n     * Check the given value against the named predicate.\n     * Returns false if no such predicate exists.\n     * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n     */\n\n  }, {\n    key: 'checkPredicate',\n    value: function checkPredicate(name, input) {\n      var predicate = this.getPredicate(name);\n      if (predicate) {\n        return predicate(input);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Returns a decorator for a function or object with the given type.\n     */\n\n  }, {\n    key: 'decorate',\n    value: function decorate(type, shouldAssert) {\n      var _this2 = this;\n\n      if (shouldAssert == null) {\n        shouldAssert = this.mode === 'assert';\n      }\n      return function (input, propertyName, descriptor) {\n        if (descriptor && typeof propertyName === 'string') {\n          return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n        } else {\n          invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n          return _this2.annotate(input, type);\n        }\n      };\n    }\n\n    /**\n     * Annotates an object or function with the given type.\n     * If a type is specified as the sole argument, returns a\n     * function which can decorate classes or functions with the given type.\n     */\n\n  }, {\n    key: 'annotate',\n    value: function annotate(input, type) {\n      if (type === undefined) {\n        return annotateValue(input);\n      } else {\n        return annotateValue(input, type);\n      }\n    }\n  }, {\n    key: 'getAnnotation',\n    value: function getAnnotation(input) {\n      if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' || typeof input === 'function') {\n        // Issue 252\n        return input[TypeSymbol];\n      }\n    }\n  }, {\n    key: 'hasAnnotation',\n    value: function hasAnnotation(input) {\n      if (input == null) {\n        return false;\n      } else {\n        return input[TypeSymbol] ? true : false;\n      }\n    }\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(input, type) {\n      input[TypeSymbol] = type;\n      return input;\n    }\n  }, {\n    key: 'type',\n    value: function type(name, _type) {\n      if (typeof _type === 'function') {\n        var target = new ParameterizedTypeAlias(this);\n        target.name = name;\n        target.typeCreator = _type;\n        return target;\n      } else {\n        var _target = new TypeAlias(this);\n        _target.name = name;\n        _target.type = _type;\n        return _target;\n      }\n    }\n  }, {\n    key: 'declare',\n    value: function declare(name, type) {\n\n      if (name instanceof Declaration) {\n        type = name;\n        name = type.name;\n      } else if (name instanceof TypeAlias) {\n        type = name;\n        name = type.name;\n      }\n      if (typeof type === 'function') {\n        type = this.type(name, type);\n      }\n      if (type instanceof ModuleDeclaration) {\n        var moduleRegistry = this[ModuleRegistrySymbol];\n        moduleRegistry[name] = type;\n        return type;\n      } else {\n        invariant(typeof name === 'string', 'Name must be a string');\n        invariant(type instanceof Type, 'Type must be supplied to declaration');\n        var nameRegistry = this[NameRegistrySymbol];\n\n        if (type instanceof Declaration) {\n          nameRegistry[name] = type;\n          return type;\n        } else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n          var target = new TypeDeclaration(this);\n          target.name = name;\n          target.typeAlias = type;\n          nameRegistry[name] = target;\n          return target;\n        } else {\n          var _target2 = this.var(name, type);\n          nameRegistry[name] = _target2;\n          return _target2;\n        }\n      }\n    }\n  }, {\n    key: 'declarations',\n    value: _regeneratorRuntime.mark(function declarations() {\n      var nameRegistry, key;\n      return _regeneratorRuntime.wrap(function declarations$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              nameRegistry = this[NameRegistrySymbol];\n              _context.t0 = _regeneratorRuntime.keys(nameRegistry);\n\n            case 2:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 8;\n                break;\n              }\n\n              key = _context.t1.value;\n              _context.next = 6;\n              return [key, nameRegistry[key]];\n\n            case 6:\n              _context.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, declarations, this);\n    })\n  }, {\n    key: 'modules',\n    value: _regeneratorRuntime.mark(function modules() {\n      var moduleRegistry, key;\n      return _regeneratorRuntime.wrap(function modules$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              moduleRegistry = this[ModuleRegistrySymbol];\n              _context2.t0 = _regeneratorRuntime.keys(moduleRegistry);\n\n            case 2:\n              if ((_context2.t1 = _context2.t0()).done) {\n                _context2.next = 8;\n                break;\n              }\n\n              key = _context2.t1.value;\n              _context2.next = 6;\n              return moduleRegistry[key];\n\n            case 6:\n              _context2.next = 2;\n              break;\n\n            case 8:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, modules, this);\n    })\n  }, {\n    key: 'import',\n    value: function _import(moduleName) {\n      var moduleRegistry = this[ModuleRegistrySymbol];\n      if (moduleRegistry[moduleName]) {\n        return moduleRegistry[moduleName];\n      }\n\n      var _moduleName$split = moduleName.split('/'),\n          _moduleName$split2 = slicedToArray(_moduleName$split, 1),\n          head = _moduleName$split2[0];\n\n      var module = moduleRegistry[head];\n      if (module) {\n        return module.import(moduleName);\n      }\n      var parent = this[ParentSymbol];\n      if (parent) {\n        return parent.import(moduleName);\n      }\n    }\n  }, {\n    key: 'declareTypeConstructor',\n    value: function declareTypeConstructor(_ref) {\n      var name = _ref.name,\n          impl = _ref.impl,\n          typeName = _ref.typeName,\n          errors = _ref.errors,\n          accepts = _ref.accepts,\n          inferTypeParameters = _ref.inferTypeParameters;\n\n      var nameRegistry = this[NameRegistrySymbol];\n\n      if (nameRegistry[name]) {\n        this.emitWarningMessage('Redeclaring type: ' + name + ', this may be unintended.');\n      }\n\n      var target = new TypeConstructor(this);\n      target.name = name;\n      target.typeName = typeName;\n      target.impl = impl;\n      target.errors = errors;\n      target.accepts = accepts;\n      target.inferTypeParameters = inferTypeParameters;\n\n      nameRegistry[name] = target;\n\n      if (typeof impl === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        if (handlerRegistry.has(impl)) {\n          this.emitWarningMessage('A type handler already exists for the given implementation of ' + name + '.');\n        }\n        handlerRegistry.set(impl, target);\n      }\n      return target;\n    }\n  }, {\n    key: 'getTypeConstructor',\n    value: function getTypeConstructor(impl) {\n      // Issue 252\n      var handlerRegistry = this[TypeConstructorRegistrySymbol];\n      handlerRegistry;\n\n      return handlerRegistry.get(impl);\n    }\n  }, {\n    key: 'literal',\n    value: function literal(input) {\n      if (input === undefined) {\n        return this.void();\n      } else if (input === null) {\n        return this.null();\n      } else if (typeof input === 'boolean') {\n        return this.boolean(input);\n      } else if (typeof input === 'number') {\n        return this.number(input);\n      } else if (typeof input === 'string') {\n        return this.string(input);\n      }\n      // Issue 252\n      else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'symbol') {\n          return this.symbol(input);\n        } else {\n          return this.typeOf(input);\n        }\n    }\n  }, {\n    key: 'null',\n    value: function _null() {\n      return primitiveTypes.null;\n    }\n  }, {\n    key: 'nullable',\n    value: function nullable(type) {\n      var target = new NullableType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'existential',\n    value: function existential() {\n      return primitiveTypes.existential;\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return primitiveTypes.empty;\n    }\n  }, {\n    key: 'any',\n    value: function any() {\n      return primitiveTypes.any;\n    }\n  }, {\n    key: 'mixed',\n    value: function mixed() {\n      return primitiveTypes.mixed;\n    }\n  }, {\n    key: 'void',\n    value: function _void() {\n      return primitiveTypes.void;\n    }\n  }, {\n    key: 'this',\n    value: function _this(input) {\n      var target = new ThisType(this);\n      if (input !== undefined) {\n        target.recorded = input;\n      }\n      return target;\n    }\n  }, {\n    key: 'number',\n    value: function number(input) {\n      if (input !== undefined) {\n        var target = new NumericLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.number;\n      }\n    }\n  }, {\n    key: 'boolean',\n    value: function boolean(input) {\n      if (input !== undefined) {\n        var target = new BooleanLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.boolean;\n      }\n    }\n  }, {\n    key: 'string',\n    value: function string(input) {\n      if (input !== undefined) {\n        var target = new StringLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.string;\n      }\n    }\n  }, {\n    key: 'symbol',\n    value: function symbol(input) {\n      if (input !== undefined) {\n        var target = new SymbolLiteralType(this);\n        target.value = input;\n        return target;\n      } else {\n        return primitiveTypes.symbol;\n      }\n    }\n  }, {\n    key: 'typeParameter',\n    value: function typeParameter(id, bound, defaultType) {\n      var target = new TypeParameter(this);\n      target.id = id;\n      target.bound = bound;\n      target.default = defaultType;\n      return target;\n    }\n  }, {\n    key: 'flowInto',\n    value: function flowInto(typeParameter) {\n      return flowIntoTypeParameter(typeParameter);\n    }\n\n    /**\n     * Bind the type parameters for the parent class of the given instance.\n     */\n\n  }, {\n    key: 'bindTypeParameters',\n    value: function bindTypeParameters(subject) {\n      var instancePrototype = Object.getPrototypeOf(subject);\n      // Issue\n      var parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n      // Issue\n      var parentClass = parentPrototype && parentPrototype.constructor;\n\n      if (!parentClass) {\n        this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n        return subject;\n      }\n      // Issue 252\n      var typeParametersPointer = parentClass[TypeParametersSymbol];\n\n      if (typeParametersPointer) {\n        var typeParameters = subject[typeParametersPointer];\n        var keys = Object.keys(typeParameters);\n\n        for (var _len2 = arguments.length, typeInstances = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          typeInstances[_key2 - 1] = arguments[_key2];\n        }\n\n        var length = Math.min(keys.length, typeInstances.length);\n        for (var i = 0; i < length; i++) {\n          var typeParam = typeParameters[keys[i]];\n          typeParam.bound = typeInstances[i];\n        }\n      }\n      return subject;\n    }\n  }, {\n    key: 'module',\n    value: function module(name, body) {\n      var target = new ModuleDeclaration(this);\n      target.name = name;\n      var innerContext = this.createContext();\n      // Issue 252\n      innerContext[ParentSymbol] = this;\n      // Issue 252\n      innerContext[CurrentModuleSymbol] = target;\n\n      target.innerContext = innerContext;\n      body(innerContext);\n      return target;\n    }\n  }, {\n    key: 'moduleExports',\n    value: function moduleExports(type) {\n      var currentModule = this[CurrentModuleSymbol];\n      if (!currentModule) {\n        throw new Error('Cannot declare module.exports outside of a module.');\n      }\n      var target = new ModuleExports(this);\n      target.type = type;\n      currentModule.moduleExports = target;\n      return target;\n    }\n  }, {\n    key: 'var',\n    value: function _var(name, type) {\n      var target = new VarDeclaration(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'class',\n    value: function _class(name, head) {\n      if (typeof head === 'function') {\n        var _target3 = new ParameterizedClassDeclaration(this);\n        _target3.name = name;\n        _target3.bodyCreator = head;\n        return _target3;\n      }\n      var target = new ClassDeclaration(this);\n      target.name = name;\n\n      for (var _len3 = arguments.length, tail = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        tail[_key3 - 2] = arguments[_key3];\n      }\n\n      if (head != null) {\n        tail.unshift(head);\n      }\n      var length = tail.length;\n\n      var properties = [];\n      var body = void 0;\n\n      for (var i = 0; i < length; i++) {\n        var item = tail[i];\n        if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n          properties.push(item);\n        } else if (item instanceof ObjectType) {\n          invariant(!body, 'Class body must only be declared once.');\n          body = item;\n        } else if (item instanceof ExtendsDeclaration) {\n          invariant(!target.superClass, 'Classes can only have one super class.');\n          target.superClass = item;\n        } else if (item != null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof Type)) {\n          for (var propertyName in item) {\n            // eslint-disable-line\n            properties.push(this.property(propertyName, item[propertyName]));\n          }\n        } else {\n          throw new Error('ClassDeclaration cannot contain the given type directly.');\n        }\n      }\n      if (!body) {\n        body = new ObjectType(this);\n      }\n      if (properties.length) {\n        var _body$properties;\n\n        (_body$properties = body.properties).push.apply(_body$properties, properties);\n      }\n      target.body = body;\n      return target;\n    }\n  }, {\n    key: 'extends',\n    value: function _extends(subject) {\n      var target = new ExtendsDeclaration(this);\n\n      for (var _len4 = arguments.length, typeInstances = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        typeInstances[_key4 - 1] = arguments[_key4];\n      }\n\n      target.type = this.ref.apply(this, [subject].concat(toConsumableArray(typeInstances)));\n      return target;\n    }\n  }, {\n    key: 'fn',\n    value: function fn(head) {\n      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        tail[_key5 - 1] = arguments[_key5];\n      }\n\n      return this.function.apply(this, [head].concat(tail));\n    }\n  }, {\n    key: 'function',\n    value: function _function(head) {\n      if (typeof head === 'function') {\n        var _target4 = new ParameterizedFunctionType(this);\n        _target4.bodyCreator = head;\n        return _target4;\n      }\n      var target = new FunctionType(this);\n      if (head != null) {\n        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          tail[_key6 - 1] = arguments[_key6];\n        }\n\n        tail.unshift(head);\n        var length = tail.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = tail[i];\n          if (item instanceof FunctionTypeParam) {\n            target.params.push(item);\n          } else if (item instanceof FunctionTypeRestParam) {\n            target.rest = item;\n          } else if (item instanceof FunctionTypeReturn) {\n            target.returnType = item;\n          } else {\n            throw new Error('FunctionType cannot contain the given type directly.');\n          }\n        }\n      }\n      if (!target.returnType) {\n        target.returnType = this.any();\n      }\n      return target;\n    }\n  }, {\n    key: 'param',\n    value: function param(name, type) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new FunctionTypeParam(this);\n      target.name = name;\n      target.type = type;\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'rest',\n    value: function rest(name, type) {\n      var target = new FunctionTypeRestParam(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'return',\n    value: function _return(type) {\n      var target = new FunctionTypeReturn(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: 'generator',\n    value: function generator(yieldType, returnType, nextType) {\n      var target = new GeneratorType(this);\n      target.yieldType = yieldType;\n      target.returnType = returnType || this.any();\n      target.nextType = nextType || this.any();\n      return target;\n    }\n  }, {\n    key: 'object',\n    value: function object(head) {\n      var target = new ObjectType(this);\n      if (head != null && (typeof head === 'undefined' ? 'undefined' : _typeof(head)) === 'object' && !(head instanceof Type)) {\n        for (var propertyName in head) {\n          // eslint-disable-line\n          target.properties.push(this.property(propertyName, head[propertyName]));\n        }\n      } else {\n        var body = void 0;\n\n        for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n          tail[_key7 - 1] = arguments[_key7];\n        }\n\n        if (head) {\n          body = [head].concat(toConsumableArray(tail));\n        } else {\n          body = tail;\n        }\n        var _body = body,\n            length = _body.length;\n\n        for (var i = 0; i < length; i++) {\n          var item = body[i];\n          if (item instanceof ObjectTypeProperty) {\n            target.properties.push(item);\n          } else if (item instanceof ObjectTypeIndexer) {\n            target.indexers.push(item);\n          } else if (item instanceof ObjectTypeCallProperty) {\n            target.callProperties.push(item);\n          } else {\n            throw new Error('ObjectType cannot contain the given type directly.');\n          }\n        }\n      }\n      return target;\n    }\n  }, {\n    key: 'exactObject',\n    value: function exactObject(head) {\n      for (var _len8 = arguments.length, tail = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        tail[_key8 - 1] = arguments[_key8];\n      }\n\n      var object = this.object.apply(this, [head].concat(toConsumableArray(tail)));\n      object.exact = true;\n      return object;\n    }\n  }, {\n    key: 'callProperty',\n    value: function callProperty(value) {\n      var target = new ObjectTypeCallProperty(this);\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'property',\n    value: function property(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var target = new ObjectTypeProperty(this);\n      target.key = key;\n      if (value instanceof Type) {\n        target.value = value;\n      } else {\n        target.value = this.object(value);\n      }\n      target.optional = optional;\n      return target;\n    }\n  }, {\n    key: 'indexer',\n    value: function indexer(id, key, value) {\n      var target = new ObjectTypeIndexer(this);\n      target.id = id;\n      target.key = key;\n      target.value = value;\n      return target;\n    }\n  }, {\n    key: 'method',\n    value: function method(name, head) {\n      var target = new ObjectTypeProperty(this);\n      target.key = name;\n\n      for (var _len9 = arguments.length, tail = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        tail[_key9 - 2] = arguments[_key9];\n      }\n\n      target.value = this.function.apply(this, [head].concat(tail));\n      return target;\n    }\n  }, {\n    key: 'staticCallProperty',\n    value: function staticCallProperty(value) {\n      var prop = this.callProperty(value);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticProperty',\n    value: function staticProperty(key, value) {\n      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var prop = this.property(key, value, optional);\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'staticMethod',\n    value: function staticMethod(name, head) {\n      for (var _len10 = arguments.length, tail = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        tail[_key10 - 2] = arguments[_key10];\n      }\n\n      var prop = this.method.apply(this, [name, head].concat(tail));\n      prop.static = true;\n      return prop;\n    }\n  }, {\n    key: 'tuple',\n    value: function tuple() {\n      var target = new TupleType(this);\n\n      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        types[_key11] = arguments[_key11];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'array',\n    value: function array(elementType) {\n      var target = new ArrayType(this);\n      target.elementType = elementType || this.any();\n      return target;\n    }\n  }, {\n    key: 'union',\n    value: function union() {\n      for (var _len12 = arguments.length, types = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        types[_key12] = arguments[_key12];\n      }\n\n      return makeUnion(this, types);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect() {\n      var target = new IntersectionType(this);\n\n      for (var _len13 = arguments.length, types = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        types[_key13] = arguments[_key13];\n      }\n\n      target.types = types;\n      return target;\n    }\n  }, {\n    key: 'intersection',\n    value: function intersection() {\n      return this.intersect.apply(this, arguments);\n    }\n  }, {\n    key: 'box',\n    value: function box(reveal) {\n      var box = new TypeBox(this);\n      box.reveal = reveal;\n      return box;\n    }\n  }, {\n    key: 'tdz',\n    value: function tdz(reveal, name) {\n      var tdz = new TypeTDZ(this);\n      tdz.reveal = reveal;\n      tdz.name = name;\n      return tdz;\n    }\n  }, {\n    key: 'ref',\n    value: function ref(subject) {\n      var target = void 0;\n      if (typeof subject === 'string') {\n        // try and eagerly resolve the reference\n        target = this.get(subject);\n        if (!target) {\n          // defer dereferencing for now\n          target = new TypeReference(this);\n          target.name = subject;\n        }\n      } else if (typeof subject === 'function') {\n        // Issue 252\n        var handlerRegistry = this[TypeConstructorRegistrySymbol];\n        handlerRegistry;\n\n        // see if we have a dedicated TypeConstructor for this.\n        target = handlerRegistry.get(subject);\n\n        if (!target) {\n          // just use a generic type handler.\n          target = new GenericType(this);\n          target.impl = subject;\n          target.name = subject.name;\n        }\n      } else if (subject instanceof Type) {\n        target = subject;\n      } else {\n        if (subject == null || (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) !== 'object') {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead. (got ' + String(subject) + ')');\n        } else if (!warnedInvalidReferences.has(subject)) {\n          this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n          warnedInvalidReferences.add(subject);\n        }\n        return this.any();\n      }\n\n      for (var _len14 = arguments.length, typeInstances = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n        typeInstances[_key14 - 1] = arguments[_key14];\n      }\n\n      if (typeInstances.length) {\n        var _target5;\n\n        invariant(typeof target.apply === 'function', 'Cannot apply non-applicable type: ' + target.typeName + '.');\n        return (_target5 = target).apply.apply(_target5, toConsumableArray(typeInstances));\n      } else {\n        return target;\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = new Validation(this, input);\n      if (path) {\n        var _validation$path;\n\n        (_validation$path = validation.path).push.apply(_validation$path, toConsumableArray(path));\n      } else if (typeof type.name === 'string') {\n        validation.path.push(type.name);\n      }\n      validation.prefix = prefix;\n      validation.errors = Array.from(type.errors(validation, [], input));\n      return validation;\n    }\n  }, {\n    key: 'check',\n    value: function check(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      if (this.mode === 'assert') {\n        return this.assert(type, input, prefix, path);\n      } else {\n        return this.warn(type, input, prefix, path);\n      }\n    }\n  }, {\n    key: 'assert',\n    value: function assert(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var error = this.makeTypeError(validation);\n      if (error) {\n        throw error;\n      }\n      return input;\n    }\n  }, {\n    key: 'warn',\n    value: function warn(type, input) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var path = arguments[3];\n\n      var validation = this.validate(type, input, prefix, path);\n      var message = makeWarningMessage(validation);\n      if (typeof message === 'string') {\n        this.emitWarningMessage(message);\n      }\n      return input;\n    }\n\n    /**\n     * Emits a warning message, using `console.warn()` by default.\n     */\n\n  }, {\n    key: 'emitWarningMessage',\n    value: function emitWarningMessage(message) {\n      console.warn('flow-runtime:', message);\n    }\n  }, {\n    key: 'propTypes',\n    value: function propTypes(type) {\n      return makeReactPropTypes(type.unwrap());\n    }\n  }, {\n    key: 'match',\n    value: function match() {\n      for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n\n      var clauses = args.pop();\n      if (!Array.isArray(clauses)) {\n        throw new Error('Invalid pattern, last argument must be an array.');\n      }\n      clauses;\n      var pattern = this.pattern.apply(this, toConsumableArray(clauses));\n      return pattern.apply(undefined, args);\n    }\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      for (var _len16 = arguments.length, clauses = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        clauses[_key16] = arguments[_key16];\n      }\n\n      var length = clauses.length;\n\n      var tests = new Array(length);\n      for (var i = 0; i < length; i++) {\n        var clause = clauses[i];\n        var annotation = this.getAnnotation(clause);\n        if (!annotation) {\n          if (i !== length - 1) {\n            throw new Error('Invalid Pattern - found unannotated function in position ' + i + ', default clauses must be last.');\n          }\n          tests[i] = true;\n        } else {\n          invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n          tests[i] = annotation;\n        }\n      }\n      return function () {\n        for (var _i = 0; _i < tests.length; _i++) {\n          var test = tests[_i];\n          var _clause = clauses[_i];\n          if (test === true) {\n            return _clause.apply(undefined, arguments);\n          } else if (test.acceptsParams.apply(test, arguments)) {\n            return _clause.apply(undefined, arguments);\n          }\n        }\n        var error = new TypeError('Value did not match any of the candidates.');\n        error.name = 'RuntimeTypeError';\n        throw error;\n      };\n    }\n  }, {\n    key: 'wrapIterator',\n    value: function wrapIterator(type) {\n      var t = this;\n      return _regeneratorRuntime.mark(function wrappedIterator(input) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;\n\n        return _regeneratorRuntime.wrap(function wrappedIterator$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context3.prev = 3;\n                _iterator = input[Symbol.iterator]();\n\n              case 5:\n                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                item = _step.value;\n                _context3.next = 9;\n                return t.check(type, item);\n\n              case 9:\n                _iteratorNormalCompletion = true;\n                _context3.next = 5;\n                break;\n\n              case 12:\n                _context3.next = 18;\n                break;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3['catch'](3);\n                _didIteratorError = true;\n                _iteratorError = _context3.t0;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.prev = 19;\n\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n\n              case 21:\n                _context3.prev = 21;\n\n                if (!_didIteratorError) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 24:\n                return _context3.finish(21);\n\n              case 25:\n                return _context3.finish(18);\n\n              case 26:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, wrappedIterator, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n      });\n    }\n  }, {\n    key: 'refinement',\n    value: function refinement(type) {\n      var target = new RefinementType(this);\n      target.type = type;\n\n      for (var _len17 = arguments.length, constraints = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n        constraints[_key17 - 1] = arguments[_key17];\n      }\n\n      target.addConstraint.apply(target, toConsumableArray(constraints));\n      return target;\n    }\n  }, {\n    key: '$diff',\n    value: function $diff(aType, bType) {\n      var target = new $DiffType(this);\n      target.aType = aType;\n      target.bType = bType;\n      return target;\n    }\n  }, {\n    key: '$flowFixMe',\n    value: function $flowFixMe() {\n      return new $FlowFixMeType(this);\n    }\n  }, {\n    key: '$keys',\n    value: function $keys(type) {\n      var target = new $KeysType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$objMap',\n    value: function $objMap(object, mapper) {\n      var target = new $ObjMapType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$objMapi',\n    value: function $objMapi(object, mapper) {\n      var target = new $ObjMapiType(this);\n      target.object = object;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: '$propertyType',\n    value: function $propertyType(object, property) {\n      var target = new $PropertyType(this);\n      target.object = object;\n      if (property instanceof Type) {\n        var unwrapped = property.unwrap();\n        target.property = unwrapped.value;\n      } else {\n        target.property = property;\n      }\n      return target;\n    }\n  }, {\n    key: '$shape',\n    value: function $shape(type) {\n      var target = new $ShapeType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$subtype',\n    value: function $subtype(type) {\n      var target = new $SubType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$supertype',\n    value: function $supertype(type) {\n      var target = new $SuperType(this);\n      target.type = type;\n      return target;\n    }\n  }, {\n    key: '$tupleMap',\n    value: function $tupleMap(tuple, mapper) {\n      var target = new $TupleMapType(this);\n      target.tuple = tuple;\n      target.mapper = mapper;\n      return target;\n    }\n  }, {\n    key: 'Class',\n    value: function Class(instanceType) {\n      var target = new ClassType(this);\n      target.instanceType = instanceType;\n      return target;\n    }\n  }, {\n    key: 'TypeParametersSymbol',\n\n\n    // Issue 252\n    get: function get$$1() {\n      return TypeParametersSymbol;\n    }\n  }]);\n  return TypeContext;\n}();\n\nvar globalContext$1 = void 0;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext$1 = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n} else {\n  globalContext$1 = new TypeContext();\n  registerPrimitiveTypes(globalContext$1);\n  registerBuiltinTypeConstructors(globalContext$1);\n  registerTypePredicates(globalContext$1);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext$1;\n  }\n}\n\nvar globalContext$2 = globalContext$1;\n\nfunction defineProperty(name, value) {\n  Object.defineProperty(globalContext$2, name, {\n    value: value\n  });\n}\n\ndefineProperty('TypeContext', TypeContext);\ndefineProperty('Type', Type);\ndefineProperty('TypeBox', TypeBox);\ndefineProperty('TypeParameter', TypeParameter);\ndefineProperty('TypeReference', TypeReference);\ndefineProperty('TypeTDZ', TypeTDZ);\ndefineProperty('ParameterizedTypeAlias', ParameterizedTypeAlias);\ndefineProperty('TypeAlias', TypeAlias);\ndefineProperty('TypeConstructor', TypeConstructor);\ndefineProperty('GenericType', GenericType);\ndefineProperty('NullLiteralType', NullLiteralType);\ndefineProperty('NumberType', NumberType);\ndefineProperty('NumericLiteralType', NumericLiteralType);\ndefineProperty('BooleanType', BooleanType);\ndefineProperty('BooleanLiteralType', BooleanLiteralType);\ndefineProperty('SymbolType', SymbolType);\ndefineProperty('SymbolLiteralType', SymbolLiteralType);\ndefineProperty('StringType', StringType);\ndefineProperty('StringLiteralType', StringLiteralType);\ndefineProperty('ArrayType', ArrayType);\ndefineProperty('ObjectType', ObjectType);\ndefineProperty('ObjectTypeCallProperty', ObjectTypeCallProperty);\ndefineProperty('ObjectTypeIndexer', ObjectTypeIndexer);\ndefineProperty('ObjectTypeProperty', ObjectTypeProperty);\ndefineProperty('FunctionType', FunctionType);\ndefineProperty('FunctionTypeParam', FunctionTypeParam);\ndefineProperty('FunctionTypeRestParam', FunctionTypeRestParam);\ndefineProperty('FunctionTypeReturn', FunctionTypeReturn);\ndefineProperty('ParameterizedFunctionType', ParameterizedFunctionType);\ndefineProperty('PartialType', PartialType);\ndefineProperty('RefinementType', RefinementType);\ndefineProperty('TypeParameterApplication', TypeParameterApplication);\ndefineProperty('GeneratorType', GeneratorType);\ndefineProperty('ExistentialType', ExistentialType);\ndefineProperty('FlowIntoType', FlowIntoType);\ndefineProperty('AnyType', AnyType);\ndefineProperty('MixedType', MixedType);\ndefineProperty('EmptyType', EmptyType);\ndefineProperty('NullableType', NullableType);\ndefineProperty('ThisType', ThisType);\ndefineProperty('TupleType', TupleType);\ndefineProperty('UnionType', UnionType);\ndefineProperty('IntersectionType', IntersectionType);\ndefineProperty('VoidType', VoidType);\ndefineProperty('Declaration', Declaration);\ndefineProperty('VarDeclaration', VarDeclaration);\ndefineProperty('TypeDeclaration', TypeDeclaration);\ndefineProperty('ModuleDeclaration', ModuleDeclaration);\ndefineProperty('ModuleExportsDeclaration', ModuleExports);\ndefineProperty('ClassDeclaration', ClassDeclaration);\ndefineProperty('ParameterizedClassDeclaration', ParameterizedClassDeclaration);\ndefineProperty('ExtendsDeclaration', ExtendsDeclaration);\n\nreturn globalContext$2;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(3);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar t = __webpack_require__(1);\nvar map = new Map();\nvar voidType = t.void;\nvar intersect = t.intersect;\nvar declare = t.declare;\nvar ref = t.ref;\nvar decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\nt.undef = function () {\n    return voidType.bind(t)();\n};\nt.nostrict = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args.concat([t.null(), t.undef()]));\n};\nt.void = function () {\n    return t.union(t.null(), t.undef());\n};\nt.n = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.nullable.apply(t, args);\n};\nt.enum = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.union.apply(t, args);\n};\nt.enumMember = function (arg) {\n    return t.literal(arg);\n};\nt.enumRef = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return t.typeOf.apply(t, args);\n};\nexports.default = t;\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ts-runtime.lib.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6cf55abbc1b919903bb7","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeJSONError.js","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}\n\n\n// WEBPACK FOOTER //\n// ../src/cyclic.js","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/Validation.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`);\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeTypeError.js","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/makeError.js","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/compareTypes.js","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/getErrorMessage.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from './FlowIntoType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    }\n    else if (recorded) {\n      return recorded.accepts(input);\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameter.js","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/invariant.js","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/typeConstraints.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ParameterizedClassDeclaration.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else if (this.exact) {\n      result = acceptsExact(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        yield* property.errors(validation, path, input);\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/IntersectionType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedTypeAlias.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ParameterizedFunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeTDZ.js","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeReactPropTypes.js","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/makeWarningMessage.js","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/makeUnion.js","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/classDecorators.js","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/annotateValue.js","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/ClassType.js","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction defineProperty (name: string, value: any) {\n  Object.defineProperty(globalContext, name, {\n    value: value\n  });\n}\n\ndefineProperty('TypeContext', TypeContext);\ndefineProperty('Type', Type);\ndefineProperty('TypeBox', TypeBox);\ndefineProperty('TypeParameter', TypeParameter);\ndefineProperty('TypeReference', TypeReference);\ndefineProperty('TypeTDZ', TypeTDZ);\ndefineProperty('ParameterizedTypeAlias', ParameterizedTypeAlias);\ndefineProperty('TypeAlias', TypeAlias);\ndefineProperty('TypeConstructor', TypeConstructor);\ndefineProperty('GenericType', GenericType);\ndefineProperty('NullLiteralType', NullLiteralType);\ndefineProperty('NumberType', NumberType);\ndefineProperty('NumericLiteralType', NumericLiteralType);\ndefineProperty('BooleanType', BooleanType);\ndefineProperty('BooleanLiteralType', BooleanLiteralType);\ndefineProperty('SymbolType', SymbolType);\ndefineProperty('SymbolLiteralType', SymbolLiteralType);\ndefineProperty('StringType', StringType);\ndefineProperty('StringLiteralType', StringLiteralType);\ndefineProperty('ArrayType', ArrayType);\ndefineProperty('ObjectType', ObjectType);\ndefineProperty('ObjectTypeCallProperty', ObjectTypeCallProperty);\ndefineProperty('ObjectTypeIndexer', ObjectTypeIndexer);\ndefineProperty('ObjectTypeProperty', ObjectTypeProperty);\ndefineProperty('FunctionType', FunctionType);\ndefineProperty('FunctionTypeParam', FunctionTypeParam);\ndefineProperty('FunctionTypeRestParam', FunctionTypeRestParam);\ndefineProperty('FunctionTypeReturn', FunctionTypeReturn);\ndefineProperty('ParameterizedFunctionType', ParameterizedFunctionType);\ndefineProperty('PartialType', PartialType);\ndefineProperty('RefinementType', RefinementType);\ndefineProperty('TypeParameterApplication', TypeParameterApplication);\ndefineProperty('GeneratorType', GeneratorType);\ndefineProperty('ExistentialType', ExistentialType);\ndefineProperty('FlowIntoType', FlowIntoType);\ndefineProperty('AnyType', AnyType);\ndefineProperty('MixedType', MixedType);\ndefineProperty('EmptyType', EmptyType);\ndefineProperty('NullableType', NullableType);\ndefineProperty('ThisType', ThisType);\ndefineProperty('TupleType', TupleType);\ndefineProperty('UnionType', UnionType);\ndefineProperty('IntersectionType', IntersectionType);\ndefineProperty('VoidType', VoidType);\ndefineProperty('Declaration', Declaration);\ndefineProperty('VarDeclaration', VarDeclaration);\ndefineProperty('TypeDeclaration', TypeDeclaration);\ndefineProperty('ModuleDeclaration', ModuleDeclaration);\ndefineProperty('ModuleExportsDeclaration', ModuleExportsDeclaration);\ndefineProperty('ClassDeclaration', ClassDeclaration);\ndefineProperty('ParameterizedClassDeclaration', ParameterizedClassDeclaration);\ndefineProperty('ExtendsDeclaration', ExtendsDeclaration);\n\nexport default globalContext;\n\n\n\n// WEBPACK FOOTER //\n// ../src/index.cjs.js","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;\n\n\n// WEBPACK FOOTER //\n// ../src/primitiveTypes.js","export default require(\"regenerator-runtime\");\n\n\n\n// WEBPACK FOOTER //\n// ../~/rollup-regenerator-runtime/regenerator/index.js","/* @flow */\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n}\n\n\n// WEBPACK FOOTER //\n// ../src/errorReporting/RuntimeTypeError.js","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/Type.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/AnyType.js","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exists on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n\n\n// WEBPACK FOOTER //\n// ../src/errorMessages.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/TupleType.js","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ArrayType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/BooleanType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/EmptyType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ExistentialType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FlowIntoType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeRestParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeParam.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionTypeReturn.js","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n\n\n\n// WEBPACK FOOTER //\n// ../src/symbols.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/FunctionType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GeneratorType.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeParameterApplication.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeConstructor.js","/* @flow */\n\nimport TypeConstructor from './TypeConstructor';\n\nimport type Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GenericType extends TypeConstructor {\n\n  typeName: string = 'GenericType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {name, impl, context} = this;\n    if (!(input instanceof impl)) {\n      const annotation = context.getAnnotation(impl);\n      if (annotation) {\n        yield* annotation.errors(validation, path, input);\n      }\n      else {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', name), this];\n      }\n    }\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, impl} = this;\n    if (input instanceof impl) {\n      return true;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      return annotation.accepts(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  compareWith <P> (input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const {context, impl} = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    }\n    else if (input instanceof GenericType && (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  unwrap <P> (...typeInstances: Type<P>[]) {\n    const {context, impl} = this;\n    if (typeof impl !== 'function') {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    }\n    else {\n      return this;\n    }\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/GenericType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullLiteralType.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/VoidType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NullableType.js","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeProperty.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeIndexer.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/ObjectTypeCallProperty.js","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/Declaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/VarDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/TypeDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ModuleExportsDeclaration.js","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ClassDeclaration.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/PartialType.js","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/declarations/ExtendsDeclaration.js","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/MixedType.js","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeAlias.js","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumericLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/NumberType.js","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/RefinementType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/StringType.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolLiteralType.js","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/SymbolType.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/ThisType.js","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeBox.js","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/types/TypeReference.js","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/types/UnionType.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;\n\n\n// WEBPACK FOOTER //\n// ../src/TypeInferrer.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$DiffType.js","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$FlowFixMeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$KeysType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapiType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ObjMapType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$PropertyType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$ShapeType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SubType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$SuperType.js","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ../src/flowTypes/$TupleMapType.js","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/TypeContext.js","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;\n\n\n// WEBPACK FOOTER //\n// ../src/globalContext.js","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerPrimitiveTypes.js","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerBuiltins.js","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    }\n    else if (input !== null && typeof input === 'object' && typeof input.then === 'function') {\n      return input.then.length >= 2;\n    }\n    else {\n      return false;\n    }\n  });\n}\n\n\n// WEBPACK FOOTER //\n// ../src/registerTypePredicates.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime-module.js\n// module id = 2\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 3\n// module chunks = 0","import * as t from 'flow-runtime';\n\nconst map: Map<string, any> = new Map();\n\nconst voidType = t.void;\nconst intersect = t.intersect;\nconst declare = t.declare;\nconst ref = t.ref;\nconst decorate = t.decorate;\n\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n\nt.undef = () => {\n  return voidType.bind(t)();\n}\n\nt.nostrict = (...args: any[]) => {\n  return t.union(...args, t.null(), t.undef());\n}\n\nt.void = () => {\n  return t.union(t.null(), t.undef());\n}\n\nt.n = (...args: any[]) => {\n  return t.nullable(...args);\n}\n\nt.enum = (...args: any[]) => {\n  return t.union(...args);\n}\n\nt.enumMember = (arg: any) => {\n  return t.literal(arg);\n}\n\nt.enumRef = (...args: any[]) => {\n  return t.typeOf(...args);\n}\n\nexport default t;\n\n\n\n// WEBPACK FOOTER //\n// ./~/source-map-loader!./src/lib/index.ts"],"sourceRoot":""}